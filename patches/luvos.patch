diff --git a/build_luvos.sh b/build_luvos.sh
new file mode 100755
index 0000000..30b9ae2
--- /dev/null
+++ b/build_luvos.sh
@@ -0,0 +1,90 @@
+#!/bin/bash
+# The material contained herein is not a license, either
+# expressly or impliedly, to any intellectual property owned
+# or controlled by any of the authors or developers of this
+# material or to any contribution thereto. The material
+# contained herein is provided on an "AS IS" basis and, to the
+# maximum extent permitted by applicable law, this information
+# is provided AS IS AND WITH ALL FAULTS, and the authors and
+# developers of this material hereby disclaim all other
+# warranties and conditions, either express, implied or
+# statutory, including, but not limited to, any (if any)
+# implied warranties, duties or conditions of merchantability,
+# of fitness for a particular purpose, of accuracy or
+# completeness of responses, of results, of workmanlike
+# effort, of lack of viruses and of lack of negligence, all
+# with regard to this material and any contribution thereto.
+# Designers must not rely on the absence or characteristics of
+# any features or instructions marked "reserved" or
+# "undefined." The ARM, Inc. reserves any
+# features or instructions so marked for future definition and
+# shall have no responsibility whatsoever for conflicts or
+# incompatibilities arising from future changes to them. ALSO,
+# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
+# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
+# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
+# CONTRIBUTION THERETO.
+#
+# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
+# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
+# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
+# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
+# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
+# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
+# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
+# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
+# THE POSSIBILITY OF SUCH DAMAGES.
+#
+# Copyright 2016 ARM, Inc. All
+# Rights Reserved, subject to all existing rights in all
+# matters included within this Test Suite, to which ARM, Inc.
+# makes no claim of right.
+#
+# Copyright (c) 2016 ARM Ltd. All rights reserved.<BR>
+#
+TOPDIR=`pwd`
+
+METALUV="$TOPDIR/meta-luv \\\\"
+BB_CONF="conf/bblayers.conf"
+LOCAL_CONF="conf/local.conf"
+MACHINE="\"qemuarm64\""
+LUV="\"luv\""
+NUM_THREADS="BB_NUMBER_THREADS ?= \"16\""
+OUTPUT_FILE="$PWD/build/tmp/deploy/images/qemuarm64/luv-live-image.img"
+
+echo "Building LuvOS Image with SBBR and SBSA for AARCH4 ..."
+echo "UEFI-SCT source is available only to members of UEFI Forum."
+echo "Please abort, if you are not a member."
+echo "Authentication Required for https://github.com/UEFI/UEFI-SCT"
+echo -n User:
+read SCTUSERNAME
+echo -n Password:
+read -s SCTPASSWORD
+export SCTUSERNAME
+export SCTPASSWORD
+rm -rf build
+source oe-init-build-env
+export BB_ENV_EXTRAWHITE="BB_ENV_EXTRAWHITE SCTUSERNAME SCTPASSWORD"
+
+# include meta-luv  for building
+line=`grep -n "meta-yocto-bsp" $BB_CONF | cut -d : -f 1`
+sed -i "$line a $(echo "  $METALUV")" $BB_CONF
+
+# modify local.conf to edit Machine Type, Distro and Number of Threads
+sed -i -e "s/\(MACHINE ??= \).*/\1$MACHINE/" $LOCAL_CONF
+sed -i -e "s/\(DISTRO ?= \).*/\1$LUV/" $LOCAL_CONF
+sed -i -e "\$aEXTRA_IMAGE_FEATURES += \"dev-pkgs\"" $LOCAL_CONF
+echo >> $LOCAL_CONF
+echo "$NUM_THREADS" >> $LOCAL_CONF
+
+bitbake -c cleanall sbbr
+bitbake -c cleanall sbsa
+bitbake -c cleanall luv-live-image
+bitbake sbbr
+bitbake sbsa
+bitbake luv-live-image
+unset BB_ENV_EXTRAWHITE
+unset SCTPASSWORD
+unset SCTUSERNAME
+echo "Built image can be found at $OUTPUT_FILE"
+exit
diff --git a/meta-luv/classes/luv-efi.bbclass b/meta-luv/classes/luv-efi.bbclass
index 889bbce..ced456a 100644
--- a/meta-luv/classes/luv-efi.bbclass
+++ b/meta-luv/classes/luv-efi.bbclass
@@ -16,6 +16,13 @@ def get_bits_depends(bb, d):
                  return ""
 _BITSDEPENDS = "${@get_bits_depends(bb, d)}"
 
+def get_sbbr_depends(bb, d):
+         import re
+         deps = bb.data.getVar('TARGET_PREFIX', d, True)
+         if re.search("aarch64",deps):
+                 return "sbbr:do_deploy"
+_SBBRDEPENDS = "${@get_sbbr_depends(bb, d)}"
+
 # The x86 build is depends on grub-efi and AArch64 build depends on grub_git
 def get_grub_depends(bb, d):
          import re
@@ -56,8 +63,9 @@ efi_populate() {
 
     # Install grub2 in EFI directory
     if [ "${TARGET_ARCH}" = "aarch64" ]; then
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
-                echo "bootaa64.efi" > ${DEST}${EFIDIR}/startup.nsh
+                efi_populate_sbbr ${DEST}
+                efi_populate_sbsa ${DEST}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
 
     # TODO: need conditional signing; e.g., if (DISTRO_FEATURES contains secure_boot)
     # shim bootloader does not seem to work with i386. Thus we don't use it for 32-bit
@@ -81,7 +89,7 @@ efi_populate() {
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEPLOY_DIR_IMAGE}/shim.efi
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}-unsigned ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}
     else
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
     fi
 
     if echo "${TARGET_ARCH}" | grep -q "i.86" || [ "${TARGET_ARCH}" = "x86_64" ]; then
@@ -94,6 +102,25 @@ efi_populate() {
     install -m 0644 ${WORKDIR}/${SPLASH_IMAGE} ${DEST}${EFIDIR}
 }
 
+efi_populate_sbbr() {
+    DEST=$1
+    cp -r ${DEPLOY_DIR_IMAGE}/sbbr ${DEST}${EFIDIR}/sbbr
+    mv ${DEST}${EFIDIR}/sbbr/Shell.efi ${DEST}${EFIDIR}/Shell.efi
+    echo "echo -off
+          for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F
+            if exist FS%i:\SCT\Overall\Summary.log then
+              bootaa64.efi
+              goto Done
+            endif
+          endfor
+          :Done" > ${DEST}${EFIDIR}/startup.nsh
+}
+
+efi_populate_sbsa() {
+        DEST=$1
+        cp -r ${DEPLOY_DIR_IMAGE}/sbsa ${DEST}${EFIDIR}/sbsa
+}
+
 efi_populate_bits() {
     DEST=$1
     # TODO: weird behavior here. When building luv-live-image,
@@ -173,6 +200,11 @@ python build_efi_cfg() {
        cfgfile.write('timeout=0\n')
        cfgfile.write('fallback=0\n')
 
+    if "${TARGET_ARCH}" == "aarch64":
+       cfgfile.write('default=sbbr/sbsa\n')
+       cfgfile.write('timeout=1\n')
+       cfgfile.write('fallback=0\n')
+
     cfgfile.write('menuentry \'luv\' {\n')
     if re.search("(x86_64|i.86)", target):
        cfgfile.write('linux /vmlinuz')
@@ -204,6 +236,11 @@ python build_efi_cfg() {
        cfgfile.write('chainloader /EFI/BOOT/bits/%s\n' % loader)
        cfgfile.write('}\n')
 
+    if "${TARGET_ARCH}" == "aarch64":
+       cfgfile.write('menuentry \'sbbr/sbsa\' {\n')
+       cfgfile.write('chainloader /EFI/BOOT/Shell.efi\n')
+       cfgfile.write('}\n')
+
     cfgfile.close()
 }
 
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/README.md b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
new file mode 100644
index 0000000..06f0264
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
@@ -0,0 +1,2 @@
+UEFI-SCT
+========
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
new file mode 100644
index 0000000..758cdcc
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
@@ -0,0 +1,98 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+SUMMARY = "SBBR is a test suite that runs Server Base Boot Requirements UEFI tests."
+
+DESCRIPTION = "This Server Base Boot Requirements (SBBR) test suite is intended \
+for SBSA[2]-compliant 64-bit ARMv8 servers. It defines the base firmware requirements \
+for out-of-box support of any ARM SBSA-compatible Operating System or hypervisor. \
+The tests are expected to be minimal yet complete for booting a multi-core \
+ARMv8 server platform, while leaving plenty of room \
+for OEM or ODM innovations and design details."
+
+# Home Page
+HOMEPAGE = "https://github.com/UEFI/UEFI-SCT"
+
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+SBBRVERSION="v1.0"
+PV="${SBBRVERSION}+git${SRCPV}"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+# No information for SRC_URI yet (only an external source tree was specified)
+SRCREV  = "d38be6dae3e7f67bdf52595288906d6832e0d893"
+SRC_URI = "git://github.com/UEFI/UEFI-SCT.git;protocol=https;branch=sbbr;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+          "
+
+# NOTE: no Makefile found, unable to determine what needs to be done
+
+do_configure () {
+	# Specify any needed configure commands here
+	:
+	echo "do_configure()"
+	# Specify any needed configure commands here
+	rm -rf edk2
+	git clone https://github.com/tianocore/edk2
+	cd edk2
+	git checkout c0584d0bdd4463551db8f8c62a5e2936ec97b407
+	ln -s ../SctPkg SctPkg
+	chmod +x SctPkg/build_sbbr.sh
+	cd ..
+
+	mkdir -p "tools/gcc"
+	cd "tools/gcc"
+	wget -nv "https://releases.linaro.org/components/toolchain/binaries/4.9-2016.02/aarch64-linux-gnu/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz"
+	#Untar the GCC Linaro files.
+	tar -xf gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz
+	cd ../..
+}
+
+do_compile () {
+	# Specify compilation commands here
+	:
+	echo "$PWD: do_compile()"
+	export PATH=$PATH:"$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE PATH"
+	echo "New PATH = $PATH"
+	export CROSS_COMPILE="$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE CROSS_COMPILE"
+	echo "NEW CROSS_COMPILE: $CROSS_COMPILE"
+
+	cd edk2
+	./SctPkg/build_sbbr.sh AARCH64 GCC
+	cd ..
+}
+
+do_install () {
+	# Specify install commands here
+	:
+	echo "do_install()"
+	echo "Destination Directory: ${D}"
+	echo "Source Directory: ${B}"
+	cp -r ${B}/edk2/Build/SbbrSct/DEBUG_GCC49/SctPackageAARCH64 ${D}/sbbr
+	cp ${B}/edk2/ShellBinPkg/UefiShell/AArch64/Shell.efi ${D}/sbbr/Shell.efi
+}
+
+do_deploy () {
+	# Specify deploy commands here
+	:
+	echo "do_deploy()"
+	echo "Destination Directory: ${DEPLOYDIR}"
+	echo "Source Directory: ${D}"
+	install -d ${DEPLOYDIR}
+	cp -r ${D}/sbbr ${DEPLOYDIR}/sbbr
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-bsp/sbsa/files/compile.sh b/meta-luv/recipes-bsp/sbsa/files/compile.sh
new file mode 100755
index 0000000..4b86191
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/files/compile.sh
@@ -0,0 +1,16 @@
+#!/usr/bin/env bash
+
+
+cd ${1}/edk2
+
+export GCC49_AARCH64_PREFIX=${1}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+
+echo "do_compile: Initializing EDK2 for building."
+set --
+source edksetup.sh
+
+echo "do_compile: Building BaseTools."
+make -C BaseTools/Source/C
+
+echo "do_compile: Building SBSA."
+source AppPkg/Applications/sbsa-acs/tools/scripts/avsbuild.sh
\ No newline at end of file
diff --git a/meta-luv/recipes-bsp/sbsa/sbsa.bb b/meta-luv/recipes-bsp/sbsa/sbsa.bb
new file mode 100644
index 0000000..0543333
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/sbsa.bb
@@ -0,0 +1,105 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+# SCT files placed in ${WORKDIR}/git
+# GCC files placed in ${WORKDIR}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu
+SRC_URI = "git://github.com/ARM-software/sbsa-acs.git;protocol=https;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+           https://releases.linaro.org/components/toolchain/binaries/latest-5/aarch64-linux-gnu/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu.tar.xz \
+           file://compile.sh"
+
+PV = "1.0+git${SRCPV}"
+SRCREV = "${AUTOREV}"
+
+# GCC checksum.
+SRC_URI[md5sum] = "24ac2e26f50f49f3043f281440b41bba"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+do_configure () {
+
+    # Downloading EDK2 into ${WORKDIR}/edk2.
+    echo "do_configure: Checking if EDK2 repository already exists."
+    cd ${WORKDIR}
+    if [ ! -d ${WORKDIR}/edk2 ]
+    then
+        echo "do_configure: Cloning EDK2 repository."
+        git clone https://github.com/tianocore/edk2.git
+    fi
+
+    # Linking SBSA and EDK2.
+    echo "do_configure: Linking SBSA to EDK2."
+    cd ${WORKDIR}/git/uefi_app
+    if [ -d val ]
+    then
+        echo "do_configure: Existing val found, deleted."
+        rm val
+    fi
+    if [ -d pal ]
+    then
+        echo "do_configure: Existing pal found, deleted."
+        rm pal
+    fi
+    if [ -d test_pool ]
+    then
+        echo "do_configure: Existing test_pool found, deleted."
+        rm test_pool
+    fi
+    cd ${WORKDIR}/edk2/AppPkg/Applications
+    if [ -d sbsa-acs ]
+    then
+        echo "do_configure: Existing sbsa-acs found, deleted."
+        rm sbsa-acs
+    fi
+    cd ${WORKDIR}/git
+    set -- "${WORKDIR}/git" "${WORKDIR}/edk2"
+    . ${WORKDIR}/git/tools/scripts/avssetup.sh
+    set --
+    cd ../..
+
+    # Modifying EDK2 to build SBSA.
+    echo "do_configure: Modifying edk2/ShellPkg/ShellPkg.dsc to build SBSA."
+    if ! grep -q SbsaPalLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaPalLib|AppPkg/Applications/sbsa-acs/platform/pal_uefi/SbsaPalLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaValLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaValLib|AppPkg/Applications/sbsa-acs/val/SbsaValLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaAvs "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/Components/ a \ \ AppPkg/Applications/sbsa-acs/uefi_app/SbsaAvs.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+}
+
+do_compile () {
+    cd ${WORKDIR}
+    ./compile.sh ${WORKDIR}
+}
+
+do_install () {
+    echo "do_install: Copying SBSA files to destination ${D}"
+    mkdir ${D}/sbsa
+	cp ${WORKDIR}/edk2/Build/Shell/DEBUG_GCC49/AARCH64/Sbsa.efi ${D}/sbsa/Sbsa.efi
+}
+
+do_deploy () {
+    echo "do_deploy: Deploying SBSA files to destionation ${DEPLOYDIR}"
+    install -d ${DEPLOYDIR}
+    cp -r ${D}/sbsa ${DEPLOYDIR}/sbsa
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-core/fwts/fwts/sbbr.patch b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
new file mode 100644
index 0000000..53e5cb7
--- /dev/null
+++ b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
@@ -0,0 +1,823 @@
+diff --git a/src/acpi/acpitables/acpitables.c b/src/acpi/acpitables/acpitables.c
+index 064dabe..99ac65a 100644
+--- a/src/acpi/acpitables/acpitables.c
++++ b/src/acpi/acpitables/acpitables.c
+@@ -14,7 +14,10 @@
+  *
+  */
+ #include "fwts.h"
+-
++#include "acpi.h"
++#include "accommon.h"
++#include "acnamesp.h"
++#include "actables.h"
+ #if defined(FWTS_HAS_ACPI)
+ 
+ #include <stdio.h>
+@@ -27,6 +30,12 @@
+ #include <unistd.h>
+ #include <inttypes.h>
+ 
++#define MIN_SIG 4
++#define OEM_ID 6
++#define OEM_TABLE_ID 8
++#define OEM_CREATOR_ID 4
++#define FADT_MAX_MAJOR_REVISION ((uint8_t)6)
++
+ static bool acpi_table_check_field(const char *field, const size_t len)
+ {
+ 	size_t i;
+@@ -106,7 +115,7 @@ static int acpi_table_check_test1(fwts_framework *fw)
+ 		passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, 4) &
+ 			 acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, 6) &
+ 			 acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, 8) &
+-			acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, 4);
++			 acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, 4);
+ 		if (passed)
+ 			fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
+ 
+@@ -116,9 +125,193 @@ static int acpi_table_check_test1(fwts_framework *fw)
+ 
+ 	return FWTS_OK;
+ }
++/* Callback function used when searching for processor devices in namespace. */
++ACPI_STATUS processor_handler(ACPI_HANDLE ObjHandle, uint32_t level, void *context,
++                              void **returnvalue)
++{
++	ACPI_NAMESPACE_NODE *node = (ACPI_NAMESPACE_NODE *)ObjHandle;
++	ACPI_NAMESPACE_NODE *parent = node->Parent;
++	int error_count;
++
++	/* Unused parameters trigger errors. */
++	FWTS_UNUSED(level);
++	FWTS_UNUSED(context);
++
++	/* If the processor device is not located under _SB_, increment the error_count. */
++	if (strncmp(parent->Name.Ascii, "_SB_", sizeof(int32_t)) != 0) {
++		error_count = *((int *)returnvalue);
++		error_count++;
++		*((int *)returnvalue) = error_count;
++	}
++
++	/* Return 0 so namespace search continues. */
++	return 0;
++}
++
++/* Test function that makes sure processors are under the _SB_ namespace. */
++static int acpi_namespace_check_test2(fwts_framework *fw)
++{
++	int error_count = 0;
++
++	/* Initializing ACPICA library so we can call AcpiWalkNamespace. */
++	if (fwts_acpica_init(fw) != FWTS_OK)
++		return FWTS_ERROR;
++
++	/* Searching for all processor devices in the namespace. */
++	AcpiWalkNamespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
++	                  processor_handler, NULL, NULL, (void **)&error_count);
++
++	/* Deinitializing ACPICA, if we don't call this the terminal will break on exit. */
++	fwts_acpica_deinit();
++
++	/* error_count variable counts the number of processors outside of the _SB_ namespace. */
++	if (error_count > 0)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiCpuWrongNamespace", "%d Processor devices "
++		            "were found outside of the _SB_ namespace.", error_count);
++	else
++		fwts_passed(fw, "All processor devices were located in the _SB_ namespace.");
++
++	return FWTS_OK;
++}
++
++static int acpi_table_check_test3(fwts_framework *fw)
++{
++	int i;
++	bool checked = false;
++	bool dsdt_checked = false;
++	bool ssdt_checked = false;
++
++	for (i = 0; ; i++) {
++		fwts_acpi_table_info *info;
++		fwts_acpi_table_header *hdr;
++		char name[50];
++		bool passed;
++
++		if (fwts_acpi_get_table(fw, i, &info) != FWTS_OK)
++			break;
++		if (info == NULL)
++			continue;
++
++		checked = true;
++		if (!strcmp(info->name, "DSDT") ||
++			!strcmp(info->name, "SSDT")) {
++			if (!strcmp(info->name, "DSDT")) {
++				dsdt_checked = true;
++			}
++			if (!strcmp(info->name, "SSDT")) {
++				ssdt_checked = true;
++			}
++			hdr = (fwts_acpi_table_header *)info->data;
++			if (acpi_table_check_field(hdr->signature, MIN_SIG)) {
++				snprintf(name, sizeof(name), "%4.4s", hdr->signature);
++			} else {
++				/* Table name not printable, so identify it by the address */
++				snprintf(name, sizeof(name), "at address 0x%" PRIx64, info->addr);
++			}
++
++			/*
++			 * Tables shouldn't be short, however, they do have at
++			 * least 4 bytes with their signature else they would not
++			 * have been loaded by this stage.
++			 */
++			if (hdr->length < sizeof(fwts_acpi_table_header)) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, "ACPITableHdrShort",
++					"ACPI Table %s is too short, only %d bytes long. Further "
++					"header checks will be omitted.", name, hdr->length);
++				continue;
++			}
++			/* Warn about empty tables */
++			if (hdr->length == sizeof(fwts_acpi_table_header)) {
++				fwts_warning(fw,
++					"ACPI Table %s is empty and just contains a table header. Further "
++					"header checks will be omitted.", name);
++				continue;
++			}
++
++			passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, MIN_SIG) &
++			    acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, OEM_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, OEM_TABLE_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, OEM_CREATOR_ID);
++			if (passed)
++				fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
++		}
++	}
++	if (!checked)
++		fwts_aborted(fw, "Cannot find any ACPI tables.");
++	if (!dsdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test DSDT table is NOT implemented.");
++	}
++	if (!ssdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test SSDT table is NOT implemented.");
++	}
++	if ((!dsdt_checked) || (!ssdt_checked))
++	  return FWTS_ERROR;
++
++	return FWTS_OK;
++}
++
++/* List of ACPI tables recommended by SBBR 4.2.2 */
++char *recommended_acpi_tables[] = {
++	"MCFG",
++	"IORT",
++	"BERT",
++	"EINJ",
++	"ERST",
++	"HEST",
++	"RASF",
++	"SPMI",
++	"SLIT",
++	"SRAT",
++	"CSRT",
++	"ECDT",
++	"MPST",
++	"PCCT",
++	NULL
++};
++
++/* Searches ACPI tables by signature. */
++fwts_acpi_table_info *sbbr_search_acpi_tables(fwts_framework *fw, char *signature)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	i = 0;
++	while (fwts_acpi_get_table(fw, i, &info) == FWTS_OK) {
++		if (info != NULL && strncmp(info->name, signature, sizeof(uint32_t)) == 0) {
++			return info;
++		}
++		i++;
++	}
++
++	return NULL;
++}
++
++static int acpi_table_check_test4(fwts_framework *fw)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	for (i = 0; recommended_acpi_tables[i] != NULL; i++) {
++		info = sbbr_search_acpi_tables(fw, recommended_acpi_tables[i]);
++		if (info == NULL) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiRecommendedTableNotFound",
++			            "SBBR Recommended ACPI table \"%s\" not found.",
++			            recommended_acpi_tables[i]);
++		} else {
++			fwts_passed(fw, "SBBR Recommended ACPI table \"%s\" found.",
++			            recommended_acpi_tables[i]);
++		}
++	}
++	return FWTS_OK;
++}
+ 
+ static fwts_framework_minor_test acpi_table_check_tests[] = {
+ 	{ acpi_table_check_test1, "Test ACPI headers." },
++	{ acpi_namespace_check_test2, "Test that processors only exist in the _SB namespace." },
++	{ acpi_table_check_test3, "Test DSDT and SSDT tables are implemented." },
++	{ acpi_table_check_test4, "Check for recommended ACPI tables." },
+ 	{ NULL, NULL }
+ };
+ 
+diff --git a/src/acpi/dbg2/dbg2.c b/src/acpi/dbg2/dbg2.c
+index 38ca65e..85b2bce 100644
+--- a/src/acpi/dbg2/dbg2.c
++++ b/src/acpi/dbg2/dbg2.c
+@@ -39,8 +39,8 @@ static int dbg2_init(fwts_framework *fw)
+ 		return FWTS_ERROR;
+ 	}
+ 	if (table == NULL || (table && table->length == 0)) {
+-		fwts_log_error(fw, "ACPI DBG2 table does not exist, skipping test");
+-		return FWTS_SKIP;
++		fwts_log_error(fw, "ACPI DBG2 table does not exist");
++		return FWTS_ERROR;
+ 	}
+ 
+ 	return FWTS_OK;
+diff --git a/src/acpi/fadt/fadt.c b/src/acpi/fadt/fadt.c
+index 533882d..903ade3 100644
+--- a/src/acpi/fadt/fadt.c
++++ b/src/acpi/fadt/fadt.c
+@@ -213,14 +213,9 @@ static int fadt_revision(fwts_framework *fw)
+ 	if (major == LATEST_MAJOR && minor == LATEST_MINOR)
+ 		fwts_passed(fw, "FADT revision is up to date.");
+ 	else {
+-		fwts_warning(fw, "FADT revision is outdated: %d.%d",
+-			     major, minor);
+-		fwts_advice(fw, "The most recent revision of the FADT "
+-			    "defined in the ACPI specification is %d.%d.  "
+-			    "While older revisions of the FADT can be used, "
+-			    "newer ones may enable additional functionality "
+-			    "that cannot be used until the FADT is updated.",
+-			    LATEST_MAJOR, LATEST_MINOR);
++		fwts_failed(fw, LOG_LEVEL_HIGH, "fadt_revision",
++		    "FADT revision Not up to date");
++		return FWTS_ERROR;
+ 	}
+ 
+ 	return FWTS_OK;
+@@ -1591,6 +1586,18 @@ static void acpi_table_check_fadt_sleep_status_reg(fwts_framework *fw)
+ 				    "will be ignored reduced hardware mode.");
+ 	}
+ }
++static int fadt_arm_boot_arch_psci_compliant_test(fwts_framework *fw)
++{
++	/* ARM SBBR 4.2.1.3 FADT */
++	if (fadt->arm_boot_flags &
++		FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT)
++		  fwts_passed(fw, "PSCI_COMPLIANT is set, PSCI is implemented.");
++	else
++	  fwts_failed(fw, LOG_LEVEL_MEDIUM,
++	      "FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT_flag is not set",
++	      "PSCI is NOT implemented.");
++	return FWTS_OK;
++}
+ 
+ static int fadt_test1(fwts_framework *fw)
+ {
+@@ -1829,6 +1836,7 @@ static fwts_framework_minor_test fadt_tests[] = {
+ 	{ fadt_test1, "ACPI FADT Description Table tests." },
+ 	{ fadt_test2, "Test FADT SCI_EN bit is enabled." },
+ 	{ fadt_test3, "Test FADT reset register." },
++	{ fadt_arm_boot_arch_psci_compliant_test, "Test ARM_BOOT_ARCH for psci compliance" },
+ 	{ NULL, NULL }
+ };
+ 
+diff --git a/src/acpi/method/method.c b/src/acpi/method/method.c
+index bc18224..5da9c3e 100644
+--- a/src/acpi/method/method.c
++++ b/src/acpi/method/method.c
+@@ -210,7 +210,7 @@
+  * _SLI 	 N
+  * _SPD 	 Y
+  * _SRS 	 n/a
+- * _SRT 	 n/a
++ * _SRT 	 Y
+  * _SRV 	 Y
+  * _SST 	 Y
+  * _STA 	 Y
+@@ -255,7 +255,7 @@
+  */
+ 
+ /* Test types */
+-#define	METHOD_MANDITORY	1
++#define	METHOD_MANDATORY	1
+ #define METHOD_OPTIONAL		2
+ #define METHOD_MOBILE		4
+ #define METHOD_SILENT		8
+@@ -548,7 +548,7 @@ static int method_evaluate_method(fwts_framework *fw,
+ 	} else {
+ 		if (!(test_type & METHOD_SILENT)) {
+ 			/* Manditory not-found test are a failure */
+-			if (test_type & METHOD_MANDITORY) {
++			if (test_type & METHOD_MANDATORY) {
+ 				fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodNotExist",
+ 					"Object %s did not exist.", name);
+ 			}
+@@ -2235,7 +2235,7 @@ static void method_test_CRS_return(
+ 
+ static int method_test_CRS(fwts_framework *fw)
+ {
+-	return method_evaluate_method(fw, METHOD_MANDITORY,
++	return method_evaluate_method(fw, METHOD_MANDATORY,
+ 		"_CRS", NULL, 0, method_test_CRS_return, "_CRS");
+ }
+ 
+@@ -4786,6 +4786,34 @@ static int method_test_CWS(fwts_framework *fw)
+ 	return ret;
+ }
+ 
++static void method_test_SRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value & ~0x1)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SRTReturn",
++			"%s returned %" PRId64 ", should be between 0 and 1, "
++			"one or more of the reserved bits 1..31 seem "
++			"to be set.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_SRT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SRT", NULL, 0, method_test_SRT_return, NULL);
++}
+ 
+ static int method_test_STP(fwts_framework *fw)
+ {
+@@ -6389,7 +6417,7 @@ static int method_test_PTS(fwts_framework *fw)
+ 
+ 		fwts_log_info(fw, "Test _PTS(%d).", i);
+ 
+-		if (method_evaluate_method(fw, METHOD_MANDITORY, "_PTS", arg, 1,
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_PTS", arg, 1,
+ 			method_test_NULL_return, NULL) == FWTS_NOT_EXIST) {
+ 			fwts_advice(fw,
+ 				"Could not find _PTS. This method provides a "
+@@ -6422,7 +6450,7 @@ static int method_test_TTS(fwts_framework *fw)
+ 			fwts_log_info(fw,
+ 				"Test _TTS(%d) Transition To State S%d.", i, i);
+ 
+-			if (method_evaluate_method(fw, METHOD_MANDITORY,
++			if (method_evaluate_method(fw, METHOD_MANDATORY,
+ 				"_TTS", arg, 1, method_test_NULL_return,
+ 				NULL) == FWTS_NOT_EXIST) {
+ 				fwts_advice(fw,
+@@ -6474,7 +6502,7 @@ static int method_test_WAK(fwts_framework *fw)
+ 		arg[0].Type = ACPI_TYPE_INTEGER;
+ 		arg[0].Integer.Value = i;
+ 		fwts_log_info(fw, "Test _WAK(%d) System Wake, State S%d.", i, i);
+-		if (method_evaluate_method(fw, METHOD_MANDITORY, "_WAK", arg, 1,
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_WAK", arg, 1,
+ 			method_test_WAK_return, &i) == FWTS_NOT_EXIST) {
+ 			fwts_advice(fw,
+ 				"Section 7.3.7 states that a system that wakes "
+@@ -6879,6 +6907,85 @@ static int method_test_SRV(fwts_framework *fw)
+ 		"_SRV", NULL, 0, method_test_integer_return, NULL);
+ }
+ 
++/* ARM SBBR Test Definitions */
++static int sbbr_method_test_ADR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_ADR", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_AEI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_AEI_return, NULL);
++}
++
++static int sbbr_method_test_CCA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_CCA", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_EVT(fwts_framework *fw)
++{
++	int ret;
++
++	/* Only test the _EVT method with pins defined in AEI. */
++	ret = method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_EVT_return, NULL);
++
++	if (ret == FWTS_NOT_EXIST)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiEvtDoesNotExist", "Method _EVT does not exist.");
++
++	return ret;
++}
++
++static int sbbr_method_test_HID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_HID", NULL, 0, method_test_HID_return, NULL);
++}
++
++static int sbbr_method_test_OSI(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_STRING;
++	arg[0].String.Pointer = "Linux";
++
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_OSI", arg, 1, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_SST(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int ret, i;
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	for (i = 0; i <= 4; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_MANDATORY,
++			"_SST", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static int sbbr_method_test_STA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_STA", NULL, 0, method_test_STA_return, "_STA");
++}
++
++static int sbbr_method_test_UID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_UID", NULL, 0, method_test_UID_return, NULL);
++}
++
+ /*
+  * Tests
+  */
+@@ -7081,7 +7188,7 @@ static fwts_framework_minor_test method_tests[] = {
+ 	{ method_test_GRT, "Test _GRT (Get Real Time)." },
+ 	{ method_test_GWS, "Test _GWS (Get Wake Status)." },
+ 	{ method_test_CWS, "Test _CWS (Clear Wake Status)." },
+-	/* { method_test_SRT, "Test _SRT (Set Real Time)." }, */
++	{ method_test_SRT, "Test _SRT (Set Real Time)." },
+ 	{ method_test_STP, "Test _STP (Set Expired Timer Wake Policy)." },
+ 	{ method_test_STV, "Test _STV (Set Timer Value)." },
+ 	{ method_test_TIP, "Test _TIP (Expired Timer Wake Policy)." },
+@@ -7196,6 +7303,17 @@ static fwts_framework_minor_test method_tests[] = {
+ 	{ method_test_IFT, "Test _IFT (IPMI Interface Type)." },
+ 	{ method_test_SRV, "Test _SRV (IPMI Interface Revision)." },
+ 
++	/* From ARM SBBR */
++	{ sbbr_method_test_ADR, "SBBR Test _ADR (Return Unique ID for Device)." },
++	{ sbbr_method_test_AEI, "SBBR Test _AEI (Event Information)." },
++	{ sbbr_method_test_CCA, "SBBR Test _CCA (Cache Coherency Attribute)." },
++	{ sbbr_method_test_EVT, "SBBR Test _EVT (Event Method)." },
++	{ sbbr_method_test_HID, "SBBR Test _HID (Hardware ID)." },
++	{ sbbr_method_test_OSI, "SBBR Test _OSI (Operating System Interfaces)." },
++	{ sbbr_method_test_SST, "SBBR Test _SST (System Status)." },
++	{ sbbr_method_test_STA, "SBBR Test _STA (Status)." },
++	{ sbbr_method_test_UID, "SBBR Test _UID (Unique ID)." },
++
+ 	/* End! */
+ 
+ 	{ NULL, NULL }
+diff --git a/src/acpi/rsdp/rsdp.c b/src/acpi/rsdp/rsdp.c
+index f7e10bb..09ec1be 100644
+--- a/src/acpi/rsdp/rsdp.c
++++ b/src/acpi/rsdp/rsdp.c
+@@ -123,6 +123,17 @@ static int rsdp_test1(fwts_framework *fw)
+ 			    "RSDP: at least one of RsdtAddress or XsdtAddress "
+ 			    "is non-zero.");
+ 
++	/* ARM SBBR 4.2.1.1  RSDP */
++	if ((rsdp->rsdt_address == 0) && (rsdp->xsdt_address != 0))
++		fwts_passed(fw,
++				"RSDP: the RsdtAddress is zero "
++				"and the XsdtAddress is non-zero.");
++	else
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++				"RSDPNoAddressesFound",
++				"RSDP: the RsdtAddress must be zero "
++				"and the XsdtAddress must be non-zero.");
++
+ 	if (rsdp->rsdt_address && rsdp->xsdt_address) {
+ 		fwts_log_warning(fw, "NOTE: The RSDT and XSDT are both "
+ 			"defined. An operating system supporting ACPI "
+diff --git a/src/acpi/spcr/spcr.c b/src/acpi/spcr/spcr.c
+index 26cae54..e100ff3 100644
+--- a/src/acpi/spcr/spcr.c
++++ b/src/acpi/spcr/spcr.c
+@@ -39,8 +39,8 @@ static int spcr_init(fwts_framework *fw)
+ 		return FWTS_ERROR;
+ 	}
+ 	if (table == NULL || (table && table->length == 0)) {
+-		fwts_log_error(fw, "ACPI SPCR table does not exist, skipping test");
+-		return FWTS_SKIP;
++		fwts_log_error(fw, "ACPI SPCR table does not exist");
++		return FWTS_ERROR;
+ 	}
+ 	spcr = (const fwts_acpi_table_spcr*)table->data;
+ 
+diff --git a/src/acpi/xsdt/xsdt.c b/src/acpi/xsdt/xsdt.c
+index 032f1a1..7042a59 100644
+--- a/src/acpi/xsdt/xsdt.c
++++ b/src/acpi/xsdt/xsdt.c
+@@ -45,6 +45,8 @@ static int xsdt_init(fwts_framework *fw)
+ 
+ /*
+  *  XSDT Extended System Description Table
++ *
++ *  ARM SBBR 4.2.1.2 XSDT
+  */
+ static int xsdt_test1(fwts_framework *fw)
+ {
+@@ -68,7 +70,8 @@ static int xsdt_test1(fwts_framework *fw)
+ 		}
+ 	}
+ 	if (passed)
+-		fwts_passed(fw, "No issues found in XSDT table.");
++		fwts_passed(fw, "No issues found in XSDT table."
++		    "Number of tables pointed by XSDT = %d", (int)n);
+ 
+ 	return FWTS_OK;
+ }
+diff --git a/src/dmi/dmicheck/dmicheck.c b/src/dmi/dmicheck/dmicheck.c
+index 1934ebe..d00411c 100644
+--- a/src/dmi/dmicheck/dmicheck.c
++++ b/src/dmi/dmicheck/dmicheck.c
+@@ -313,12 +313,15 @@ static int dmi_load_file(const char* filename, void *buf, size_t size)
+ 
+ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ {
+-	off_t addr = (off_t)entry->struct_table_address;
+ 	size_t length = (size_t)entry->struct_table_length;
+ 	void *table;
+-	void *mem;
+ 	char anchor[8];
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
++	off_t addr = (off_t)entry->struct_table_address;
++	void *mem;
++	#endif
++
+ 	/* 32 bit entry sanity check on length */
+ 	if ((length == 0) || (length > 0xffff)) {
+ 		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
+@@ -326,6 +329,7 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 		return NULL;
+ 	}
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
+ 	mem = fwts_mmap(addr, length);
+ 	if (mem != FWTS_MAP_FAILED) {
+ 		table = malloc(length);
+@@ -334,6 +338,7 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 		(void)fwts_munmap(mem, length);
+ 		return table;
+ 	}
++	#endif
+ 
+ 	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, 4) == FWTS_OK
+ 			&& strncmp(anchor, "_SM_", 4) == 0) {
+@@ -354,12 +359,15 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 
+ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ {
+-	off_t addr = (off_t)entry->struct_table_address;
+ 	size_t length = (size_t)entry->struct_table_max_size;
+ 	void *table;
+-	void *mem;
+ 	char anchor[8];
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
++	off_t addr = (off_t)entry->struct_table_address;
++	void *mem;
++	#endif
++
+ 	/* 64 bit entry sanity check on length */
+ 	if ((length == 0) || (length > 0xffffff)) {
+ 		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
+@@ -367,6 +375,7 @@ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ 		return NULL;
+ 	}
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
+ 	mem = fwts_mmap(addr, length);
+ 	if (mem != FWTS_MAP_FAILED) {
+ 		table = malloc(length);
+@@ -375,6 +384,7 @@ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ 		(void)fwts_munmap(mem, length);
+ 		return table;
+ 	}
++	#endif
+ 
+ 	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, 5) == FWTS_OK
+ 			&& strncmp(anchor, "_SM3_", 5) == 0) {
+@@ -1877,10 +1887,15 @@ static int dmicheck_test3(fwts_framework *fw)
+ 	return FWTS_OK;
+ }
+ 
++static int sbbr_smbios30_locate_structure (fwts_framework *fw, fwts_smbios30_entry *entry,
++	                                       uint8_t *table, uint8_t type, fwts_dmi_header *hdr);
++static int sbbr_smbios_test(fwts_framework *fw);
++
+ static fwts_framework_minor_test dmicheck_tests[] = {
+ 	{ dmicheck_test1, "Find and test SMBIOS Table Entry Points." },
+ 	{ dmicheck_test2, "Test DMI/SMBIOS tables for errors." },
+ 	{ dmicheck_test3, "Test DMI/SMBIOS3 tables for errors." },
++	{ sbbr_smbios_test, "Test ARM SBBR SMBIOS structure requirements."},
+ 	{ NULL, NULL }
+ };
+ 
+@@ -1892,3 +1907,124 @@ static fwts_framework_ops dmicheck_ops = {
+ FWTS_REGISTER("dmicheck", &dmicheck_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_BATCH | FWTS_FLAG_ROOT_PRIV)
+ 
+ #endif
++
++/*
++ * ARM SBBR SMBIOS Structure Test
++ */
++
++/* Test Entry Structure */
++typedef struct {
++	const char *name;
++	const uint8_t type;
++} sbbr_test_entry;
++
++/* Test Definition Array */
++sbbr_test_entry sbbr_test[] = {
++	{"BIOS Information", 0},
++	{"System Information", 1},
++	{"Baseboard Information", 2},
++	{"System Enclosure or Chassis", 3},
++	{"Processor Information", 4},
++	{"Cache Information", 7},
++	{"Port Connector Information", 8},
++	{"System Slots", 9},
++	{"OEM Strings", 11},
++	{"BIOS Language Information", 13},
++	{"System Event Log", 15},
++	{"Physical Memory Array", 16},
++	{"Memory Device", 17},
++	{"Memory Array Mapped Address", 19},
++	{"System Boot Information", 32},
++	{"IPMI Device Information", 38},
++	{"Onboard Devices Extended Information", 41},
++	{0, 0}
++};
++
++#define HEADER_TYPE_OFFSET 0
++#define HEADER_LENGTH_OFFSET 1
++#define HEADER_HANDLE_OFFSET 2
++
++/* Finds SMBIOS structure of a given type in an SMBIOS30 table. */
++static int sbbr_smbios30_locate_structure (fwts_framework *fw, fwts_smbios30_entry *entry,
++	                                       uint8_t *table, uint8_t type, fwts_dmi_header *hdr){
++	uint8_t *entry_data = table;
++	uint16_t table_max_length;
++	int i = 0;
++	uint8_t *next_entry;
++	table_max_length = entry->struct_table_max_size;
++
++	for (i = 0; entry_data <= (table + table_max_length - 4); i++) {
++
++		hdr->type   = entry_data[0];
++		hdr->length = entry_data[1];
++		hdr->handle = GET_UINT16(entry_data + 2);
++		hdr->data   = entry_data;
++
++		/* We found the entry we're looking for. */
++		if (hdr->type == type)
++			return FWTS_OK;
++
++		/* We found DMI end of table */
++		if (hdr->type == SMBIOS_END_OF_TABLE)
++			return FWTS_ERROR;
++
++		/* Real Physical Address */
++		next_entry = entry_data + hdr->length;
++
++		/* Look for structure terminator, ends in two zero bytes */
++		while (((next_entry - table + 1) < table_max_length) && ((next_entry[0] != 0) || (next_entry[1] != 0)))
++			next_entry++;
++
++		/* Skip over terminating two zero bytes, see section 6.1 of spec */
++		next_entry += 2;
++
++		if ((next_entry - table) > table_max_length){
++			fwts_failed(fw, LOG_LEVEL_HIGH, DMI_BAD_TABLE_LENGTH,
++				"DMI table maximum size was %" PRId32 " bytes (as specified by "
++				"the SMBIOS 3.0 header) but the DMI entries over the maximum "
++				"length without finding the End-of-Table(Type 127).",
++				table_max_length);
++			break;
++		}
++
++		entry_data = next_entry;
++	}
++	return FWTS_ERROR;
++}
++
++/* SBBR SMBIOS structure test function. */
++static int sbbr_smbios_test(fwts_framework *fw)
++{
++	fwts_smbios30_entry entry;
++	fwts_dmi_header hdr;
++	uint16_t version;
++	void *addr;
++	uint32_t i;
++	uint8_t *table;
++
++	/* Finding SMBIOS30 entry point. */
++	addr = fwts_smbios30_find_entry(fw, &entry, &version);
++	if (addr == NULL) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoTable", "Cannot find SMBIOS30 table "
++		            "entry.");
++		return FWTS_ERROR;
++	}
++
++	/* Getting SMBIOS table contents. */
++	table = dmi_table_smbios30(fw, &entry);
++	if (table == NULL)
++		return FWTS_ERROR;
++
++	/* Searching for each SMBIOS structure needed by SBBR. */
++	for (i = 0; sbbr_test[i].name != NULL; i++) {
++		if (sbbr_smbios30_locate_structure(fw, &entry, table, sbbr_test[i].type, &hdr) == FWTS_OK)
++			dmicheck_entry(fw, (uintptr_t)hdr.data, &hdr);
++		else
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoStruct", "Cannot find SMBIOS "
++			            "structure: %s (Type %d)", sbbr_test[i].name, sbbr_test[i].type);
++	}
++
++	dmi_table_free(table);
++
++	return FWTS_OK;
++}
+diff --git a/src/lib/src/fwts_smbios.c b/src/lib/src/fwts_smbios.c
+index 21263b4..0ed57eb 100644
+--- a/src/lib/src/fwts_smbios.c
++++ b/src/lib/src/fwts_smbios.c
+@@ -52,6 +52,8 @@ static void *fwts_smbios_find_entry_uefi(fwts_framework *fw, fwts_smbios_entry *
+ 	void *addr;
+ 
+ 	if ((addr = fwts_scan_efi_systab("SMBIOS")) != NULL) {
++
++		#if !defined(FWTS_ARCH_AARCH64)
+ 		fwts_smbios_entry *mapped_entry;
+ 
+ 		if ((mapped_entry = fwts_mmap((off_t)addr, sizeof(fwts_smbios_entry))) != FWTS_MAP_FAILED) {
+@@ -60,6 +62,7 @@ static void *fwts_smbios_find_entry_uefi(fwts_framework *fw, fwts_smbios_entry *
+ 			*type  = FWTS_SMBIOS;
+ 			return addr;
+ 		}
++		#endif
+ 
+ 		if (fwts_load_file("/sys/firmware/dmi/tables/smbios_entry_point",
+ 				entry, sizeof(fwts_smbios_entry)) == FWTS_OK && !strncmp((char*)entry, "_SM_", 4)) {
+@@ -82,13 +85,16 @@ static void *fwts_smbios30_find_entry_uefi(fwts_framework *fw, fwts_smbios30_ent
+ 	void *addr;
+ 
+ 	if ((addr = fwts_scan_efi_systab("SMBIOS3")) != NULL) {
+-		fwts_smbios30_entry *mapped_entry;
+ 
++		#if !defined(FWTS_ARCH_AARCH64)
++		fwts_smbios30_entry *mapped_entry;
++		
+ 		if ((mapped_entry = fwts_mmap((off_t)addr, sizeof(fwts_smbios30_entry))) != FWTS_MAP_FAILED) {
+ 			*entry = *mapped_entry;
+ 			(void)fwts_munmap(mapped_entry, sizeof(fwts_smbios30_entry));
+ 			return addr;
+ 		}
++		#endif
+ 
+ 		if (fwts_load_file("/sys/firmware/dmi/tables/smbios_entry_point",
+ 				entry, sizeof(fwts_smbios30_entry)) == FWTS_OK && !strncmp((char*)entry, "_SM3_", 5)) {
diff --git a/meta-luv/recipes-core/fwts/fwts_git.bb b/meta-luv/recipes-core/fwts/fwts_git.bb
index 73e6b61..5a2a5b1 100644
--- a/meta-luv/recipes-core/fwts/fwts_git.bb
+++ b/meta-luv/recipes-core/fwts/fwts_git.bb
@@ -4,11 +4,12 @@ HOMEPAGE = "https://wiki.ubuntu.com/Kernel/Reference/fwts"
 LICENSE = "GPLv2+"
 LIC_FILES_CHKSUM = "file://src/main.c;beginline=1;endline=16;md5=31da590f3e9f3bd34dcdb9e4db568519"
 
-PV = "V16.09.00+git${SRCPV}"
+PV = "V16.11.00+git${SRCPV}"
 
-SRCREV = "7fd1834a879f27647b371c18284868c9a54f6474"
+SRCREV = "e2ed99a74c06f62e3bb7ab1dcb4c344f5abc3a29"
 SRC_URI = "git://kernel.ubuntu.com/hwe/fwts.git \
            file://luv-parser-fwts \
+           file://sbbr.patch \
           "
 
 S = "${WORKDIR}/git"
diff --git a/meta-luv/recipes-core/images/luv-live-image.bb b/meta-luv/recipes-core/images/luv-live-image.bb
index 20c2194..8464c8c 100644
--- a/meta-luv/recipes-core/images/luv-live-image.bb
+++ b/meta-luv/recipes-core/images/luv-live-image.bb
@@ -12,11 +12,11 @@ INITRD = "${DEPLOY_DIR_IMAGE}/${INITRD_IMAGE}-${MACHINE}.cpio.gz"
 MACHINE_FEATURES += "efi"
 APPEND = "debug crashkernel=256M console=ttyS0,115200 console=ttyPCH0,115200 ip=dhcp log_buf_len=1M"
 APPEND_netconsole = "luv_netconsole=10.11.12.13,64001"
-APPEND_aarch64 = "crashkernel=256M console=ttyAMA0 uefi_debug acpi=force"
+APPEND_aarch64 = "crashkernel=256M earlycon uefi_debug acpi=force"
 
 SPLASH_IMAGE = "blue-luv.jpg"
 
-GRUB_TIMEOUT = "2"
+GRUB_TIMEOUT = "1"
 
 inherit bootimg
 
@@ -32,8 +32,8 @@ build_img() {
     # Sectors: 512 bytes
     # Blocks: 1024 bytes
     VFAT_RESULTS=${DEPLOY_DIR_IMAGE}/${PN}-results.hddimg
-    # 16MB of space for test results
-    VFAT_RESULTS_SPACE=16777216
+    # 128 MB of space for test results and SCT installation
+    VFAT_RESULTS_SPACE=134217728
     VFAT_RESULTS_BLOCKS=$(expr $VFAT_RESULTS_SPACE / 1024)
     # TODO: do we need to dynamically generate the UUID?
     # For now, every time this UUID changes, the file etc/init.d/luv-test-manager
diff --git a/meta-luv/recipes-core/images/luv-netboot-image.bb b/meta-luv/recipes-core/images/luv-netboot-image.bb
index 0fc7333..0962380 100644
--- a/meta-luv/recipes-core/images/luv-netboot-image.bb
+++ b/meta-luv/recipes-core/images/luv-netboot-image.bb
@@ -1,7 +1,7 @@
 LICENSE = "MIT"
 LIC_FILES_CHKSUM = "file://${COREBASE}/LICENSE;md5=4d92cd373abda3937c2bc47fbc49d690"
 
-DEPENDS_${PN} = "bits"
+DEPENDS_${PN} = "bits sbbr"
 
 INITRD_IMAGE = "core-image-efi-initramfs"
 INITRD = "${DEPLOY_DIR_IMAGE}/${INITRD_IMAGE}-${MACHINE}.cpio.gz"
@@ -15,7 +15,7 @@ PCBIOS_append = "0"
 
 APPEND = "debug crashkernel=256M console=ttyS0,115200 console=ttyPCH0,115200 luv.netboot ip=dhcp log_buf_len=1M"
 APPEND_netconsole = "luv_netconsole=10.11.12.13,64001"
-APPEND_aarch64 = "crashkernel=256M console=ttyAMA0 uefi_debug acpi=force luv.netboot"
+APPEND_aarch64 = "crashkernel=256M earlycon uefi_debug acpi=force luv.netboot"
 
 HDDDIR = "${S}/hddimg"
 
@@ -33,7 +33,8 @@ do_mkimage[depends] += "${EXTRABOOTIMGDEPS} \
                         mtools-native:do_populate_sysroot \
                         cdrtools-native:do_populate_sysroot \
                         virtual/kernel:do_deploy \
-			${_BITSDEPENDS}"
+                        ${_BITSDEPENDS} \
+                        ${_SBBRDEPENDS}"
 
 do_bootimg[noexec] = "1"
 
@@ -42,7 +43,8 @@ do_populate_image() {
 	if [ "${TARGET_ARCH}" != "aarch64" ]; then
 		efi_populate_bits ${HDDDIR}
 	else
-		echo "bootaa64.efi" > ${HDDDIR}${EFIDIR}/startup.nsh
+		efi_populate_sbbr ${HDDDIR}
+		efi_populate_sbsa ${HDDDIR}
 		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${HDDDIR}${EFIDIR}
 	fi
 	install -m 0644 ${GRUBCFG} ${HDDDIR}${EFIDIR}
diff --git a/meta-luv/recipes-core/initscripts/initscripts/luv-collect-results b/meta-luv/recipes-core/initscripts/initscripts/luv-collect-results
new file mode 100644
index 0000000..5f4d57f
--- /dev/null
+++ b/meta-luv/recipes-core/initscripts/initscripts/luv-collect-results
@@ -0,0 +1,172 @@
+#!/usr/bin/env python
+
+import sys
+import os
+import re
+import codecs
+
+def log_fwts(d):
+    testCategory = ""
+    testName = ""
+    testPasses = 0
+    testFails = 0
+    testSkips = 0
+    totalPasses = 0
+    totalFails = 0
+    totalSkips = 0
+
+    # Finding latest FWTS results directory.
+    directory = os.listdir(d)
+    fwtsDir = ""
+    for folder in directory:
+        if "luv-results-" in folder and folder > fwtsDir:
+            fwtsDir = folder
+
+    # Opening FWTS raw output file.
+    fwtsRawPath = os.path.join(d, fwtsDir, "raw", "fwts")
+    try:
+        fwtsRaw = open(fwtsRawPath, "r")
+    except IOError:
+        print "FWTS raw results file \"%s\" could not be opened, skipping." % fwtsRawPath
+        return -1
+
+    # Printing .MD file header for FWTS results.
+    outFile.write("# FWTS Test Results\n")
+    outFile.write("| Category | Test Case | Passes | Skips | Failures |\n")
+    outFile.write("| :--- | :--- | ---: | ---: | ---: |\n")
+
+    # Scraping FWTS output.
+    while True:
+        # Getting a line from file.
+        line = fwtsRaw.readline()
+        if line == "":
+            if testCategory != "":
+                outFile.write ("| %s | %s | %d | %d | %d |\n" % (testCategory, testName, testPasses, testSkips, testFails))
+                outFile.write ("| Total |  | %d | %d | %d |\n" % (totalPasses, totalSkips, totalFails))
+            return 0
+        line = line.rstrip()
+
+        # Checking if line is the beginning of a new test results block.
+        matchString = re.search(r"INF Test \d", line, re.M|re.I)
+        if matchString:
+            # Printing information for previous test before we move to next one.
+            if testName != "":
+                outFile.write ("| %s | %s | %d | %d | %d |\n" % (testCategory, testName, testPasses, testSkips, testFails))
+                testCategory = ""
+            currentTest = line.split()[2] + " " + line.split()[3]
+            testCategory = line.split()[0]
+            testName = line[(line.index(":") + 2):]
+            testPasses = 0
+            testFails = 0
+            testSkips = 0
+            testInfos = 0
+            while testName[len(testName) - 1] != ".":
+                line = fwtsRaw.readline().rstrip()
+                if ";INF" not in line:
+                    break
+                testName = testName + " " + line[20:]
+
+        # Checking if line is a pass/fail/skip for currentTest.
+        if "PASSED" in line and currentTest in line:
+            testPasses = testPasses + 1
+            totalPasses = totalPasses + 1
+        if "SKIPPED" in line and currentTest in line:
+            testSkips = testSkips + 1
+            totalSkips = totalSkips + 1
+        if "FAILED" in line and currentTest in line:
+            testFails = testFails + 1
+            totalFails = totalFails + 1
+
+def log_sbbr(d):
+    testCategory = ""
+    testName = ""
+    testCase = ""
+    testDescription = ""
+    testPasses = 0
+    testWarnings = 0
+    testErrors = 0
+    totalPasses = 0
+    totalWarnings = 0
+    totalErrors = 0
+
+    # Finding SCT test results.
+    sbbrDir = os.path.join(d, "SCT", "Log")
+    if os.path.isdir(sbbrDir) == False:
+        print "SBBR SCT results directory \"%s\" not found.  Skipping." % sbbrDir
+        return -1
+
+    # Printing .MD file header for SCT results.
+    outFile.write("# UEFI SBBR SCT Test Results\n")
+    outFile.write("| Category | Test File | Test Case | Description | Passes | Warnings | Errors |\n")
+    outFile.write("| :--- | :--- | :--- | :--- | ---: | ---: | ---: |\n")
+
+    # Recursively walking through SBBR results folders.
+    for dirpath, dirnames, filenames in os.walk(sbbrDir):
+        for entry in filenames:
+            if ".log" in entry:
+                path, testName = os.path.split(dirpath)
+                testName = testName.split("0")[0]
+                path, testCategory = os.path.split(path)
+                with codecs.open(os.path.join(dirpath, entry), mode="r", encoding="utf-16") as logfile:
+                    i = 1
+                    while True:
+                        line = logfile.readline()
+                        if line == "":
+                            break
+                        if i == 2:
+                            testCase = line.rstrip()
+                        if i == 11:
+                            testDescription = line.rstrip()
+                        if "Passes..........." in line:
+                            testPasses = int(line.split()[1])
+                        if "Warnings........." in line:
+                            testWarnings = int(line.split()[1])
+                        if "Errors..........." in line:
+                            testErrors = int(line.split()[1])
+                        i = i + 1
+                    outFile.write("| %s | %s | %s | %s | %d | %d | %d |\n" % (testCategory, testName, testCase, testDescription, testPasses, testWarnings, testErrors))
+                    totalPasses = totalPasses + testPasses
+                    totalWarnings = totalWarnings + testWarnings
+                    totalErrors = totalErrors + testErrors
+
+    # Print totals.
+    outFile.write("| Total | | | | %d | %d | %d |" % (totalPasses, totalWarnings, totalErrors))
+
+
+# Script entry point.
+
+# This script needs to be run on a stripped out yocto distribution so we can't use argparse.
+if "-h" in sys.argv or "--help" in sys.argv:
+    print "Usage:"
+    print " python %s [-h] LUV_RESULTS OUTPUT_FILE" % sys.argv[0]
+    print "Options:"
+    print " -h, --help              Display this help and exit."
+    print " LUV_RESULTS             Path to luv-results directory/drive."
+    print " OUTPUT_FILE             File for script output, must have .md file extension."
+    exit()
+
+arg_directory = sys.argv[1]
+arg_output = sys.argv[2]
+
+# Validating parameter and opening output file.
+filename, fileext = os.path.splitext(arg_output)
+if fileext != ".md" and fileext != ".MD":
+    print "Output file must have .md file extension. Exiting."
+    exit()
+try:
+    outFile = open(arg_output, "w")
+except IOError:
+    print "Could not open \"%s\" for writing. Exiting." % arg_output
+    exit()
+
+# Scanning FWTS.
+print "Gathering FWTS test results..."
+log_fwts(arg_directory)
+
+# Scanning SBBR.
+print "Gathering UEFI SBBR SCT test results..."
+log_sbbr(arg_directory)
+
+outFile.close()
+
+print "Done, test results can be found in \"%s\"" % arg_output
diff --git a/meta-luv/recipes-core/initscripts/initscripts/luv-test-manager b/meta-luv/recipes-core/initscripts/initscripts/luv-test-manager
index 326683d..0abe8c6 100644
--- a/meta-luv/recipes-core/initscripts/initscripts/luv-test-manager
+++ b/meta-luv/recipes-core/initscripts/initscripts/luv-test-manager
@@ -251,7 +251,8 @@ done | awk '/\[\+/  { units += 1 }
 		suites, units, passes, fails, skips, warns)
     }' | html_inline ${LUV_HTML_REPORT} | tee -a /dev/kmsg /tmp/luv.results \
          ${LUV_SAVE_RESULTS_DIR}/luv.results
-
+# collecting test results
+python /etc/luv-collect-results ${LUV_STORAGE} ${LUV_STORAGE}/results.md
 html_finish ${LUV_HTML_REPORT}
 
 mountpoint -q ${LUV_EFI}
diff --git a/meta-luv/recipes-core/initscripts/initscripts_1.0.bbappend b/meta-luv/recipes-core/initscripts/initscripts_1.0.bbappend
index 676bc81..b0d9305 100644
--- a/meta-luv/recipes-core/initscripts/initscripts_1.0.bbappend
+++ b/meta-luv/recipes-core/initscripts/initscripts_1.0.bbappend
@@ -5,7 +5,8 @@ SRC_URI += "file://luv-test-manager file://luv-test-parser \
             file://luv-netconsole \
             file://luv-netconsole-params \
             file://luv-scripts \
-            file://luv-css-styles"
+            file://luv-css-styles \
+            file://luv-collect-results"
 
 RDEPENDS_${PN}+= "kernel-modules iputils iproute2 bash init-ifupdown dhcp-client"
 
@@ -40,6 +41,9 @@ do_install_append() {
         install -d ${D}${datadir}/luv/html
         install -m 0644 ${WORKDIR}/luv-scripts ${D}${datadir}/luv/html
         install -m 0644 ${WORKDIR}/luv-css-styles ${D}${datadir}/luv/html
+
+        # Install luv-collect-results script
+        install -m 755 ${WORKDIR}/luv-collect-results ${D}${sysconfdir}/
 }
 
 FILES_${PN} += "${datadir}/luv/html/luv-scripts ${datadir}/luv/html/luv-css-styles"
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/0005-ACPI-Console-Through-SPCR-Table.patch b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/0005-ACPI-Console-Through-SPCR-Table.patch
new file mode 100644
index 0000000..19ad9e8
--- /dev/null
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/0005-ACPI-Console-Through-SPCR-Table.patch
@@ -0,0 +1,419 @@
+From 55148bc607319db1f439fdff3ac76923e20b4283 Mon Sep 17 00:00:00 2001
+From: Supreeth Venkatesh <supreeth.venkatesh@arm.com>
+Date: Sat, 3 Dec 2016 01:14:00 +0000
+Subject: [PATCH] ACPI: Console Through SPCR Table.
+
+---
+ arch/arm64/Kconfig              |   1 +
+ arch/arm64/kernel/acpi.c        |  12 ++++-
+ drivers/acpi/Kconfig            |   3 ++
+ drivers/acpi/Makefile           |   1 +
+ drivers/acpi/spcr.c             | 111 ++++++++++++++++++++++++++++++++++++++++
+ drivers/of/fdt.c                |  10 +---
+ drivers/tty/serial/amba-pl011.c |  54 +++++++++++++++++++
+ drivers/tty/serial/earlycon.c   |  19 ++++++-
+ include/linux/acpi.h            |   6 +++
+ include/linux/of_fdt.h          |   3 ++
+ include/linux/serial_core.h     |   9 +++-
+ 11 files changed, 216 insertions(+), 13 deletions(-)
+ create mode 100644 drivers/acpi/spcr.c
+
+diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
+index 5a0a691..cc78080 100644
+--- a/arch/arm64/Kconfig
++++ b/arch/arm64/Kconfig
+@@ -3,6 +3,7 @@ config ARM64
+ 	select ACPI_CCA_REQUIRED if ACPI
+ 	select ACPI_GENERIC_GSI if ACPI
+ 	select ACPI_REDUCED_HARDWARE_ONLY if ACPI
++	select ACPI_SPCR_TABLE if ACPI
+ 	select ARCH_HAS_DEVMEM_IS_ALLOWED
+ 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
+ 	select ARCH_HAS_ELF_RANDOMIZE
+diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
+index 3e4f1a4..191acdd 100644
+--- a/arch/arm64/kernel/acpi.c
++++ b/arch/arm64/kernel/acpi.c
+@@ -24,6 +24,7 @@
+ #include <linux/memblock.h>
+ #include <linux/of_fdt.h>
+ #include <linux/smp.h>
++#include <linux/serial_core.h>
+ 
+ #include <asm/cputype.h>
+ #include <asm/cpu_ops.h>
+@@ -206,7 +207,7 @@ void __init acpi_boot_table_init(void)
+ 	if (param_acpi_off ||
+ 	    (!param_acpi_on && !param_acpi_force &&
+ 	     of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
+-		return;
++		goto done;;
+ 
+ 	/*
+ 	 * ACPI is disabled at this point. Enable it in order to parse
+@@ -226,6 +227,15 @@ void __init acpi_boot_table_init(void)
+ 		if (!param_acpi_force)
+ 			disable_acpi();
+ 	}
++
++done:
++	if (acpi_disabled) {
++		if (earlycon_init_is_deferred)
++			early_init_dt_scan_chosen_stdout();
++	} else {
++		parse_spcr(earlycon_init_is_deferred);
++	}
++
+ }
+ 
+ #ifdef CONFIG_ACPI_APEI
+diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
+index b7e2e77..89218ea 100644
+--- a/drivers/acpi/Kconfig
++++ b/drivers/acpi/Kconfig
+@@ -77,6 +77,9 @@ config ACPI_DEBUGGER_USER
+ 
+ endif
+ 
++config ACPI_SPCR_TABLE
++	bool
++
+ config ACPI_SLEEP
+ 	bool
+ 	depends on SUSPEND || HIBERNATION
+diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
+index 251ce85..43cde68 100644
+--- a/drivers/acpi/Makefile
++++ b/drivers/acpi/Makefile
+@@ -81,6 +81,7 @@ obj-$(CONFIG_ACPI_EC_DEBUGFS)	+= ec_sys.o
+ obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o
+ obj-$(CONFIG_ACPI_BGRT)		+= bgrt.o
+ obj-$(CONFIG_ACPI_CPPC_LIB)	+= cppc_acpi.o
++obj-$(CONFIG_ACPI_SPCR_TABLE)	+= spcr.o
+ obj-$(CONFIG_ACPI_DEBUGGER_USER) += acpi_dbg.o
+ 
+ # processor has its own "processor." module_param namespace
+diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
+new file mode 100644
+index 0000000..01c0e15
+--- /dev/null
++++ b/drivers/acpi/spcr.c
+@@ -0,0 +1,111 @@
++/*
++ * Copyright (c) 2012, Intel Corporation
++ * Copyright (c) 2015, Red Hat, Inc.
++ * Copyright (c) 2015, 2016 Linaro Ltd.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ */
++
++#define pr_fmt(fmt) "ACPI: SPCR: " fmt
++
++#include <linux/acpi.h>
++#include <linux/console.h>
++#include <linux/kernel.h>
++#include <linux/serial_core.h>
++
++/**
++ * parse_spcr() - parse ACPI SPCR table and add preferred console
++ *
++ * @earlycon: set up earlycon for the console specified by the table
++ *
++ * For the architectures with support for ACPI, CONFIG_ACPI_SPCR_TABLE may be
++ * defined to parse ACPI SPCR table.  As a result of the parsing preferred
++ * console is registered and if @earlycon is true, earlycon is set up.
++ *
++ * When CONFIG_ACPI_SPCR_TABLE is defined, this function should be called
++ * from arch inintialization code as soon as the DT/ACPI decision is made.
++ *
++ */
++int __init parse_spcr(bool earlycon)
++{
++	static char opts[64];
++	struct acpi_table_spcr *table;
++	acpi_size table_size;
++	acpi_status status;
++	char *uart;
++	char *iotype;
++	int baud_rate;
++	int err;
++
++	if (acpi_disabled)
++		return -ENODEV;
++
++	status = acpi_get_table_with_size(ACPI_SIG_SPCR, 0,
++					  (struct acpi_table_header **)&table,
++					  &table_size);
++
++	if (ACPI_FAILURE(status))
++		return -ENOENT;
++
++	if (table->header.revision < 2) {
++		err = -ENOENT;
++		pr_err("wrong table version\n");
++		goto done;
++	}
++
++	iotype = table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY ?
++			"mmio" : "io";
++
++	switch (table->interface_type) {
++	case ACPI_DBG2_ARM_SBSA_32BIT:
++		iotype = "mmio32";
++		/* fall through */
++	case ACPI_DBG2_ARM_PL011:
++	case ACPI_DBG2_ARM_SBSA_GENERIC:
++	case ACPI_DBG2_BCM2835:
++		uart = "pl011";
++		break;
++	case ACPI_DBG2_16550_COMPATIBLE:
++	case ACPI_DBG2_16550_SUBSET:
++		uart = "uart";
++		break;
++	default:
++		err = -ENOENT;
++		goto done;
++	}
++
++	switch (table->baud_rate) {
++	case 3:
++		baud_rate = 9600;
++		break;
++	case 4:
++		baud_rate = 19200;
++		break;
++	case 6:
++		baud_rate = 57600;
++		break;
++	case 7:
++		baud_rate = 115200;
++		break;
++	default:
++		err = -ENOENT;
++		goto done;
++	}
++
++	snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
++		 table->serial_port.address, baud_rate);
++
++	pr_info("console: %s\n", opts);
++
++	if (earlycon)
++		setup_earlycon(opts);
++
++	err = add_preferred_console(uart, 0, opts + strlen(uart) + 1);
++
++done:
++	early_acpi_os_unmap_memory((void __iomem *)table, table_size);
++	return err;
++}
+diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
+index 33daffc..bc8d9e2 100644
+--- a/drivers/of/fdt.c
++++ b/drivers/of/fdt.c
+@@ -904,7 +904,7 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
+ 
+ #ifdef CONFIG_SERIAL_EARLYCON
+ 
+-static int __init early_init_dt_scan_chosen_serial(void)
++int __init early_init_dt_scan_chosen_stdout(void)
+ {
+ 	int offset;
+ 	const char *p, *q, *options = NULL;
+@@ -949,14 +949,6 @@ static int __init early_init_dt_scan_chosen_serial(void)
+ 	return -ENODEV;
+ }
+ 
+-static int __init setup_of_earlycon(char *buf)
+-{
+-	if (buf)
+-		return 0;
+-
+-	return early_init_dt_scan_chosen_serial();
+-}
+-early_param("earlycon", setup_of_earlycon);
+ #endif
+ 
+ /**
+diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
+index 1b7331e..fa7c5fa 100644
+--- a/drivers/tty/serial/amba-pl011.c
++++ b/drivers/tty/serial/amba-pl011.c
+@@ -2288,6 +2288,60 @@ static int __init pl011_console_setup(struct console *co, char *options)
+ 	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
+ }
+ 
++/**
++ *	pl011_console_match - non-standard console matching
++ *	@co:	  registering console
++ *	@name:	  name from console command line
++ *	@idx:	  index from console command line
++ *	@options: ptr to option string from console command line
++ *
++ *	Only attempts to match console command lines of the form:
++ *	    console=pl011,mmio|mmio32,<addr>[,<options>]
++ *	    console=pl011,0x<addr>[,<options>]
++ *	This form is used to register an initial earlycon boot console and
++ *	replace it with the amba_console at pl011 driver init.
++ *
++ *	Performs console setup for a match (as required by interface)
++ *	If no <options> are specified, then assume the h/w is already setup.
++ *
++ *	Returns 0 if console matches; otherwise non-zero to use default matching
++ */
++static int __init pl011_console_match(struct console *co, char *name, int idx,
++				      char *options)
++{
++	unsigned char iotype;
++	unsigned long addr;
++	int i;
++
++	if (strcmp(name, "pl011") != 0)
++		return -ENODEV;
++
++	if (uart_parse_earlycon(options, &iotype, &addr, &options))
++		return -ENODEV;
++
++	if (iotype != UPIO_MEM && iotype != UPIO_MEM32)
++		return -ENODEV;
++
++	/* try to match the port specified on the command line */
++	for (i = 0; i < ARRAY_SIZE(amba_ports); i++) {
++		struct uart_port *port;
++
++		if (!amba_ports[i])
++			continue;
++
++		port = &amba_ports[i]->port;
++
++		if (port->mapbase != addr)
++			continue;
++
++		co->index = i;
++		port->cons = co;
++		return pl011_console_setup(co, options);
++	}
++
++	return -ENODEV;
++}
++
+ static struct uart_driver amba_reg;
+ static struct console amba_console = {
+ 	.name		= "ttyAMA",
+diff --git a/drivers/tty/serial/earlycon.c b/drivers/tty/serial/earlycon.c
+index 067783f..ea00b9f 100644
+--- a/drivers/tty/serial/earlycon.c
++++ b/drivers/tty/serial/earlycon.c
+@@ -21,6 +21,7 @@
+ #include <linux/sizes.h>
+ #include <linux/of.h>
+ #include <linux/of_fdt.h>
++#include <linux/acpi.h>
+ 
+ #ifdef CONFIG_FIX_EARLYCON_MEM
+ #include <asm/fixmap.h>
+@@ -199,6 +200,14 @@ int __init setup_earlycon(char *buf)
+ 	return -ENOENT;
+ }
+ 
++/*
++ * When CONFIG_ACPI_SPCR_TABLE is defined, "earlycon" without parameters in
++ * command line does not start DT earlycon immediately, instead it defers
++ * starting it until DT/ACPI decision is made.  At that time if ACPI is enabled
++ * call parse_spcr(), else call early_init_dt_scan_chosen_stdout()
++ */
++bool earlycon_init_is_deferred __initdata;
++
+ /* early_param wrapper for setup_earlycon() */
+ static int __init param_setup_earlycon(char *buf)
+ {
+@@ -208,8 +217,14 @@ static int __init param_setup_earlycon(char *buf)
+ 	 * Just 'earlycon' is a valid param for devicetree earlycons;
+ 	 * don't generate a warning from parse_early_params() in that case
+ 	 */
+-	if (!buf || !buf[0])
+-		return 0;
++	if (!buf || !buf[0]) {
++		if (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) {
++			earlycon_init_is_deferred = true;
++			return 0;
++		} else {
++			return early_init_dt_scan_chosen_stdout();
++		}
++	}
+ 
+ 	err = setup_earlycon(buf);
+ 	if (err == -ENOENT || err == -EALREADY)
+diff --git a/include/linux/acpi.h b/include/linux/acpi.h
+index 288fac5..1de43be 100644
+--- a/include/linux/acpi.h
++++ b/include/linux/acpi.h
+@@ -997,4 +997,10 @@ static inline struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
+ #define acpi_probe_device_table(t)	({ int __r = 0; __r;})
+ #endif
+ 
++#ifdef CONFIG_ACPI_SPCR_TABLE
++int parse_spcr(bool earlycon);
++#else
++static inline int parse_spcr(bool earlycon) { return 0; }
++#endif
++
+ #endif	/*_LINUX_ACPI_H*/
+diff --git a/include/linux/of_fdt.h b/include/linux/of_fdt.h
+index 901ec01..11eb9a7 100644
+--- a/include/linux/of_fdt.h
++++ b/include/linux/of_fdt.h
+@@ -14,6 +14,7 @@
+ 
+ #include <linux/types.h>
+ #include <linux/init.h>
++#include <linux/errno.h>
+ 
+ /* Definitions used by the flattened device tree */
+ #define OF_DT_HEADER		0xd00dfeed	/* marker */
+@@ -64,6 +65,7 @@ extern int early_init_dt_scan_chosen(unsigned long node, const char *uname,
+ 				     int depth, void *data);
+ extern int early_init_dt_scan_memory(unsigned long node, const char *uname,
+ 				     int depth, void *data);
++extern int early_init_dt_scan_chosen_stdout(void);
+ extern void early_init_fdt_scan_reserved_mem(void);
+ extern void early_init_fdt_reserve_self(void);
+ extern void early_init_dt_add_memory_arch(u64 base, u64 size);
+@@ -92,6 +94,7 @@ extern void early_get_first_memblock_info(void *, phys_addr_t *);
+ extern u64 of_flat_dt_translate_address(unsigned long node);
+ extern void of_fdt_limit_memory(int limit);
+ #else /* CONFIG_OF_FLATTREE */
++static inline int early_init_dt_scan_chosen_stdout(void) { return -ENODEV; }
+ static inline void early_init_fdt_scan_reserved_mem(void) {}
+ static inline void early_init_fdt_reserve_self(void) {}
+ static inline const char *of_flat_dt_get_machine_name(void) { return NULL; }
+diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
+index a3d7c0d..926c416 100644
+--- a/include/linux/serial_core.h
++++ b/include/linux/serial_core.h
+@@ -361,11 +361,18 @@ extern const struct earlycon_id __earlycon_table_end[];
+ 
+ #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
+ 
+-extern int setup_earlycon(char *buf);
+ extern int of_setup_earlycon(const struct earlycon_id *match,
+ 			     unsigned long node,
+ 			     const char *options);
+ 
++#ifdef CONFIG_SERIAL_EARLYCON
++extern bool earlycon_init_is_deferred __initdata;
++int setup_earlycon(char *buf);
++#else
++static const bool earlycon_init_is_deferred;
++static inline int setup_earlycon(char *buf) { return 0; }
++#endif
++
+ struct uart_port *uart_get_console(struct uart_port *ports, int nr,
+ 				   struct console *c);
+ int uart_parse_earlycon(char *p, unsigned char *iotype, unsigned long *addr,
+-- 
+2.7.4
+
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg
index 09fe7c7..155a101 100644
--- a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg
@@ -1,2 +1,3 @@
 CONFIG_EXPERT = y
 CONFIG_EMBEDDED=y
+CONFIG_ACPI=y
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb
index 5a577cc..d4c73d6 100644
--- a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb
@@ -64,6 +64,7 @@ SRC_URI += "file://0001-Add-function-to-fixup-page-faults-in-BOOT_SERVICES_-.pat
             file://0002-efi-allow-efi_mem_desc_lookup-find-EFI_BOOT_SERVICES.patch \
             file://0003-x86-efi-Fixup-faults-from-UEFI-firmware.patch \
             file://0004-x86-efi-Introduce-EFI_BOOT_SERVICES_WARN.patch \
+            file://0005-ACPI-Console-Through-SPCR-Table.patch \
            "
 
 # Add the defconfig from v4.6 kernel and the configuration x86 fragments
diff --git a/meta/conf/bitbake.conf b/meta/conf/bitbake.conf
index e80ee18..8a1b9d5 100644
--- a/meta/conf/bitbake.conf
+++ b/meta/conf/bitbake.conf
@@ -717,7 +717,7 @@ INITRAMFS_FSTYPES ?= "cpio.gz"
 # The maximum size in Kbytes for the generated initramfs image size.
 # Usually, it should be less than 1/2 of ram size, or you may fail to
 # boot it.
-INITRAMFS_MAXSIZE ??= "131072"
+INITRAMFS_MAXSIZE ??= "196608"
 
 DEFAULT_TASK_PROVIDER ?= "packagegroup-base"
 MACHINE_TASK_PROVIDER ?= "${DEFAULT_TASK_PROVIDER}"
