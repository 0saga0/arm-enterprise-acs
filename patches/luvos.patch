diff --git a/build_luvos.sh b/build_luvos.sh
new file mode 100755
index 0000000..e24f05e
--- /dev/null
+++ b/build_luvos.sh
@@ -0,0 +1,89 @@
+#!/bin/bash
+# The material contained herein is not a license, either
+# expressly or impliedly, to any intellectual property owned
+# or controlled by any of the authors or developers of this
+# material or to any contribution thereto. The material
+# contained herein is provided on an "AS IS" basis and, to the
+# maximum extent permitted by applicable law, this information
+# is provided AS IS AND WITH ALL FAULTS, and the authors and
+# developers of this material hereby disclaim all other
+# warranties and conditions, either express, implied or
+# statutory, including, but not limited to, any (if any)
+# implied warranties, duties or conditions of merchantability,
+# of fitness for a particular purpose, of accuracy or
+# completeness of responses, of results, of workmanlike
+# effort, of lack of viruses and of lack of negligence, all
+# with regard to this material and any contribution thereto.
+# Designers must not rely on the absence or characteristics of
+# any features or instructions marked "reserved" or
+# "undefined." The ARM, Inc. reserves any
+# features or instructions so marked for future definition and
+# shall have no responsibility whatsoever for conflicts or
+# incompatibilities arising from future changes to them. ALSO,
+# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
+# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
+# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
+# CONTRIBUTION THERETO.
+#
+# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
+# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
+# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
+# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
+# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
+# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
+# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
+# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
+# THE POSSIBILITY OF SUCH DAMAGES.
+#
+# Copyright 2016 ARM, Inc. All
+# Rights Reserved, subject to all existing rights in all
+# matters included within this Test Suite, to which ARM, Inc.
+# makes no claim of right.
+#
+# Copyright (c) 2016 ARM Ltd. All rights reserved.<BR>
+#
+TOPDIR=`pwd`
+
+METALUV="$TOPDIR/meta-luv \\\\"
+BB_CONF="conf/bblayers.conf"
+LOCAL_CONF="conf/local.conf"
+MACHINE="\"qemuarm64\""
+LUV="\"luv\""
+NUM_THREADS="BB_NUMBER_THREADS ?= \"16\""
+OUTPUT_FILE="$PWD/build/tmp/deploy/images/qemuarm64/luv-live-image.img"
+
+echo "Building LuvOS Image with SBBR and SBSA for AARCH4 ..."
+echo "UEFI-SCT source is available only to members of UEFI Forum."
+echo "Please abort, if you are not a member."
+echo "Authentication Required for https://github.com/UEFI/UEFI-SCT"
+echo -n User:
+read SCTUSERNAME
+echo -n Password:
+read -s SCTPASSWORD
+export SCTUSERNAME
+export SCTPASSWORD
+rm -rf build
+source oe-init-build-env
+export BB_ENV_EXTRAWHITE="BB_ENV_EXTRAWHITE SCTUSERNAME SCTPASSWORD"
+
+# include meta-luv  for building
+line=`grep -n "meta-yocto-bsp" $BB_CONF | cut -d : -f 1`
+sed -i "$line a $(echo "  $METALUV")" $BB_CONF
+
+# modify local.conf to edit Machine Type, Distro and Number of Threads
+sed -i -e "s/\(MACHINE ??= \).*/\1$MACHINE/" $LOCAL_CONF
+sed -i -e "s/\(DISTRO ?= \).*/\1$LUV/" $LOCAL_CONF
+echo >> $LOCAL_CONF
+echo "$NUM_THREADS" >> $LOCAL_CONF
+
+bitbake -c cleanall sbbr
+bitbake -c cleanall sbsa
+bitbake -c cleanall luv-live-image
+bitbake sbbr
+bitbake sbsa
+bitbake luv-live-image
+unset BB_ENV_EXTRAWHITE
+unset SCTPASSWORD
+unset SCTUSERNAME
+echo "Built image can be found at $OUTPUT_FILE"
+exit
diff --git a/meta-luv/classes/luv-efi.bbclass b/meta-luv/classes/luv-efi.bbclass
index 889bbce..ced456a 100644
--- a/meta-luv/classes/luv-efi.bbclass
+++ b/meta-luv/classes/luv-efi.bbclass
@@ -16,6 +16,13 @@ def get_bits_depends(bb, d):
                  return ""
 _BITSDEPENDS = "${@get_bits_depends(bb, d)}"
 
+def get_sbbr_depends(bb, d):
+         import re
+         deps = bb.data.getVar('TARGET_PREFIX', d, True)
+         if re.search("aarch64",deps):
+                 return "sbbr:do_deploy"
+_SBBRDEPENDS = "${@get_sbbr_depends(bb, d)}"
+
 # The x86 build is depends on grub-efi and AArch64 build depends on grub_git
 def get_grub_depends(bb, d):
          import re
@@ -56,8 +63,9 @@ efi_populate() {
 
     # Install grub2 in EFI directory
     if [ "${TARGET_ARCH}" = "aarch64" ]; then
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
-                echo "bootaa64.efi" > ${DEST}${EFIDIR}/startup.nsh
+                efi_populate_sbbr ${DEST}
+                efi_populate_sbsa ${DEST}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
 
     # TODO: need conditional signing; e.g., if (DISTRO_FEATURES contains secure_boot)
     # shim bootloader does not seem to work with i386. Thus we don't use it for 32-bit
@@ -81,7 +89,7 @@ efi_populate() {
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEPLOY_DIR_IMAGE}/shim.efi
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}-unsigned ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}
     else
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
     fi
 
     if echo "${TARGET_ARCH}" | grep -q "i.86" || [ "${TARGET_ARCH}" = "x86_64" ]; then
@@ -94,6 +102,25 @@ efi_populate() {
     install -m 0644 ${WORKDIR}/${SPLASH_IMAGE} ${DEST}${EFIDIR}
 }
 
+efi_populate_sbbr() {
+    DEST=$1
+    cp -r ${DEPLOY_DIR_IMAGE}/sbbr ${DEST}${EFIDIR}/sbbr
+    mv ${DEST}${EFIDIR}/sbbr/Shell.efi ${DEST}${EFIDIR}/Shell.efi
+    echo "echo -off
+          for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F
+            if exist FS%i:\SCT\Overall\Summary.log then
+              bootaa64.efi
+              goto Done
+            endif
+          endfor
+          :Done" > ${DEST}${EFIDIR}/startup.nsh
+}
+
+efi_populate_sbsa() {
+        DEST=$1
+        cp -r ${DEPLOY_DIR_IMAGE}/sbsa ${DEST}${EFIDIR}/sbsa
+}
+
 efi_populate_bits() {
     DEST=$1
     # TODO: weird behavior here. When building luv-live-image,
@@ -173,6 +200,11 @@ python build_efi_cfg() {
        cfgfile.write('timeout=0\n')
        cfgfile.write('fallback=0\n')
 
+    if "${TARGET_ARCH}" == "aarch64":
+       cfgfile.write('default=sbbr/sbsa\n')
+       cfgfile.write('timeout=1\n')
+       cfgfile.write('fallback=0\n')
+
     cfgfile.write('menuentry \'luv\' {\n')
     if re.search("(x86_64|i.86)", target):
        cfgfile.write('linux /vmlinuz')
@@ -204,6 +236,11 @@ python build_efi_cfg() {
        cfgfile.write('chainloader /EFI/BOOT/bits/%s\n' % loader)
        cfgfile.write('}\n')
 
+    if "${TARGET_ARCH}" == "aarch64":
+       cfgfile.write('menuentry \'sbbr/sbsa\' {\n')
+       cfgfile.write('chainloader /EFI/BOOT/Shell.efi\n')
+       cfgfile.write('}\n')
+
     cfgfile.close()
 }
 
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/README.md b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
new file mode 100644
index 0000000..06f0264
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
@@ -0,0 +1,2 @@
+UEFI-SCT
+========
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/luv-parser-sbbr b/meta-luv/recipes-bsp/sbbr/sbbr/luv-parser-sbbr
new file mode 100644
index 0000000..cbbca0f
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/luv-parser-sbbr
@@ -0,0 +1,41 @@
+#!/bin/sh
+#
+# Parse the output of the SBBR tests and write a luv-test-manager
+# compatible version to stdout.
+#
+awk '/\=\=\=/ {
+	# There is not a clear way of identifying the end of a test. Thus,
+	# we rely on the start of the next test. Of course, we should not
+	# print the END tag if we are not parsing any test.
+	prev_test = test;
+	test=$2;
+	if (!parsing_tests) {
+		parsing_tests = 1;
+		prev_test = test;
+	} else {
+		printf "1.0 sbbr %s RESULT %d %d %d 0\n", prev_test, passes,
+			fails, skips;
+		passes = 0; fails = 0; skips =0;
+		printf ("1.0 sbbr %s END\n", prev_test);
+	}
+
+	# We have reached of the test cases
+	if ($2 == "Overall") {
+		exit 0;
+	}
+
+	printf ("1.0 sbbr %s START\n", test);
+	fflush("");
+}
+
+{
+	printf ("1.0 sbbr %s INFO %s \n", test, $0);
+}
+
+/^Summary/ {
+	passes += $2
+	fails += $4
+
+	if (!passes && !fails)
+		skips += 1
+}'
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/luv-test-sbbr b/meta-luv/recipes-bsp/sbbr/sbbr/luv-test-sbbr
new file mode 100644
index 0000000..abdd66c
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/luv-test-sbbr
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# Check to see whether the SBBR tests were run as part of this boot.
+#
+
+EFI_PATH="/mnt/luv-efi"
+sbbr_log=/home/root/sbbr-log.txt
+
+if [ ! -e $sbbr_log ]; then
+    # Nothing to do, no test results.
+    exit 0
+fi
+
+cat $sbbr_log
+
+# if booted from disk, create a new emtpy log file to use when rebooting
+grep -q luv\.netboot /proc/cmdline
+if [ $? -ne 0 ]; then
+    mkdir -p /tmp/newsbbrrd/home/root
+    yes '' | head -c 524288 >  /tmp/newsbbrrd/home/root/sbbr-log.txt
+    cd /tmp/newsbbrsrd
+    find . | cpio --create --format='newc' > ${EFI_PATH}/boot/sbbrrd
+    rm -fr /tmp/newsbbrrd
+fi
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/sbbr_v1.0.patch b/meta-luv/recipes-bsp/sbbr/sbbr/sbbr_v1.0.patch
new file mode 100644
index 0000000..f8ce19c
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/sbbr_v1.0.patch
@@ -0,0 +1,8074 @@
+diff --git a/SctPkg/CommonGenFramework.sh b/SctPkg/CommonGenFramework.sh
+index 2c0d159..d7b4650 100755
+--- a/SctPkg/CommonGenFramework.sh
++++ b/SctPkg/CommonGenFramework.sh
+@@ -1,51 +1,51 @@
+ #!/bin/sh
+-# The material contained herein is not a license, either      
+-# expressly or impliedly, to any intellectual property owned  
+-# or controlled by any of the authors or developers of this   
+-# material or to any contribution thereto. The material       
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
+ # contained herein is provided on an "AS IS" basis and, to the
+ # maximum extent permitted by applicable law, this information
+-# is provided AS IS AND WITH ALL FAULTS, and the authors and  
+-# developers of this material hereby disclaim all other       
+-# warranties and conditions, either express, implied or       
+-# statutory, including, but not limited to, any (if any)      
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
+ # implied warranties, duties or conditions of merchantability,
+-# of fitness for a particular purpose, of accuracy or         
+-# completeness of responses, of results, of workmanlike       
+-# effort, of lack of viruses and of lack of negligence, all   
+-# with regard to this material and any contribution thereto.  
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
+ # Designers must not rely on the absence or characteristics of
+-# any features or instructions marked "reserved" or           
+-# "undefined." The Unified EFI Forum, Inc. reserves any       
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
+ # features or instructions so marked for future definition and
+-# shall have no responsibility whatsoever for conflicts or    
++# shall have no responsibility whatsoever for conflicts or
+ # incompatibilities arising from future changes to them. ALSO,
+ # THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
+-# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR          
+-# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY      
+-# CONTRIBUTION THERETO.                                       
+-#                                                             
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
+ # IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
+-# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR   
+-# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST    
+-# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,      
+-# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER 
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
+ # UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
+-# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS     
+-# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF   
+-# THE POSSIBILITY OF SUCH DAMAGES.                            
+-#                                                             
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
+ # Copyright 2006 - 2015 Unified EFI, Inc. All
+-# Rights Reserved, subject to all existing rights in all      
+-# matters included within this Test Suite, to which United    
+-# EFI, Inc. makes no claim of right.                          
+-#                                                             
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
+ # Copyright (c) 2014 - 2015, Intel Corporation. All rights reserved.
+-# Copyright (c) 2011, 2012 ARM Ltd All rights reserved. 
++# Copyright (c) 2011, 2012 ARM Ltd All rights reserved.
++#
+ #
+ #
+ #
+-# 
+ # Module Name
+ #
+ #   CommonGenFramework.sh
+@@ -120,15 +120,15 @@ CopyDependencyFile()
+ 
+ CopyDependency()
+ {
+-    mkdir -p $Framework/Dependency/$1BBTest	
++    mkdir -p $Framework/Dependency/$1BBTest
+     ls -h $ProcessorType/$1_Invalid*       > temp.txt 2>NUL
+     ls -h $ProcessorType/$1_*.efi   >> temp.txt 2>NUL
+     ls -h $ProcessorType/$1_*.ini   >> temp.txt 2>NUL
+     ls -h $ProcessorType/$1_*.cmp   >> temp.txt 2>NUL
+     ls -h $ProcessorType/$1_*.ucmp  >> temp.txt 2>NUL
+ 
+-    while read line 																																												 
+-      do 
++    while read line
++      do
+         CopyDependencyFile $1 $line
+       done < temp.txt
+     rm -f temp.txt >NUL
+@@ -138,8 +138,8 @@ CopyDependency()
+ # For UEFI SCT
+ # *********************************************
+ 
+-if [ $1 = "uefi_sct" ] 
+-then 
++if [ $1 = "uefi_sct" ]
++then
+     # *********************************************
+     # Copy the UEFI 2.1 Test Cases
+     # *********************************************
+@@ -355,4 +355,65 @@ then
+   CopyDependency Ebc
+   CopyDependency PxeBaseCode
+ fi
++# *********************************************
++# For SBBR v1.0 SCT
++# *********************************************
++
++if [ $1 = "sbbr_sct" ]
++then
++    # *********************************************
++    # Copy the SBBR v1.0 Test Cases
++    # *********************************************
++
++    mkdir -p $Framework/SCRT
++    cp $ProcessorType/SCRTDRIVER.efi                           $Framework/SCRT  > NUL
++    cp $ProcessorType/SCRTAPP.efi                              $Framework/SCRT  > NUL
++    cp ../../../SctPkg/Config/Data/SCRT.conf                   $Framework/SCRT  > NUL
++
++    # *********************************************
++    # Copy your test cases here
++    # *********************************************
++
++    # Boot Services Tests - SBBR v1.0 Appendix A
++    cp $ProcessorType/EventTimerTaskPriorityServicesBBTest.efi $Framework/Test/ > NUL
++    cp $ProcessorType/ImageServicesBBTest.efi                  $Framework/Test/ > NUL
++    cp $ProcessorType/MemoryAllocationServicesBBTest.efi       $Framework/Test/ > NUL
++    cp $ProcessorType/MiscBootServicesBBTest.efi               $Framework/Test/ > NUL
++    cp $ProcessorType/ProtocolHandlerServicesBBTest.efi        $Framework/Test/ > NUL
+ 
++    # Tests SBBR sections 3.3.1, 3.3.2, 3.3.3, and 3.3.4
++    cp $ProcessorType/SysEnvConfigBBTest.efi                   $Framework/Test/ > NUL
++
++    # UEFI Boot Services - SBBR v1.0 3.4
++    cp $ProcessorType/SbbrBootServicesBBTest.efi               $Framework/Test/ > NUL
++
++    # Check if EFI Specification Version is 2.5 or greater
++    cp $ProcessorType/EfiSpecVerLvlBBTest.efi                  $Framework/Test/ > NUL
++
++    # SMBIOS Requirements on UEFI - SBBR v1.0 5.1.1
++    cp $ProcessorType/SbbrSmbiosBBTest.efi                     $Framework/Test/ > NUL
++
++    # Runtime Services Tests - SBBR v1.0 Appendix B
++    cp $ProcessorType/VariableServicesBBTest.efi               $Framework/Test/ > NUL
++    cp $ProcessorType/TimeServicesBBTest.efi                   $Framework/Test/ > NUL
++    cp $ProcessorType/MiscRuntimeServicesBBTest.efi            $Framework/Test/ > NUL
++    cp $ProcessorType/SBBRRuntimeServicesBBTest.efi            $Framework/Test/ > NUL
++
++    # Tests SBBR Appendix C
++    cp $ProcessorType/RequiredUefiProtocolsBBTest.efi          $Framework/Test/ > NUL
++    cp $ProcessorType/EfiCompliantBBTest.efi                   $Framework/Test/ > NUL
++
++    # *********************************************
++    # Copy ENTS binary
++    # *********************************************
++
++    cp $ProcessorType/SerialMonitor.efi                $Framework/Ents/Support/ > NUL
++    cp $ProcessorType/ManagedNetworkMonitor.efi        $Framework/Ents/Support/ > NUL
++    cp $ProcessorType/IP4NetworkMonitor.efi            $Framework/Ents/Support/ > NUL
++    cp $ProcessorType/Eftp.efi                         $Framework/Ents/Support/ > NUL
++
++    # *********************************************
++    # Copy the test dependency files
++    # *********************************************
++
++fi
+diff --git a/SctPkg/Config/Data/Category.ini b/SctPkg/Config/Data/Category.ini
+index 91bc015..c63876d 100644
+--- a/SctPkg/Config/Data/Category.ini
++++ b/SctPkg/Config/Data/Category.ini
+@@ -120,8 +120,29 @@ Description   =
+ 
+ [Category Data]
+ Revision      = 0x00010000
+-CategoryGuid  = E9EF7553-F833-4E56-96E8-38AE679523CC
+-InterfaceGuid = E9EF7553-F833-4E56-96E8-38AE679523CC
++CategoryGuid  = 6b4d5d18-f55f-4fc5-8496-f10022375c04
++InterfaceGuid = 71652D04-BF38-434A-BCB8-6547D7FD8384
++Name          = GenericTest\SbbrRequiredUefiProtocols
++Description   = Checks that UEFI protocols required by ARM SBBR are present.
++
++[Category Data]
++Revision      = 0x00010000
++CategoryGuid  = 852e92eb-d7aa-4d61-84ef-d32dc5d545ec
++InterfaceGuid = 71652D04-BF38-434A-BCB8-6547D7FD8384
++Name          = GenericTest\SbbrSmbios
++Description   = Checks that SMBIOS on UEFI is implemented correctly.
++
++[Category Data]
++Revision      = 0x00010000
++CategoryGuid  = D84A6430-99F5-4660-8454-6E4C896A7E51
++InterfaceGuid = 71652D04-BF38-434a-BCB8-6547D7FD8384
++Name          = GenericTest\SbbrSysEnvConfig
++Description   =
++
++[Category Data]
++Revision      = 0x00010000
++CategoryGuid  = E9EF7553-F833-4e56-96E8-38AE679523CC
++InterfaceGuid = E9EF7553-F833-4e56-96E8-38AE679523CC
+ Name          = BootServicesTest
+ Description   =
+ 
+@@ -162,8 +183,15 @@ Description   =
+ 
+ [Category Data]
+ Revision      = 0x00010000
+-CategoryGuid  = AFF115FB-387B-4C18-8C41-6AFC7F03BB90
+-InterfaceGuid = AFF115FB-387B-4C18-8C41-6AFC7F03BB90
++CategoryGuid  = 8dafd7a7-44d0-4cf4-9d28-9f87080fc091
++InterfaceGuid = E9EF7553-F833-4E56-96E8-38AE679523CC
++Name          = BootServicesTest\SbbrBootServices
++Description   = Tests SBBR boot services requirements.
++
++[Category Data]
++Revision      = 0x00010000
++CategoryGuid  = AFF115FB-387B-4c18-8C41-6AFC7F03BB90
++InterfaceGuid = AFF115FB-387B-4c18-8C41-6AFC7F03BB90
+ Name          = RuntimeServicesTest
+ Description   =
+ 
+@@ -197,8 +225,15 @@ Description   =
+ 
+ [Category Data]
+ Revision      = 0x00010000
+-CategoryGuid  = 5B1B31A1-9562-11D2-8E3F-00A0C969723B
+-InterfaceGuid = 5B1B31A1-9562-11D2-8E3F-00A0C969723B
++CategoryGuid  = 52A69BBF-E19F-4e82-93D6-AAC46E2E1E06
++InterfaceGuid = AFF115FB-387B-4c18-8C41-6AFC7F03BB90
++Name          = RuntimeServicesTest\SBBRRuntimeServicesTest
++Description   =
++
++[Category Data]
++Revision      = 0x00010000
++CategoryGuid  = 5B1B31A1-9562-11d2-8E3F-00A0C969723B
++InterfaceGuid = 5B1B31A1-9562-11d2-8E3F-00A0C969723B
+ Name          = LoadedImageProtocolTest
+ Description   =
+ 
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/Guid.c b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/Guid.c
+new file mode 100644
+index 0000000..a0224a9
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/Guid.c
+@@ -0,0 +1,65 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  Global variable assignments for GUIDs used in test assertions.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID gSbbrBootServicesAssertion001Guid = SBBRBOOTSERVICES_ASSERTION_001_GUID;
++
++EFI_GUID gSbbrBootServicesAssertion002Guid = SBBRBOOTSERVICES_ASSERTION_002_GUID;
++
++EFI_GUID gSbbrBootServicesAssertion003Guid = SBBRBOOTSERVICES_ASSERTION_003_GUID;
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/Guid.h b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/Guid.h
+new file mode 100644
+index 0000000..9f7d5a9
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/Guid.h
+@@ -0,0 +1,76 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  Definitions for GUIDs used in test assertions.
++
++--*/
++
++#ifndef _SBBRBOOTSERVICES_GUID_H_
++#define _SBBRBOOTSERVICES_GUID_H_
++
++#define SBBRBOOTSERVICES_ASSERTION_001_GUID \
++{ 0x58a44f17, 0x760e, 0x478b, {0xba, 0xef, 0xe2, 0x0b, 0xfb, 0xcd, 0x74, 0x57 }}
++
++extern EFI_GUID gSbbrBootServicesAssertion001Guid;
++
++#define SBBRBOOTSERVICES_ASSERTION_002_GUID \
++{ 0x1e4cdbab, 0x9727, 0x4f71, {0x88, 0x25, 0xb4, 0xb1, 0x6a, 0x58, 0xcf, 0x84 }}
++
++extern EFI_GUID gSbbrBootServicesAssertion002Guid;
++
++#define SBBRBOOTSERVICES_ASSERTION_003_GUID \
++{ 0x2a326d84, 0x5e23, 0x40e1, {0xb8, 0xae, 0xf7, 0xa9, 0xce, 0x18, 0xf9, 0xb5 }}
++
++extern EFI_GUID gSbbrBootServicesAssertion003Guid;
++
++#endif /* _SBBRBOOTSERVICES_GUID_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTest.inf b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTest.inf
+new file mode 100644
+index 0000000..9abf4e2
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTest.inf
+@@ -0,0 +1,85 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2016, ARM Ltd. All rights reserved.
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   SbbrBootServicesBBTest.inf
++#
++# Abstract:
++#
++#   Component description file for SbbrBootServices tests.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010005
++  BASE_NAME            = SbbrBootServicesBBTest
++  FILE_GUID            = 9fa74174-eacf-468a-adca-f23a6ee190d2
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTestSbbrBootServices
++
++[Sources.common]
++  SbbrBootServicesBBTestMain.c
++  SbbrBootServicesBBTestFunction.c
++  Guid.c
++
++[Packages]
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  UefiDriverEntryPoint
++  SctLib
++  EfiTestLib
++
++[Protocols]
++
++[Guids]
++  gEfiSmbios3TableGuid
++  gEfiAcpi20TableGuid
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestFunction.c b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestFunction.c
+new file mode 100644
+index 0000000..fb50702
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestFunction.c
+@@ -0,0 +1,549 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrBootServicesBBTestFunction.c
++
++Abstract:
++
++  Test case function definitions for SbbrBootServices.
++
++--*/
++
++#include "Guid.h"
++#include <IndustryStandard/Acpi20.h>
++#include <IndustryStandard/SmBios.h>
++#include "SbbrBootServicesBBTestMain.h"
++#include "SbbrBootServicesBBTestFunction.h"
++#include "SctLib.h"
++
++/* Helper Functions */
++
++STATIC
++UINT8
++SbbrBootServicesByteChecksum (
++  IN VOID                 *Data,
++  IN UINT32               Length
++  )
++{
++  UINT32 i;
++  UINT8 sum = 0;
++  UINT8 *Bytes = (UINT8 *)Data;
++
++  for (i = 0; i < Length; i++){
++    sum = sum + Bytes[i];
++  }
++
++  return sum;
++}
++
++STATIC
++UINT32
++SbbrBootServicesIsRam (
++  EFI_MEMORY_DESCRIPTOR *MemoryMapEntry
++  )
++{
++  switch (MemoryMapEntry->Type)
++  {
++    case EfiLoaderCode:
++    case EfiLoaderData:
++    case EfiBootServicesCode:
++    case EfiBootServicesData:
++    case EfiRuntimeServicesCode:
++    case EfiRuntimeServicesData:
++    case EfiConventionalMemory:
++      return TRUE;
++    default:
++      return FALSE;
++  }
++}
++
++/**
++ *  Entrypoint for MemoryMap Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTestMemoryMapTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  UINTN                               MemoryMapSize;
++  VOID                                *MemoryMap;
++  EFI_MEMORY_DESCRIPTOR               *MemoryMapDescriptor;
++  UINTN                               MapKey;
++  UINTN                               DescriptorSize;
++  UINT32                              DescriptorVersion;
++  UINT32                              i;
++  UINT32                              error;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Getting memory map
++  //
++  MemoryMapSize = 0;
++  Status = gtBS->GetMemoryMap (
++              &MemoryMapSize,
++              MemoryMap,
++              &MapKey,
++              &DescriptorSize,
++              &DescriptorVersion
++              );
++  if (Status != EFI_BUFFER_TOO_SMALL){
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion001Guid,
++                L"MemoryMap",
++                L"%a:%d - MemoryMap Not Found",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++  MemoryMap = SctAllocatePool(MemoryMapSize);
++  if (MemoryMap == 0) {
++    return EFI_OUT_OF_RESOURCES;
++  }
++  Status = gtBS->GetMemoryMap (
++              &MemoryMapSize,
++              MemoryMap,
++              &MapKey,
++              &DescriptorSize,
++              &DescriptorVersion
++              );
++  if (EFI_ERROR (Status)) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion001Guid,
++                L"MemoryMap",
++                L"%a:%d - MemoryMap Not Found",
++                __FILE__,
++                __LINE__
++                );
++    SctFreePool(MemoryMap);
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Looping through each descriptor
++  //
++  for (i = 0; i < MemoryMapSize / DescriptorSize; i++) {
++    MemoryMapDescriptor = (EFI_MEMORY_DESCRIPTOR *)(MemoryMap + (i * DescriptorSize));
++    error = FALSE;
++
++    //
++    // Checking for identity mapping
++    //
++    if (MemoryMapDescriptor->PhysicalStart != MemoryMapDescriptor->VirtualStart) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gSbbrBootServicesAssertion001Guid,
++                  L"MemoryMap",
++                  L"%a:%d - MemoryMap 0x%X Not Identity Mapped",
++                  __FILE__,
++                  __LINE__,
++                  MemoryMapDescriptor
++                  );
++      error = TRUE;
++    }
++
++    //
++    // Checking attribute
++    //
++    if (SbbrBootServicesIsRam(MemoryMapDescriptor) == TRUE && !(MemoryMapDescriptor->Attribute & EFI_MEMORY_WB)) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gSbbrBootServicesAssertion001Guid,
++                  L"MemoryMap",
++                  L"%a:%d - MemoryMap 0x%X Attribute Not Supported",
++                  __FILE__,
++                  __LINE__,
++                  MemoryMapDescriptor
++                  );
++      error = TRUE;
++    }
++
++    //
++    // Checking for 64KB alignment
++    //
++    if (MemoryMapDescriptor->PhysicalStart & (SIZE_64KB - 1)) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gSbbrBootServicesAssertion001Guid,
++                  L"MemoryMap",
++                  L"%a:%d - MemoryMap 0x%X Not Aligned to 64KB",
++                  __FILE__,
++                  __LINE__,
++                  MemoryMapDescriptor
++                  );
++      error = TRUE;
++    }
++
++    //
++    // No issues found
++    //
++    if (error == FALSE) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_PASSED,
++                  gSbbrBootServicesAssertion001Guid,
++                  L"MemoryMap 0x%X",
++                  L"%a:%d",
++                  __FILE__,
++                  __LINE__,
++                  MemoryMapDescriptor
++                  );
++    }
++  }
++
++  SctFreePool(MemoryMap);
++  return EFI_SUCCESS;
++}
++
++/**
++ *  Entrypoint for AcpiTable Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTestAcpiTableTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  UINTN                               IStatus;
++  EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER     *AcpiTable;
++  UINT8                               Checksum;
++  UINT32                              i;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Looking for ACPI table
++  //
++  Status = SctGetSystemConfigurationTable (
++              &gEfiAcpi20TableGuid,
++              &AcpiTable
++              );
++  if (EFI_ERROR (Status)){
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d - ACPI Table Not Found",
++                __FILE__,
++                __LINE__
++                );
++  }
++
++  //
++  // Checking ACPI table signature
++  //
++  IStatus = SctCompareMem (
++              &AcpiTable->Signature,
++              RSDP_SIGNATURE_STRING,
++              sizeof(RSDP_SIGNATURE_STRING) - 1
++              );
++  if (IStatus != 0) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d - ACPI Table Invalid Signature",
++                __FILE__,
++                __LINE__
++                );
++  }
++
++  //
++  // Checking ACPI table checksum
++  //
++  Checksum = SbbrBootServicesByteChecksum (AcpiTable, ACPI_TABLE_CHECKSUM_LENGTH);
++  if (Checksum != 0) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d - ACPI Table Invalid Checksum",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking ACPI table extended checksum
++  //
++  Checksum = SbbrBootServicesByteChecksum (AcpiTable, AcpiTable->Length);
++  if (Checksum != 0) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d - ACPI Table Invalid Extended Checksum",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking ACPI table length
++  //
++  if (AcpiTable->Length != ACPI_TABLE_EXPECTED_LENGTH) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d - ACPI Table Invalid Length",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking ACPI table XSDT address
++  //
++  if (AcpiTable->XsdtAddress == 0) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d - ACPI Table Invalid XSDT Pointer",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_PASSED,
++                gSbbrBootServicesAssertion002Guid,
++                L"AcpiTable",
++                L"%a:%d",
++                __FILE__,
++                __LINE__
++                );
++
++  return EFI_SUCCESS;
++}
++
++/**
++ *  Entrypoint for SmbiosTable Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTestSmbiosTableTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  INTN                                IStatus;
++  SMBIOS_TABLE_3_0_ENTRY_POINT        *SmbiosTable;
++  UINT8                               Checksum;
++  UINT32                              i;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Looking for SMBIOS table
++  //
++  Status = SctGetSystemConfigurationTable (
++              &gEfiSmbios3TableGuid,
++              &SmbiosTable
++              );
++  if (EFI_ERROR(Status)) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion003Guid,
++                L"SmbiosTable",
++                L"%a:%d - SMBIOS Table Not Found",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking SMBIOS Anchor String
++  //
++  IStatus = SctCompareMem (
++              SmbiosTable->AnchorString,
++              SMBIOS30_ANCHOR_STRING,
++              sizeof(SMBIOS30_ANCHOR_STRING) - 1
++              );
++  if (IStatus != 0) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion003Guid,
++                L"SmbiosTable",
++                L"%a:%d - SMBIOS Table Anchor String Not Found",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking entry point revision
++  //
++  if (SmbiosTable->EntryPointRevision != 1) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion003Guid,
++                L"SmbiosTable",
++                L"%a:%d - SMBIOS Table Invalid Entry Point Revision",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking entry point checksum
++  //
++  Checksum = SbbrBootServicesByteChecksum (SmbiosTable, SmbiosTable->EntryPointLength);
++  if (Checksum != 0) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrBootServicesAssertion003Guid,
++                L"SmbiosTable",
++                L"%a:%d - SMBIOS Table Invalid Checksum",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  StandardLib->RecordAssertion (
++              StandardLib,
++              EFI_TEST_ASSERTION_PASSED,
++              gSbbrBootServicesAssertion003Guid,
++              L"SmbiosTable",
++              L"%a:%d",
++              __FILE__,
++              __LINE__
++              );
++
++  return EFI_SUCCESS;
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestFunction.h b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestFunction.h
+new file mode 100644
+index 0000000..841aed9
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestFunction.h
+@@ -0,0 +1,85 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrBootServicesBBTestFunction.h
++
++Abstract:
++
++  Contains definitions and prototypes for test case functions.
++
++--*/
++
++#ifndef _SBBRBOOTSERVICES_BB_TEST_FUNCTION_H_
++#define _SBBRBOOTSERVICES_BB_TEST_FUNCTION_H_
++
++EFI_STATUS
++BBTestMemoryMapTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestAcpiTableTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestSmbiosTableTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _SBBRBOOTSERVICES_BB_TEST_FUNCTION_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestMain.c b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestMain.c
+new file mode 100644
+index 0000000..584b38c
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestMain.c
+@@ -0,0 +1,149 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrBootServicesBBTestMain.c
++
++Abstract:
++
++  Test driver for SbbrBootServices tests.
++
++--*/
++
++#include "SctLib.h"
++#include "SbbrBootServicesBBTestMain.h"
++#include "SbbrBootServicesBBTestFunction.h"
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  SBBRBOOTSERVICES_TEST_REVISION,
++  SBBRBOOTSERVICES_TEST_GUID,
++  L"SbbrBootServices Tests",
++  L"Tests SBBR boot services requirements."
++};
++
++EFI_GUID gSupportProtocolGuid[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    SBBRBOOTSERVICES_MEMORYMAP_GUID,
++    L"MemoryMap",
++    L"Checks memory map provided by UEFI.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestMemoryMapTest
++  },
++  {
++    SBBRBOOTSERVICES_SMBIOSTABLE_GUID,
++    L"SmbiosTable",
++    L"Checks that SMBIOS3 table is provided by UEFI.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestSmbiosTableTest
++  },
++  {
++    SBBRBOOTSERVICES_ACPITABLE_GUID,
++    L"AcpiTable",
++    L"Checks that ACPI table is provided by UEFI.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestAcpiTableTest
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/**
++ *  The driver's Unload function
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was Uninstalled
++*/
++EFI_STATUS
++BBTestSbbrBootServicesUnload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++           ImageHandle,
++           gBBTestProtocolInterface
++           );
++}
++
++/**
++ *  Creates/installs the BlackBox Interface and eminating Entry Point
++ *  node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER: One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTestSbbrBootServices (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++  SctInitializeLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++           &ImageHandle,
++           &gBBTestProtocolField,
++           gBBTestEntryField,
++           BBTestSbbrBootServicesUnload,
++           &gBBTestProtocolInterface
++           );
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestMain.h b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestMain.h
+new file mode 100644
+index 0000000..e0a81ab
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTestMain.h
+@@ -0,0 +1,99 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrBootServicesBBTestMain.h
++
++Abstract:
++
++  Contains definitions for test information and test GUIDs.
++
++--*/
++
++#ifndef _SBBRBOOTSERVICES_TEST_MAIN_H_
++#define _SBBRBOOTSERVICES_TEST_MAIN_H_
++
++#include "Efi.h"
++#include "Guid.h"
++#include <Library/EfiTestLib.h>
++
++#define SBBRBOOTSERVICES_TEST_REVISION 0x00010000
++
++#define SBBRBOOTSERVICES_TEST_GUID \
++  { 0x8dafd7a7, 0x44d0, 0x4cf4, {0x9d, 0x28, 0x9f, 0x87, 0x08, 0x0f, 0xc0, 0x91 }}
++
++#define ACPI_TABLE_EXPECTED_LENGTH 36
++#define ACPI_TABLE_CHECKSUM_LENGTH 20
++#define SMBIOS30_ANCHOR_STRING "_SM3_"
++#define RSDP_SIGNATURE_STRING "RSD PTR "
++
++EFI_STATUS
++InitializeBBTestSbbrBootServices (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++EFI_STATUS
++BBTestSbbrBootServicesUnload (
++  IN EFI_HANDLE       ImageHandle
++  );
++
++//
++// Test Case GUIDs
++//
++
++#define SBBRBOOTSERVICES_MEMORYMAP_GUID \
++  { 0x8540c12d, 0x5413, 0x4a0b, {0xa5, 0x45, 0x89, 0xa8, 0xe3, 0xc7, 0xda, 0x4b }}
++
++#define SBBRBOOTSERVICES_ACPITABLE_GUID \
++  { 0x40ff8495, 0x8ae9, 0x442e, {0x89, 0xf2, 0xf8, 0x97, 0xbb, 0x7c, 0x41, 0x75 }}
++
++#define SBBRBOOTSERVICES_SMBIOSTABLE_GUID \
++  { 0xc44ca44c, 0x4f4e, 0x4760, {0x96, 0xc9, 0xb8, 0xcd, 0xe5, 0x31, 0xb4, 0xc4 }}
++
++#endif /* _SBBRBOOTSERVICES_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/EfiCompliant/BlackBoxTest/EfiCompliantBBTestPlatform_uefi.c b/SctPkg/TestCase/UEFI/EFI/Generic/EfiCompliant/BlackBoxTest/EfiCompliantBBTestPlatform_uefi.c
+index 81d00fe..c68395d 100644
+--- a/SctPkg/TestCase/UEFI/EFI/Generic/EfiCompliant/BlackBoxTest/EfiCompliantBBTestPlatform_uefi.c
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/EfiCompliant/BlackBoxTest/EfiCompliantBBTestPlatform_uefi.c
+@@ -1528,62 +1528,24 @@ CheckUefiNetworkApplication (
+                        NULL,
+                        (VOID **)&TempInterface
+                        );
+-      switch (Index) {
+-        case 0:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 1:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 2:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 3:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 4:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        default:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-      }
+-   
+-      Status = gtBS->LocateProtocol (
+-                       &Guid[Index+7],
+-                       NULL,
+-                       (VOID **)&Interface
+-                       );
+       if (!EFI_ERROR (Status)) {
+-        Value[Index+7] = TRUE;
++        TempInterface->CreateChild (TempInterface, &ChildHandle);
++
++        Status = gtBS->LocateProtocol (
++                         &Guid[Index+7],
++                         NULL,
++                         (VOID **)&Interface
++                         );
++        if (!EFI_ERROR (Status)) {
++          Value[Index+7] = TRUE;
++        } else {
++          Value[Index+7] = FALSE;
++        }
++     
++        TempInterface->DestroyChild (TempInterface, ChildHandle);
+       } else {
+         Value[Index+7] = FALSE;
+       }
+-   
+-      switch (Index) {
+-        case 0:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 1:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 2:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 3:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 4:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        default:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-      }
+     } 
+ 
+     AssertionType = NeedOrWarning (13, Value);
+@@ -1726,55 +1688,24 @@ CheckUefiV6NetworkApplication (
+                        NULL,
+                        (VOID **) &TempInterface
+                        );
+-      switch (Index) {
+-        case 0:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 1:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 2:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        case 3:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-          break;
+-        default:
+-          TempInterface->CreateChild(TempInterface, &ChildHandle);
+-      }
+-
+-      Status = gtBS->LocateProtocol (
+-                       &Guid[Index+5],
+-                       NULL,
+-                       (VOID **) &Interface
+-                       );
+       if (!EFI_ERROR (Status)) {
+-        Value[Index+5] = TRUE;
++        TempInterface->CreateChild (TempInterface, &ChildHandle);
++
++        Status = gtBS->LocateProtocol (
++                         &Guid[Index+5],
++                         NULL,
++                         (VOID **) &Interface
++                         );
++        if (!EFI_ERROR (Status)) {
++          Value[Index+5] = TRUE;
++        } else {
++          Value[Index+5] = FALSE;
++        }
++        
++        TempInterface->DestroyChild (TempInterface, ChildHandle);
+       } else {
+         Value[Index+5] = FALSE;
+       }
+-      
+-      switch (Index) {
+-        case 0:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 1:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 2:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        case 3:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-          break;
+-        default:
+-          TempInterface->DestroyChild(TempInterface, ChildHandle);
+-          ChildHandle = NULL;
+-      }
+     } 
+ 
+     AssertionType = NeedOrWarning (9, Value);
+@@ -3000,24 +2931,26 @@ CheckDNS4Protocols (
+                        NULL,
+                        (VOID **) &TempInterface
+                        );
++    if (!EFI_ERROR (Status)) {
++      TempInterface->CreateChild (TempInterface, &ChildHandle);
+ 
+-    TempInterface->CreateChild(TempInterface, &ChildHandle);
+-
++      Status = gtBS->LocateProtocol (
++                       &gEfiDns4ProtocolGuid,
++                       NULL,
++                       (VOID **) &Interface
++                       );
++      if (!EFI_ERROR (Status)) {
++        ValueB = TRUE;
++      } else {
++        ValueB = FALSE;
++      }
+ 
+-    Status = gtBS->LocateProtocol (
+-                     &gEfiDns4ProtocolGuid,
+-                     NULL,
+-                     (VOID **) &Interface
+-                     );
+-    if (!EFI_ERROR (Status)) {
+-      ValueB = TRUE;
++      TempInterface->DestroyChild (TempInterface, ChildHandle);
++      ChildHandle = NULL;
+     } else {
+       ValueB = FALSE;
+     }
+ 
+-    TempInterface->DestroyChild(TempInterface, ChildHandle);
+-    ChildHandle = NULL;
+-
+     AssertionType = NeedOneOrWarning (ValueB);
+ 
+     if (AssertionType == EFI_TEST_ASSERTION_FAILED) {
+@@ -3128,24 +3061,26 @@ CheckDNS6Protocols (
+                        NULL,
+                        (VOID **) &TempInterface
+                        );
++    if (!EFI_ERROR (Status)) {
++      TempInterface->CreateChild (TempInterface, &ChildHandle);
+ 
+-    TempInterface->CreateChild(TempInterface, &ChildHandle);
+-
++      Status = gtBS->LocateProtocol (
++                       &gEfiDns6ProtocolGuid,
++                       NULL,
++                       (VOID **) &Interface
++                       );
++      if (!EFI_ERROR (Status)) {
++        ValueB = TRUE;
++      } else {
++        ValueB = FALSE;
++      }
+ 
+-    Status = gtBS->LocateProtocol (
+-                     &gEfiDns6ProtocolGuid,
+-                     NULL,
+-                     (VOID **) &Interface
+-                     );
+-    if (!EFI_ERROR (Status)) {
+-      ValueB = TRUE;
++      TempInterface->DestroyChild (TempInterface, ChildHandle);
++      ChildHandle = NULL;
+     } else {
+       ValueB = FALSE;
+     }
+ 
+-    TempInterface->DestroyChild(TempInterface, ChildHandle);
+-    ChildHandle = NULL;
+-
+     AssertionType = NeedOneOrWarning (ValueB);
+ 
+     if (AssertionType == EFI_TEST_ASSERTION_FAILED) {
+@@ -3269,24 +3204,26 @@ CheckTLSProtocols (
+                        NULL,
+                        (VOID **) &TempInterface
+                        );
++    if (!EFI_ERROR (Status)) {
++      TempInterface->CreateChild (TempInterface, &ChildHandle);
+ 
+-    TempInterface->CreateChild(TempInterface, &ChildHandle);
+-
++      Status = gtBS->LocateProtocol (
++                       &gEfiTlsProtocolGuid,
++                       NULL,
++                       (VOID **) &Interface
++                       );
++      if (!EFI_ERROR (Status)) {
++        ValueC = TRUE;
++      } else {
++        ValueC = FALSE;
++      }
+ 
+-    Status = gtBS->LocateProtocol (
+-                     &gEfiTlsProtocolGuid,
+-                     NULL,
+-                     (VOID **) &Interface
+-                     );
+-    if (!EFI_ERROR (Status)) {
+-      ValueC = TRUE;
++      TempInterface->DestroyChild (TempInterface, ChildHandle);
++      ChildHandle = NULL;
+     } else {
+       ValueC = FALSE;
+     }
+ 
+-    TempInterface->DestroyChild(TempInterface, ChildHandle);
+-    ChildHandle = NULL;
+-
+     AssertionType = NeedOneOrWarning (ValueC);
+ 
+     if (AssertionType == EFI_TEST_ASSERTION_FAILED) {
+@@ -3412,24 +3349,26 @@ CheckHTTPProtocols (
+                        NULL,
+                        (VOID **) &TempInterface
+                        );
++    if (!EFI_ERROR (Status)){
++      TempInterface->CreateChild (TempInterface, &ChildHandle);
+ 
+-    TempInterface->CreateChild(TempInterface, &ChildHandle);
+-
++      Status = gtBS->LocateProtocol (
++                       &gEfiHttpProtocolGuid,
++                       NULL,
++                       (VOID **) &Interface
++                       );
++      if (!EFI_ERROR (Status)) {
++        ValueC = TRUE;
++      } else {
++        ValueC = FALSE;
++      }
+ 
+-    Status = gtBS->LocateProtocol (
+-                     &gEfiHttpProtocolGuid,
+-                     NULL,
+-                     (VOID **) &Interface
+-                     );
+-    if (!EFI_ERROR (Status)) {
+-      ValueC = TRUE;
++      TempInterface->DestroyChild (TempInterface, ChildHandle);
++      ChildHandle = NULL;
+     } else {
+       ValueC = FALSE;
+     }
+ 
+-    TempInterface->DestroyChild(TempInterface, ChildHandle);
+-    ChildHandle = NULL;
+-
+     AssertionType = NeedOneOrWarning (ValueC);
+ 
+     if (AssertionType == EFI_TEST_ASSERTION_FAILED) {
+@@ -3663,23 +3602,25 @@ CheckBlueToothProtocols (
+                        NULL,
+                        (VOID **) &TempInterface
+                        );
+-
+-    TempInterface->CreateChild(TempInterface, &ChildHandle);
+-
+-
+-    Status = gtBS->LocateProtocol (
+-                     &gEfiBlueToothIoProtocolGuid,
+-                     NULL,
+-                     (VOID **) &Interface
+-                     );
+     if (!EFI_ERROR (Status)) {
+-      ValueD = TRUE;
++      TempInterface->CreateChild (TempInterface, &ChildHandle);
++
++      Status = gtBS->LocateProtocol (
++                       &gEfiBlueToothIoProtocolGuid,
++                       NULL,
++                       (VOID **) &Interface
++                       );
++      if (!EFI_ERROR (Status)) {
++        ValueD = TRUE;
++      } else {
++        ValueD = FALSE;
++      }
++      
++      TempInterface->DestroyChild (TempInterface, ChildHandle);
++      ChildHandle = NULL;
+     } else {
+       ValueD = FALSE;
+     }
+-    
+-    TempInterface->DestroyChild(TempInterface, ChildHandle);
+-    ChildHandle = NULL;
+ 
+     AssertionType = NeedOneOrWarning (ValueD);
+ 
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTest.inf b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTest.inf
+new file mode 100644
+index 0000000..daa4d44
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTest.inf
+@@ -0,0 +1,84 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   EfiSpecVerLvlBBTest.inf
++#
++# Abstract:
++#
++#   Component description file for SBBR EFI Specification Version Level test.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010019
++  BASE_NAME            = EfiSpecVerLvlBBTest
++  FILE_GUID            = f865a18a-9b47-420d-97ae-676d8016a513
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTestEfiSpecVerLvl
++
++[Sources.common]
++  EfiSpecVerLvlBBTestFunction.c
++  EfiSpecVerLvlBBTestMain.c
++  Guid.c
++
++[Packages]
++  ArmPkg/ArmPkg.dec
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  ArmLib
++  EfiTestLib
++  SctLib
++  UefiDriverEntryPoint
++
++[Protocols]
++  gBlackBoxEfiBlockIoProtocolGuid
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestFunction.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestFunction.c
+new file mode 100644
+index 0000000..3985b4a
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestFunction.c
+@@ -0,0 +1,130 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  EfiSpecVerLvlBBTestFunction.c
++
++Abstract:
++
++  Test case definitions for EfiSpecVerLvl test.
++
++--*/
++
++#include <Library/ArmLib.h>
++
++#include "EfiSpecVerLvlBBTestMain.h"
++#include "Guid.h"
++#include "SctLib.h"
++#include "EfiSpecVerLvlBBTestFunction.h"
++
++/** Entrypoint for EFI Specification Version Level Test.
++ *
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++//
++// SBBR 3.3.1
++//
++
++EFI_STATUS
++BBTestEfiSpecVerLvlTest (
++  IN EFI_BB_TEST_PROTOCOL               *This,
++  IN VOID                               *ClientInterface,
++  IN EFI_TEST_LEVEL                     TestLevel,
++  IN EFI_HANDLE                         SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL    *StandardLib;
++  EFI_STATUS                            Status;
++  UINTN                                 CurHrRev;
++
++  // Get the Standard Library Interface
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  CurHrRev = gtBS->Hdr.Revision; // Reading revision of the EFI Specification.
++
++  // Check if EFI Specification version is less than 2.5
++  if (gtBS->Hdr.Revision < EFI_2_50_SYSTEM_TABLE_REVISION){
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gTestGenericFailureGuid,
++                L"EFI Specification Version is below 2.5",
++                L"%a:%d:Current EFI Header Rev=0x%X",
++                __FILE__,
++                __LINE__,
++                CurHrRev
++                );
++    return EFI_INCOMPATIBLE_VERSION;
++  } else {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_PASSED,
++                gEfiSpecVerLvlAssertion01Guid,
++                L"TestEfiSpecVerLvl",
++                L"%a:%d:Current EFI Header Rev=0x%X",
++                __FILE__,
++                __LINE__,
++                CurHrRev
++                );
++
++    return EFI_SUCCESS;
++  }
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestFunction.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestFunction.h
+new file mode 100644
+index 0000000..0ea7aa7
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestFunction.h
+@@ -0,0 +1,71 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  EfiSpecVerLvlBBTestFunction.h
++
++Abstract:
++
++  Contains definitions and prototypes used in the test functions.
++
++--*/
++
++#ifndef _EFISPECVERLVL_BB_TEST_FUNCTION_H_
++#define _EFISPECVERLVL_BB_TEST_FUNCTION_H_
++
++#include <Library/EfiTestLib.h>
++
++EFI_STATUS
++BBTestEfiSpecVerLvlTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _EFISPECVERLVL_BB_TEST_FUNCTION_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestMain.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestMain.c
+new file mode 100644
+index 0000000..754644c
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestMain.c
+@@ -0,0 +1,127 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  EfiSpecVerLvlBBTestMain.c
++
++Abstract:
++
++  Test driver for SBBR system environment configuration tests.
++
++--*/
++
++#include "SctLib.h"
++#include "EfiSpecVerLvlBBTestFunction.h"
++#include "EfiSpecVerLvlBBTestMain.h"
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  EFISPECVERLVL_TEST_REVISION,
++  EFISPECVERLVL_TEST_GUID,
++  L"SBBR UEFI Specification Version Level Test",
++  L"Check the UEFI Specification Version Level to make sure it conforms to ARM SBBR."
++};
++
++EFI_GUID gSupportProtocolGuid[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    EFISPECVERLVL_GUID,
++    L"TestEfiSpecVerLvl",
++    L"Check the EFI Specification Version Level.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestEfiSpecVerLvlTest
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/** The driver's Unload function.
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was uninstalled
++*/
++EFI_STATUS
++BBTestEfiSpecVerLvlUnload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++           ImageHandle,
++           gBBTestProtocolInterface
++           );
++}
++
++/** Creates/installs the BlackBox Interface and emanating Entry Point node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTestEfiSpecVerLvl (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++           &ImageHandle,
++           &gBBTestProtocolField,
++           gBBTestEntryField,
++           BBTestEfiSpecVerLvlUnload,
++           &gBBTestProtocolInterface
++           );
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestMain.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestMain.h
+new file mode 100644
+index 0000000..49fd7bb
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTestMain.h
+@@ -0,0 +1,84 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  EfiSpecVerLvlBBTestMain.h
++
++Abstract:
++
++  Contains definitions for test information and test GUIDs.
++
++--*/
++
++#ifndef _EFISPECVERLVL_TEST_MAIN_H_
++#define _EFISPECVERLVL_TEST_MAIN_H_
++
++#include "Efi.h"
++#include <Library/EfiTestLib.h>
++
++
++#define EFISPECVERLVL_TEST_REVISION 0x00010000
++
++#define EFISPECVERLVL_TEST_GUID     \
++  {0xd6e40d12, 0x7a51, 0x4454, {0xb4, 0xfd, 0x4c, 0x93, 0x88, 0x7e, 0xd6, 0xcf}}
++
++EFI_STATUS
++InitializeBBTestEfiSpecVerLvl (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++//
++// Entry GUIDs
++//
++
++#define EFISPECVERLVL_GUID \
++  {0x6e46b2e2, 0x2535, 0x4c8e, {0x82, 0x5a, 0x84, 0x5d, 0xc2, 0xbe, 0xed, 0xdf}}
++
++
++#endif /* _EFISPECVERLVL_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/Guid.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/Guid.c
+new file mode 100644
+index 0000000..52c6d90
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/Guid.c
+@@ -0,0 +1,61 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  GUID assignments for test progress assertions.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID gEfiSpecVerLvlAssertion01Guid = EFISPECVERLVL_ASSERTION_001_GUID;
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/Guid.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/Guid.h
+new file mode 100644
+index 0000000..b554961
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/Guid.h
+@@ -0,0 +1,66 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  Definitions of GUIDs used for test progress assertions.
++
++--*/
++
++#ifndef _EFISPECVERSION_GUID_H_
++#define _EFISPECVERSION_GUID_H_
++
++#define EFISPECVERLVL_ASSERTION_001_GUID \
++{0x14932290, 0x563b, 0x4d20, {0x95, 0xa7, 0xee, 0xc0, 0x2d, 0xbb, 0x1b, 0x13}}
++
++extern EFI_GUID gEfiSpecVerLvlAssertion01Guid;
++
++#endif /* _EFISPECVERSION_GUID_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/Guid.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/Guid.c
+new file mode 100644
+index 0000000..1886989
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/Guid.c
+@@ -0,0 +1,61 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  Global variable assignments for GUIDs used in test assertions.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID gRequiredUefiProtocolsAssertion001Guid = REQUIREDUEFIPROTOCOLS_ASSERTION_001_GUID;
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/Guid.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/Guid.h
+new file mode 100644
+index 0000000..121ad19
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/Guid.h
+@@ -0,0 +1,66 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  Definitions for GUIDs used in test assertions.
++
++--*/
++
++#ifndef _REQUIREDUEFIPROTOCOLS_GUID_H_
++#define _REQUIREDUEFIPROTOCOLS_GUID_H_
++
++#define REQUIREDUEFIPROTOCOLS_ASSERTION_001_GUID \
++{ 0x6092f275, 0x19ca, 0x413a, {0xac, 0xc8, 0x60, 0xd6, 0xe0, 0xca, 0x70, 0x54 }}
++
++extern EFI_GUID gRequiredUefiProtocolsAssertion001Guid;
++
++#endif /* _REQUIREDUEFIPROTOCOLS_GUID_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTest.inf b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTest.inf
+new file mode 100644
+index 0000000..674aba0
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTest.inf
+@@ -0,0 +1,81 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2016, ARM Corporation. All rights reserved.
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   RequiredUefiProtocolsBBTest.inf
++#
++# Abstract:
++#
++#   Component description file for RequiredUefiProtocols tests.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010005
++  BASE_NAME            = RequiredUefiProtocolsBBTest
++  FILE_GUID            = acc875f3-9c75-4392-9b95-fcb97d48890e
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTestRequiredUefiProtocols
++
++[Sources.common]
++  RequiredUefiProtocolsBBTestMain.c
++  RequiredUefiProtocolsBBTestFunction.c
++  Guid.c
++
++[Packages]
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  UefiDriverEntryPoint
++  SctLib
++  EfiTestLib
++
++[Protocols]
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestFunction.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestFunction.c
+new file mode 100644
+index 0000000..6b149ee
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestFunction.c
+@@ -0,0 +1,149 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  RequiredUefiProtocolsBBTestFunction.c
++
++Abstract:
++
++  Test case function definitions for RequiredUefiProtocols.
++
++--*/
++
++#include "RequiredUefiProtocolsBBTestMain.h"
++#include "RequiredUefiProtocolsBBTestFunction.h"
++#include "SctLib.h"
++#include "Guid.h"
++
++/**
++ *  Entrypoint for MediaIoProtocols Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTestMediaIoProtocolsTest (
++  IN EFI_BB_TEST_PROTOCOL             *This,
++  IN VOID                             *ClientInterface,
++  IN EFI_TEST_LEVEL                   TestLevel,
++  IN EFI_HANDLE                       SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  EFI_TEST_ASSERTION                  AssertionType;
++  EFI_HANDLE                          *HandleBuffer;
++  UINTN                               NumberOfHandles;
++  SBBR_REQUIRED_PROTOCOL             Protocol[] = {
++                                        {EFI_LOAD_FILE_PROTOCOL_GUID, L"EFI_LOAD_FILE_PROTOCOL"},
++                                        {EFI_LOAD_FILE2_PROTOCOL_GUID, L"EFI_LOAD_FILE2_PROTOCOL"},
++                                        {gEfiNullGuid, 0}
++                                      };
++  UINT32                              i;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Looking for Protocols
++  //
++  i = 0;
++  while (SctCompareGuid (&Protocol[i].guid, &gEfiNullGuid) != 0){
++    Status = gBS->LocateHandleBuffer (
++                ByProtocol,
++                &Protocol[i].guid,
++                NULL,
++                &NumberOfHandles,
++                &HandleBuffer
++                );
++
++    if ((Status == EFI_NOT_FOUND) && (NumberOfHandles == 0)){
++      // Protocol not found
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gRequiredUefiProtocolsAssertion001Guid,
++                  L"MediaIoProtocols",
++                  L"%a:%d:%s Not Found",
++                  __FILE__,
++                  __LINE__,
++                  Protocol[i].name
++                  );
++    }
++    else {
++      // Protocol found
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_PASSED,
++                  gRequiredUefiProtocolsAssertion001Guid,
++                  L"MediaIoProtocols",
++                  L"%a:%d:%s Found",
++                  __FILE__,
++                  __LINE__,
++                  Protocol[i].name
++                  );
++    }
++
++    i++;
++  }
++
++  return EFI_SUCCESS;
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestFunction.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestFunction.h
+new file mode 100644
+index 0000000..15009c9
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestFunction.h
+@@ -0,0 +1,86 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  RequiredUefiProtocolsBBTestFunction.h
++
++Abstract:
++
++  Contains definitions and prototypes for test case functions.
++
++--*/
++
++#ifndef _REQUIREDUEFIPROTOCOLS_BB_TEST_FUNCTION_H_
++#define _REQUIREDUEFIPROTOCOLS_BB_TEST_FUNCTION_H_
++
++/*
++ * GUIDs of protocols we're looking for are here as to avoid
++ * compilation errors in the case that they do not exist in the
++ * system.
++ */
++
++#define EFI_LOAD_FILE_PROTOCOL_GUID \
++{0x56EC3091, 0x954C, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B}}
++
++#define EFI_LOAD_FILE2_PROTOCOL_GUID \
++{0x4006C0C1, 0xFCB3, 0x403E, {0x99, 0x6D, 0x4A, 0x6C, 0x87, 0x24, 0xE0, 0x6D}}
++
++typedef struct {
++  EFI_GUID guid;
++  UINT16 *name;
++} SBBR_REQUIRED_PROTOCOL;
++
++EFI_STATUS
++BBTestMediaIoProtocolsTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _REQUIREDUEFIPROTOCOLS_BB_TEST_FUNCTION_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestMain.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestMain.c
+new file mode 100644
+index 0000000..72056e0
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestMain.c
+@@ -0,0 +1,130 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  RequiredUefiProtocolsBBTestMain.c
++
++Abstract:
++
++  Test driver for RequiredUefiProtocols tests.
++
++--*/
++
++#include "SctLib.h"
++#include "RequiredUefiProtocolsBBTestMain.h"
++#include "RequiredUefiProtocolsBBTestFunction.h"
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  REQUIREDUEFIPROTOCOLS_TEST_REVISION,
++  REQUIREDUEFIPROTOCOLS_TEST_GUID,
++  L"RequiredUefiProtocols Tests",
++  L"Checks that UEFI protocols required by ARM SBBR are present."
++};
++
++EFI_GUID gSupportProtocolGuid[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    REQUIREDUEFIPROTOCOLS_MEDIAIOPROTOCOLS_GUID,
++    L"MediaIoProtocols",
++    L"Checks to make sure various media IO protocols are supported.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestMediaIoProtocolsTest
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/**
++ *  The driver's Unload function
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was Uninstalled
++*/
++EFI_STATUS
++BBTestRequiredUefiProtocolsUnload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++           ImageHandle,
++           gBBTestProtocolInterface
++           );
++}
++
++/**
++ *  Creates/installs the BlackBox Interface and eminating Entry Point
++ *  node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER: One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTestRequiredUefiProtocols (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++           &ImageHandle,
++           &gBBTestProtocolField,
++           gBBTestEntryField,
++           BBTestRequiredUefiProtocolsUnload,
++           &gBBTestProtocolInterface
++           );
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestMain.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestMain.h
+new file mode 100644
+index 0000000..26e591c
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTestMain.h
+@@ -0,0 +1,88 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  RequiredUefiProtocolsBBTestMain.h
++
++Abstract:
++
++  Contains definitions for test information and test GUIDs.
++
++--*/
++
++#ifndef _REQUIREDUEFIPROTOCOLS_TEST_MAIN_H_
++#define _REQUIREDUEFIPROTOCOLS_TEST_MAIN_H_
++
++#include "Efi.h"
++#include "Guid.h"
++#include <Library/EfiTestLib.h>
++
++#define REQUIREDUEFIPROTOCOLS_TEST_REVISION 0x00010000
++
++#define REQUIREDUEFIPROTOCOLS_TEST_GUID \
++{ 0x6b4d5d18, 0xf55f, 0x4fc5, {0x84, 0x96, 0xf1, 0x00, 0x22, 0x37, 0x5c, 0x04 }}
++
++EFI_STATUS
++InitializeBBTestRequiredUefiProtocols (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++EFI_STATUS
++BBTestBootRequiredUefiProtocols (
++  IN EFI_HANDLE       ImageHandle
++  );
++
++//
++// Entry GUIDs
++//
++
++#define REQUIREDUEFIPROTOCOLS_MEDIAIOPROTOCOLS_GUID \
++{ 0x24d52c4c, 0xafeb, 0x49ea, {0xa7, 0x77, 0x8f, 0xe1, 0x9f, 0x32, 0x20, 0x66 }}
++
++#endif /* _REQUIREDUEFIPROTOCOLS_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/Guid.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/Guid.c
+new file mode 100644
+index 0000000..5a685f6
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/Guid.c
+@@ -0,0 +1,61 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM LTD. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  Global variable assignments for GUIDs used in test assertions.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID gSbbrSmbiosAssertion001Guid = SBBRSMBIOS_ASSERTION_001_GUID;
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/Guid.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/Guid.h
+new file mode 100644
+index 0000000..967be4d
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/Guid.h
+@@ -0,0 +1,66 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM LTD. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  Definitions for GUIDs used in test assertions.
++
++--*/
++
++#ifndef _SBBRSMBIOS_GUID_H_
++#define _SBBRSMBIOS_GUID_H_
++
++#define SBBRSMBIOS_ASSERTION_001_GUID \
++  { 0xed2399ae, 0x416e, 0x46c6, {0xac, 0xa2, 0xd9, 0xb1, 0xcf, 0x99, 0x75, 0xcd }}
++
++extern EFI_GUID gSbbrSmbiosAssertion001Guid;
++
++#endif /* _SBBRSMBIOS_GUID_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTest.inf b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTest.inf
+new file mode 100644
+index 0000000..91c013f
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTest.inf
+@@ -0,0 +1,84 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2016, ARM LTD. All rights reserved.
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   SbbrSmbiosBBTest.inf
++#
++# Abstract:
++#
++#   Component description file for SbbrSmbios tests.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010019
++  BASE_NAME            = SbbrSmbiosBBTest
++  FILE_GUID            = 04a5d449-9c54-4937-8b83-142103adb759
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTestSbbrSmbios
++
++[Sources.common]
++  Guid.c
++  SbbrSmbiosBBTestFunction.c
++  SbbrSmbiosBBTestMain.c
++
++[Packages]
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  EfiTestLib
++  SctLib
++  UefiDriverEntryPoint
++
++[Protocols]
++
++[Guids]
++  gEfiSmbios3TableGuid
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestFunction.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestFunction.c
+new file mode 100644
+index 0000000..7dca5ef
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestFunction.c
+@@ -0,0 +1,222 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM LTD. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrSmbiosBBTestFunction.c
++
++Abstract:
++
++  Test case function definitions for SbbrSmbios.
++
++--*/
++
++#include "SbbrSmbiosBBTestMain.h"
++#include "SbbrSmbiosBBTestFunction.h"
++#include "SctLib.h"
++#include "Guid.h"
++#include <IndustryStandard/SmBios.h>
++#include <Library/EfiTestLib.h>
++
++/**
++ *  Entrypoint for UefiSmbios Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTestUefiSmbiosTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  SMBIOS_TABLE_3_0_ENTRY_POINT        *SmbiosTable;
++  UINTN                               MemoryMapSize;
++  VOID                                *MemoryMap;
++  EFI_MEMORY_DESCRIPTOR               *MemoryMapDescriptor;
++  UINTN                               MapKey;
++  UINTN                               DescriptorSize;
++  UINT32                              DescriptorVersion;
++  UINT32                              i;
++  UINT64                              EndAddress;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++                   SupportHandle,
++                   &gEfiStandardTestLibraryGuid,
++                   (VOID **) &StandardLib
++                   );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Looking for SMBIOS table
++  //
++  Status = SctGetSystemConfigurationTable (
++              &gEfiSmbios3TableGuid,
++              (VOID **)&SmbiosTable
++              );
++  if (EFI_ERROR(Status)) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrSmbiosAssertion001Guid,
++                L"UefiSmbios",
++                L"%a:%d - SMBIOS30 Table Not Found",
++                __FILE__,
++                __LINE__
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Checking SMBIOS table version
++  //
++  if (SmbiosTable->MajorVersion != SBBRSMBIOS_MAJOR_VERSION) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSbbrSmbiosAssertion001Guid,
++                L"UefiSmbios",
++                L"%a:%d - SMBIOS30 table invalid version. %d",
++                __FILE__,
++                __LINE__,
++                SmbiosTable->MajorVersion
++                );
++    return EFI_SUCCESS;
++  }
++
++  //
++  // Getting Memory Map
++  //
++  Status = SbbrAllocAndGetMemoryMap (
++              &MemoryMapSize,
++              &MemoryMap,
++              &MapKey,
++              &DescriptorSize,
++              &DescriptorVersion
++              );
++  if (EFI_ERROR (Status)) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gTestGenericFailureGuid,
++                L"MemoryMap",
++                L"%a:%d - Could not retrieve memory map. 0x%X",
++                __FILE__,
++                __LINE__,
++                Status
++                );
++    return EFI_NOT_FOUND;
++  }
++
++  //
++  // Looping through memory map descriptors to find the one containing SMBIOS table
++  //
++  for (i = 0; i < MemoryMapSize / DescriptorSize; i++) {
++    MemoryMapDescriptor = (EFI_MEMORY_DESCRIPTOR *)(MemoryMap + (i * DescriptorSize));
++    EndAddress = MemoryMapDescriptor->PhysicalStart + (MemoryMapDescriptor->NumberOfPages * EFI_PAGE_SIZE);
++    if ( (SmbiosTable->TableAddress >= MemoryMapDescriptor->PhysicalStart) &&
++         ((SmbiosTable->TableAddress + SmbiosTable->TableMaximumSize) < EndAddress))
++    {
++      //
++      // Memory region containing SMBIOS table found
++      //
++      if (MemoryMapDescriptor->Type != EfiRuntimeServicesData) {
++        StandardLib->RecordAssertion (
++                    StandardLib,
++                    EFI_TEST_ASSERTION_FAILED,
++                    gSbbrSmbiosAssertion001Guid,
++                    L"UefiSmbios",
++                    L"%a:%d - Wrong SMBIOS30 Memory Type. 0x%X",
++                    __FILE__,
++                    __LINE__,
++                    MemoryMapDescriptor->Type
++                    );
++      } else {
++        StandardLib->RecordAssertion (
++                    StandardLib,
++                    EFI_TEST_ASSERTION_PASSED,
++                    gSbbrSmbiosAssertion001Guid,
++                    L"UefiSmbios",
++                    L"%a:%d",
++                    __FILE__,
++                    __LINE__
++                    );
++      }
++
++      SctFreePool(MemoryMap);
++      return EFI_SUCCESS;
++    }
++
++  }
++
++  //
++  // Memory region not found.
++  //
++  StandardLib->RecordAssertion (
++              StandardLib,
++              EFI_TEST_ASSERTION_FAILED,
++              gSbbrSmbiosAssertion001Guid,
++              L"UefiSmbios",
++              L"%a:%d - Memory region not found in map.",
++              __FILE__,
++              __LINE__
++              );
++  SctFreePool(MemoryMap);
++  return EFI_SUCCESS;
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestFunction.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestFunction.h
+new file mode 100644
+index 0000000..1de882c
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestFunction.h
+@@ -0,0 +1,69 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM LTD. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrSmbiosBBTestFunction.h
++
++Abstract:
++
++  Contains definitions and prototypes for test case functions.
++
++--*/
++
++#ifndef _SBBRSMBIOS_BB_TEST_FUNCTION_H_
++#define _SBBRSMBIOS_BB_TEST_FUNCTION_H_
++
++EFI_STATUS
++BBTestUefiSmbiosTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _SBBRSMBIOS_BB_TEST_FUNCTION_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestMain.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestMain.c
+new file mode 100644
+index 0000000..d6ff5a0
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestMain.c
+@@ -0,0 +1,181 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM LTD. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrSmbiosBBTestMain.c
++
++Abstract:
++
++  Test driver for SbbrSmbios tests.
++
++--*/
++
++#include "SctLib.h"
++#include "SbbrSmbiosBBTestMain.h"
++#include "SbbrSmbiosBBTestFunction.h"
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  SBBRSMBIOS_TEST_REVISION,
++  SBBRSMBIOS_TEST_GUID,
++  L"SbbrSmbios Tests",
++  L"Checks that SMBIOS on UEFI is implemented correctly."
++};
++
++EFI_GUID gSupportProtocolGuid1[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    SBBRSMBIOS_UEFISMBIOS_GUID,
++    L"UefiSmbios",
++    L"Checks that the SMBIOS3 table is accessible though its GUID and that it has the correct memory region settings.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid1,
++    EFI_TEST_CASE_AUTO,
++    BBTestUefiSmbiosTest
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/**
++ *  The driver's Unload function
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was Uninstalled
++*/
++EFI_STATUS
++BBTestSbbrSmbiosUnload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++              ImageHandle,
++              gBBTestProtocolInterface
++           );
++}
++
++/**
++ *  Creates/installs the BlackBox Interface and eminating Entry Point
++ *  node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER: One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTestSbbrSmbios (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++  SctInitializeLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++              &ImageHandle,
++              &gBBTestProtocolField,
++              gBBTestEntryField,
++              BBTestSbbrSmbiosUnload,
++              &gBBTestProtocolInterface
++              );
++}
++
++/**
++ * SbbrGetMemoryMap function used by test cases.
++ */
++EFI_STATUS
++SbbrAllocAndGetMemoryMap (
++  UINTN                               *MemoryMapSize,
++  VOID                                **MemoryMap,
++  UINTN                               *MapKey,
++  UINTN                               *DescriptorSize,
++  UINT32                              *DescriptorVersion
++  )
++{
++  EFI_STATUS                          Status;
++
++  //
++  // Getting memory map
++  //
++  do {
++    *MemoryMapSize = 0;
++    // First call with a size of 0 so we can find out how big the memory map is.
++    Status = gtBS->GetMemoryMap (
++                MemoryMapSize,
++                *MemoryMap,
++                MapKey,
++                DescriptorSize,
++                DescriptorVersion
++                );
++    if (Status != EFI_BUFFER_TOO_SMALL){
++      return EFI_NOT_FOUND;
++    }
++    *MemoryMap = SctAllocatePool(*MemoryMapSize);
++    if (*MemoryMap == NULL) {
++      return EFI_OUT_OF_RESOURCES;
++    }
++    // Second call with our newly allocated buffer should work properly.
++    Status = gtBS->GetMemoryMap (
++                MemoryMapSize,
++                *MemoryMap,
++                MapKey,
++                DescriptorSize,
++                DescriptorVersion
++                );
++    if (EFI_ERROR (Status)) {
++      SctFreePool(*MemoryMap);
++    }
++  } while (EFI_ERROR (Status));
++
++  return EFI_SUCCESS;
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestMain.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestMain.h
+new file mode 100644
+index 0000000..8884bdd
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTestMain.h
+@@ -0,0 +1,90 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM LTD. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  SbbrSmbiosBBTestMain.h
++
++Abstract:
++
++  Contains definitions for test information and test GUIDs.
++
++--*/
++
++#ifndef _SBBRSMBIOS_TEST_MAIN_H_
++#define _SBBRSMBIOS_TEST_MAIN_H_
++
++#include "Efi.h"
++#include "Guid.h"
++#include <Library/EfiTestLib.h>
++
++#define SBBRSMBIOS_TEST_REVISION 0x00010000
++
++#define SBBRSMBIOS_TEST_GUID     \
++  { 0x852e92eb, 0xd7aa, 0x4d61, {0x84, 0xef, 0xd3, 0x2d, 0xc5, 0xd5, 0x45, 0xec }}
++
++#define SBBRSMBIOS_MAJOR_VERSION 3
++
++EFI_STATUS
++InitializeBBTestSbbrSmbios (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++EFI_STATUS
++BBTestSbbrSmbiosUnload (
++  IN EFI_HANDLE       ImageHandle
++  );
++
++//
++// Entry GUIDs
++//
++
++#define SBBRSMBIOS_UEFISMBIOS_GUID \
++  { 0x71b32221, 0x8b9d, 0x4b41, {0x8b, 0x04, 0xee, 0x6d, 0x18, 0xa6, 0xe5, 0x25 }}
++
++#endif /* _SBBRSMBIOS_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/Guid.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/Guid.c
+new file mode 100644
+index 0000000..cd6a752
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/Guid.c
+@@ -0,0 +1,67 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  GUID assignments for test progress assertions.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID gSysEnvConfigAssertion001Guid = SYSENVCONFIG_ASSERTION_001_GUID;
++
++EFI_GUID gSysEnvConfigAssertion002Guid = SYSENVCONFIG_ASSERTION_002_GUID;
++
++EFI_GUID gSysEnvConfigAssertion003Guid = SYSENVCONFIG_ASSERTION_003_GUID;
++
++EFI_GUID gSysEnvConfigAssertion004Guid = SYSENVCONFIG_ASSERTION_004_GUID;
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/Guid.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/Guid.h
+new file mode 100644
+index 0000000..8f474c4
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/Guid.h
+@@ -0,0 +1,81 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  Definitions of GUIDs used for test progress assertions.
++
++--*/
++
++#ifndef _SYSENVCONFIG_GUID_H_
++#define _SYSENVCONFIG_GUID_H_
++
++#define SYSENVCONFIG_ASSERTION_001_GUID \
++{0xcc5c4f70, 0xbfc9, 0x48be, {0x97, 0xf8, 0xca, 0xac, 0xfd, 0x8b, 0x97, 0x5e}}
++
++extern EFI_GUID gSysEnvConfigAssertion001Guid;
++
++#define SYSENVCONFIG_ASSERTION_002_GUID \
++{0x6e3f022e, 0x425b, 0x42cd, {0x83, 0x07, 0xb5, 0x67, 0xb9, 0xdb, 0x3d, 0x5d}}
++
++extern EFI_GUID gSysEnvConfigAssertion002Guid;
++
++#define SYSENVCONFIG_ASSERTION_003_GUID \
++{0x91d5b963, 0x1da8, 0x4c1d, {0x91, 0x3e, 0xd3, 0x4b, 0xb3, 0xa7, 0x3a, 0x1c}}
++
++extern EFI_GUID gSysEnvConfigAssertion003Guid;
++
++#define SYSENVCONFIG_ASSERTION_004_GUID \
++{0x9f0b093e, 0x7606, 0x4c94, {0xa1, 0xaa, 0x85, 0x56, 0x7f, 0xd4, 0xbf, 0x15}}
++
++extern EFI_GUID gSysEnvConfigAssertion004Guid;
++
++#endif /* _SYSENVCONFIG_GUID_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTest.inf b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTest.inf
+new file mode 100644
+index 0000000..d4d610c
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTest.inf
+@@ -0,0 +1,84 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2016, ARM. All rights reserved.<BR>
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   SysEnvConfigBBTest.inf
++#
++# Abstract:
++#
++#   Component description file for SBBR system environment configuration tests.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010005
++  BASE_NAME            = SysEnvConfigBBTest
++  FILE_GUID            = 96251323-e34e-484b-b60c-6c66de30ccd6
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTestSysEnvConfig
++
++[Sources.common]
++  Guid.c
++  SysEnvConfigBBTestFunction.c
++  SysEnvConfigBBTestMain.c
++
++[Packages]
++  ArmPkg/ArmPkg.dec
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  ArmLib
++  EfiTestLib
++  SctLib
++  UefiDriverEntryPoint
++
++[Protocols]
++  gBlackBoxEfiBlockIoProtocolGuid
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestFunction.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestFunction.c
+new file mode 100644
+index 0000000..d0dba1e
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestFunction.c
+@@ -0,0 +1,527 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2006, ARM. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SysEnvConfigBBTestFunction.c
++
++Abstract:
++
++  Test case definitions for SysEnvConfig tests.
++
++--*/
++
++#include <Chipset/AArch64.h>
++#include "Guid.h"
++#include <Library/ArmLib.h>
++#include "SctLib.h"
++#include "SysEnvConfigBBTestFunction.h"
++#include "SysEnvConfigBBTestMain.h"
++#include <UEFI/Protocol/BlockIo.h>
++#include <UEFI/Protocol/Ebc.h>
++#include <Uefi/UefiGpt.h>
++#include <Uefi/UefiMultiPhase.h>
++
++/**
++ *  Entrypoint for Boot Exception Level Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++//
++// SBBR 3.3.1
++//
++
++EFI_STATUS
++BBTestBootExcLevelTest (
++  IN EFI_BB_TEST_PROTOCOL               *This,
++  IN VOID                               *ClientInterface,
++  IN EFI_TEST_LEVEL                     TestLevel,
++  IN EFI_HANDLE                         SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL    *StandardLib;
++  EFI_STATUS                            Status;
++  EFI_TEST_ASSERTION                    AssertionType;
++  UINTN                                 CurrentEL;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Reading CurrentEL register into ExceptionLevel register variable and checking its value.
++  //
++  CurrentEL = ArmReadCurrentEL();
++
++  switch(CurrentEL){
++    case AARCH64_EL1:
++      AssertionType = EFI_TEST_ASSERTION_PASSED;
++      break;
++    case AARCH64_EL2:
++      AssertionType = EFI_TEST_ASSERTION_PASSED;
++      break;
++    case AARCH64_EL3:
++      AssertionType = EFI_TEST_ASSERTION_FAILED;
++      break;
++    default:
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"Unrecognized CurrentEL Value",
++                  L"%a:%d:CurrentEL=0x%X",
++                  __FILE__,
++                  (UINTN)__LINE__,
++                  CurrentEL
++                  );
++      return EFI_UNSUPPORTED;
++  }
++
++  StandardLib->RecordAssertion (
++              StandardLib,
++              AssertionType,
++              gSysEnvConfigAssertion001Guid,
++              L"TestBootExcLevel",
++              L"%a:%d:CurrentEL=0x%X",
++              __FILE__,
++              __LINE__,
++              CurrentEL
++              );
++
++  return EFI_SUCCESS;
++}
++
++/**
++ *  Entrypoint for Memory Address Alignment Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++//
++// SBBR 3.3.2
++//
++
++EFI_STATUS
++BBTestMemAddrAlignmentTest (
++  IN EFI_BB_TEST_PROTOCOL               *This,
++  IN VOID                               *ClientInterface,
++  IN EFI_TEST_LEVEL                     TestLevel,
++  IN EFI_HANDLE                         SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL    *StandardLib;
++  EFI_STATUS                            Status;
++  EFI_TEST_ASSERTION                    AssertionType;
++  UINT32                                Sctlr;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Reading SCTLR for current exception level
++  //
++  Sctlr = ArmReadSctlr();
++
++  if (Sctlr & SCTLR_A_MASK)
++  {
++    AssertionType = EFI_TEST_ASSERTION_FAILED;
++  }
++  else
++  {
++    AssertionType = EFI_TEST_ASSERTION_PASSED;
++  }
++
++  StandardLib->RecordAssertion (
++              StandardLib,
++              AssertionType,
++              gSysEnvConfigAssertion002Guid,
++              L"TestMemAddrAlignment",
++              L"%a:%d:SCTLR.A=%d",
++              __FILE__,
++              __LINE__,
++              (Sctlr & SCTLR_A_MASK) >> SCTLR_A_SHIFT
++              );
++
++  return EFI_SUCCESS;
++}
++
++/**
++ *  Entrypoint for Operating System Boot Disk Partition Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++//
++// SBBR 3.3.3
++//
++
++EFI_STATUS
++BBTestOsDiskFormatTest (
++  IN EFI_BB_TEST_PROTOCOL               *This,
++  IN VOID                               *ClientInterface,
++  IN EFI_TEST_LEVEL                     TestLevel,
++  IN EFI_HANDLE                         SupportHandle
++  )
++{
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL    *StandardLib;
++  EFI_STATUS                            Status;
++  EFI_TEST_ASSERTION                    AssertionType;
++  INTN                                  iStatus;
++  UINTN                                 NumberOfHandles;
++  EFI_HANDLE                            *HandleBuffer;
++  EFI_BLOCK_IO_PROTOCOL                 *BlockIo;
++  UINT8                                 *BlockBuffer;
++  EFI_GUID                              PartitionTypeGuid;
++  UINT32                                GptPartitionsInThisLbaCount;
++  EFI_LBA                               PartitionEntryLba;
++  UINT32                                NumberOfPartitionEntries;
++  UINT32                                SizeOfPartitionEntry;
++  UINT32                                PartitionEntriesPerLba;
++  UINT32                                HandleCount;
++  UINT32                                GptPartitionEntryCount;
++  EFI_PARTITION_TABLE_HEADER            *GptTableHeader;
++  EFI_PARTITION_ENTRY                   *GptPartitionEntry;
++  UINT8                                 GptSignature[] = GPT_SIGNATURE;
++  EFI_GUID                              GptEfiPartitionGuid = GPT_EFI_PARTITION_GUID;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Get list of all handles that support BlockIO.
++  //
++  Status = gBS->LocateHandleBuffer (
++              ByProtocol,
++              &gBlackBoxEfiBlockIoProtocolGuid,
++              NULL,
++              &NumberOfHandles,
++              &HandleBuffer
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Checking each disk device to see if it is bootable
++  //
++  HandleCount = 0;
++  while (HandleCount < NumberOfHandles) {
++
++    //
++    // Creating BlockIo device for one of the handles we found.
++    //
++    Status = gBS->OpenProtocol (
++                HandleBuffer[HandleCount],
++                &gBlackBoxEfiBlockIoProtocolGuid,
++                (void *)&BlockIo,
++                gImageHandle,
++                NULL,
++                EFI_OPEN_PROTOCOL_GET_PROTOCOL
++                );
++    if (EFI_ERROR (Status)) {
++      return Status;
++    }
++
++    //
++    // Allocating memory to read data into
++    //
++    Status = gBS->AllocatePool (
++                EfiBootServicesData,
++                BlockIo->Media->BlockSize,
++                (void **)&BlockBuffer
++                );
++    if (EFI_ERROR (Status)) {
++      return Status;
++    }
++
++    //
++    // Reading block that should contain GPT header.
++    //
++    Status = BlockIo->ReadBlocks (
++                BlockIo,
++                BlockIo->Media->MediaId,
++                GPT_HEADER_LBA,
++                BlockIo->Media->BlockSize,
++                (VOID*)BlockBuffer
++                );
++    if (EFI_ERROR (Status)) {
++      return Status;
++    }
++
++    //
++    // Checking if block is a GPT header.
++    //
++    GptTableHeader = (EFI_PARTITION_TABLE_HEADER *)BlockBuffer;
++    iStatus = SctCompareMem (
++                (void *)&GptTableHeader->Header.Signature,
++                (void *)GptSignature,
++                GPT_SIGNATURE_SIZE
++                );
++    if (iStatus == 0) {
++
++      //
++      // Block contains a GPT header, so now we need to find an EFI partition.
++      //
++      PartitionEntryLba = GptTableHeader->PartitionEntryLBA;
++      NumberOfPartitionEntries = GptTableHeader->NumberOfPartitionEntries;
++      SizeOfPartitionEntry = GptTableHeader->SizeOfPartitionEntry;
++
++      //
++      // Loops through LBAs until all partition entries have been searched.
++      //
++      GptPartitionEntryCount = 0;
++      PartitionEntriesPerLba = BlockIo->Media->BlockSize / SizeOfPartitionEntry;
++      while (GptPartitionEntryCount < NumberOfPartitionEntries) {
++
++        //
++        // Reading LBA of partition entry.
++        //
++        Status = BlockIo->ReadBlocks (
++                    BlockIo,
++                    BlockIo->Media->MediaId,
++                    PartitionEntryLba,
++                    BlockIo->Media->BlockSize,
++                    (VOID *)BlockBuffer
++                    );
++        if (EFI_ERROR (Status)) {
++          return Status;
++        }
++
++        //
++        // Loops through partition entries in a single LBA
++        //
++        GptPartitionsInThisLbaCount = 0;
++        while ( (GptPartitionsInThisLbaCount < PartitionEntriesPerLba) \
++                && (GptPartitionEntryCount < NumberOfPartitionEntries) \
++                ) {
++
++          GptPartitionEntry = (EFI_PARTITION_ENTRY *)&BlockBuffer[(GptPartitionEntryCount % PartitionEntriesPerLba) * SizeOfPartitionEntry];
++
++          //
++          // Checking partition type GUID against EFI partition type GUID.
++          //
++          CopyGuid (
++                      &PartitionTypeGuid,
++                      &GptPartitionEntry->PartitionTypeGUID
++                      );
++
++          iStatus = SctCompareGuid (
++                      (void *)&PartitionTypeGuid,
++                      (void *)&GptEfiPartitionGuid
++                      );
++          if (iStatus == 0) {
++            StandardLib->RecordAssertion (
++                        StandardLib,
++                        EFI_TEST_ASSERTION_PASSED,
++                        gSysEnvConfigAssertion003Guid,
++                        L"TestOsDiskFormat",
++                        L"%a:%d:Valid Boot Disk Found",
++                        __FILE__,
++                        (UINTN)__LINE__
++                        );
++            gBS->FreePool ((void *)BlockBuffer);
++            Status = gBS->CloseProtocol (
++                        HandleBuffer[HandleCount],
++                        &gBlackBoxEfiBlockIoProtocolGuid,
++                        gImageHandle,
++                        NULL
++                        );
++            return EFI_SUCCESS;
++          }
++
++          GptPartitionEntryCount++;
++          GptPartitionsInThisLbaCount++;
++        }
++
++        PartitionEntryLba++;
++      }
++    }
++
++    gBS->FreePool ((void *)BlockBuffer);
++
++    //
++    // Closing the protocol
++    //
++    Status = gBS->CloseProtocol (
++                HandleBuffer[HandleCount],
++                &gBlackBoxEfiBlockIoProtocolGuid,
++                gImageHandle,
++                NULL
++                );
++
++    HandleCount++;
++  }
++
++  StandardLib->RecordAssertion (
++              StandardLib,
++              EFI_TEST_ASSERTION_FAILED,
++              gSysEnvConfigAssertion003Guid,
++              L"TestOsDiskFormat",
++              L"%a:%d:No Valid Boot Disk Found",
++              __FILE__,
++              (UINTN)__LINE__
++              );
++
++  return EFI_SUCCESS;
++}
++
++/**
++ *  Entrypoint for EBC interface check.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++//
++// SBBR 3.3.4
++//
++
++EFI_STATUS
++BBTestEbcInterfacePresentTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  EFI_HANDLE                          *HandleBuffer;
++  UINTN                               NumberOfHandles;
++  EFI_GUID                            EbcProtocolGuid = EFI_EBC_PROTOCOL_GUID;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Attempting to locate EBC protocol
++  //
++  Status = gBS->LocateHandleBuffer (
++              ByProtocol,
++              &EbcProtocolGuid,
++              NULL,
++              &NumberOfHandles,
++              &HandleBuffer
++              );
++  if ( (Status == EFI_NOT_FOUND) && (NumberOfHandles == 0) ) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gSysEnvConfigAssertion004Guid,
++                L"SBBRTestEbcInterfacePresent",
++                L"%a:%d:EBC Interpreter Not Found",
++                __FILE__,
++                (UINTN)__LINE__
++                );
++  }
++  else if( (Status == EFI_SUCCESS) && (NumberOfHandles > 0) ) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_PASSED,
++                gSysEnvConfigAssertion004Guid,
++                L"SBBRTestEbcInterfacePresent",
++                L"%a:%d:EBC Interpreter Found",
++                __FILE__,
++                (UINTN)__LINE__
++                );
++  }
++  else {
++    return Status;
++  }
++
++  return EFI_SUCCESS;
++}
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestFunction.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestFunction.h
+new file mode 100644
+index 0000000..b42fae0
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestFunction.h
+@@ -0,0 +1,104 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2006, ARM. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SysEnvConfigBBTestFunction.h
++
++Abstract:
++
++  Contains definitions and prototypes used in the test functions.
++
++--*/
++
++#ifndef _SYSENVCONFIG_BB_TEST_FUNCTION_H_
++#define _SYSENVCONFIG_BB_TEST_FUNCTION_H_
++
++#include <Library/EfiTestLib.h>
++
++#define SCTLR_A_MASK           0x2
++#define SCTLR_A_SHIFT          1
++
++#define GPT_HEADER_LBA         1
++#define GPT_SIGNATURE_SIZE     8
++#define GPT_SIGNATURE          "EFI PART"
++#define GPT_EFI_PARTITION_GUID {0xC12A7328, 0xF81F, 0x11D2, {0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B}}
++#define GPT_STARTING_ENTRY_LBA_OFFSET  72
++
++EFI_STATUS
++BBTestBootExcLevelTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestMemAddrAlignmentTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestOsDiskFormatTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestEbcInterfacePresentTest (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _SYSENVCONFIG_BB_TEST_FUNCTION_H_ */
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestMain.c b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestMain.c
+new file mode 100644
+index 0000000..9ed7cf8
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestMain.c
+@@ -0,0 +1,157 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SysEnvConfigBBTestMain.c
++
++Abstract:
++
++  Test driver for SBBR system environment configuration tests.
++
++--*/
++
++#include "SctLib.h"
++#include "SysEnvConfigBBTestFunction.h"
++#include "SysEnvConfigBBTestMain.h"
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  SYSENVCONFIG_TEST_REVISION,
++  SYSENVCONFIG_TEST_GUID,
++  L"SBBR UEFI System Environment and Configuration Tests",
++  L"Tests various processor configuration parameters to make sure they conform to ARM SBBR."
++};
++
++EFI_GUID gSupportProtocolGuid[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    SYSENVCONFIG_BOOT_EXC_LEVEL_GUID,
++    L"BootExcLevel",
++    L"Check the execution level of the UEFI boot environment.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestBootExcLevelTest
++  },
++  {
++    SYSENVCONFIG_MEM_ADDR_ALIGNMENT_GUID,
++    L"MemAddrAlignment",
++    L"Checking that memory address alignment is not enforced.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestMemAddrAlignmentTest
++  },
++  {
++    SYSENVCONFIG_OS_DISK_FORMAT_GUID,
++    L"OsDiskFormat",
++    L"Checking that the operating system disk contains a GPT partition table with an EFI partition.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestOsDiskFormatTest
++  },
++  {
++    SYSENVCONFIG_EBC_INTERPRETER_PRESENT_GUID,
++    L"EbcInterfacePresent",
++    L"Checking that an EBC interpreter is present in the system.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestEbcInterfacePresentTest
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/**
++ *  The driver's Unload function
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was Uninstalled
++*/
++EFI_STATUS
++BBTestSysEnvConfigUnload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++           ImageHandle,
++           gBBTestProtocolInterface
++           );
++}
++
++/**
++ *  Creates/installs the BlackBox Interface and eminating Entry Point
++ *  node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTestSysEnvConfig (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++           &ImageHandle,
++           &gBBTestProtocolField,
++           gBBTestEntryField,
++           BBTestSysEnvConfigUnload,
++           &gBBTestProtocolInterface
++           );
++}
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestMain.h b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestMain.h
+new file mode 100644
+index 0000000..151444c
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTestMain.h
+@@ -0,0 +1,96 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SysEnvConfigBBTestMain.h
++
++Abstract:
++
++  Contains definitions for test information and test GUIDs.
++
++--*/
++
++#ifndef _SYSENVCONFIG_TEST_MAIN_H_
++#define _SYSENVCONFIG_TEST_MAIN_H_
++
++#include <Library/EfiTestLib.h>
++
++#define SYSENVCONFIG_TEST_REVISION 0x00010000
++
++#define SYSENVCONFIG_TEST_GUID     \
++  {0xd84a6430, 0x99f5, 0x4660, {0x84, 0x54, 0x6e, 0x4c, 0x89, 0x6a, 0x7e, 0x51}}
++
++EFI_STATUS
++InitializeBBTestSysEnvConfig (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++EFI_STATUS
++BBTestBootSysEnvConfig (
++  IN EFI_HANDLE       ImageHandle
++  );
++
++//
++// Entry GUIDs
++//
++
++#define SYSENVCONFIG_BOOT_EXC_LEVEL_GUID \
++  {0x591cb467, 0x530b, 0x4b16, {0xb0, 0x90, 0xc6, 0xce, 0xfa, 0xfc, 0xc1, 0x56}}
++
++#define SYSENVCONFIG_MEM_ADDR_ALIGNMENT_GUID \
++  {0xe24959d0, 0x9539, 0x4c7b, {0xbd, 0xbc, 0x12, 0x2a, 0xc5, 0xe9, 0xef, 0xd8}}
++
++#define SYSENVCONFIG_OS_DISK_FORMAT_GUID \
++  {0x78f530dd, 0xfe16, 0x4daf, {0xa2, 0x01, 0xbc, 0xb9, 0x37, 0x15, 0x03, 0xa2}}
++
++#define SYSENVCONFIG_EBC_INTERPRETER_PRESENT_GUID \
++  {0xff469a32, 0x6d0a, 0x4a99, {0x8b, 0x1e, 0xd1, 0x37, 0x50, 0x34, 0x08, 0xb6}}
++
++
++#endif /* _SYSENVCONFIG_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/Guid.c b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/Guid.c
+new file mode 100644
+index 0000000..11dcfac
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/Guid.c
+@@ -0,0 +1,67 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  GUIDs auto-generated for EFI test assertion.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID gSBBRRuntimeServicesAssertion001Guid = SBBRRUNTIMESERVICES_ASSERTION_001_GUID;
++
++EFI_GUID gSBBRRuntimeServicesAssertion002Guid = SBBRRUNTIMESERVICES_ASSERTION_002_GUID;
++
++EFI_GUID gSBBRRuntimeServicesAssertion003Guid = SBBRRUNTIMESERVICES_ASSERTION_003_GUID;
++
++EFI_GUID gSBBRRuntimeServicesAssertion004Guid = SBBRRUNTIMESERVICES_ASSERTION_004_GUID;
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/Guid.h b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/Guid.h
+new file mode 100644
+index 0000000..29fcc1f
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/Guid.h
+@@ -0,0 +1,81 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  GUIDs auto-generated for EFI test assertion.
++
++--*/
++
++#ifndef _SBBRRUNTIMESERVICES_GUID_H_
++#define _SBBRRUNTIMESERVICES_GUID_H_
++
++#define SBBRRUNTIMESERVICES_ASSERTION_001_GUID \
++{ 0x787ad247, 0xc901, 0x49d8, {0x84, 0x82, 0x91, 0x5e, 0x09, 0x61, 0xcf, 0x34 }}
++
++extern EFI_GUID gSBBRRuntimeServicesAssertion001Guid;
++
++#define SBBRRUNTIMESERVICES_ASSERTION_002_GUID \
++{ 0xcd4cedc0, 0xf8e3, 0x4f75, {0xbd, 0xec, 0x6d, 0xf2, 0xa6, 0x9f, 0xa4, 0x0f }}
++
++extern EFI_GUID gSBBRRuntimeServicesAssertion002Guid;
++
++#define SBBRRUNTIMESERVICES_ASSERTION_003_GUID \
++{ 0x5a353070, 0xc002, 0x48b7, {0xae, 0x15, 0x80, 0x77, 0xe2, 0x7a, 0x25, 0xaf }}
++
++extern EFI_GUID gSBBRRuntimeServicesAssertion003Guid;
++
++#define SBBRRUNTIMESERVICES_ASSERTION_004_GUID \
++{ 0xe8c528de, 0x4b69, 0x4c6b, {0xaa, 0xec, 0x69, 0x64, 0x59, 0x69, 0x26, 0x6f }}
++
++extern EFI_GUID gSBBRRuntimeServicesAssertion004Guid;
++
++#endif /* _SBBRRUNTIMESERVICES_GUID_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTest.inf b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTest.inf
+new file mode 100644
+index 0000000..fd4dae0
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTest.inf
+@@ -0,0 +1,82 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2016, ARM. All rights reserved.<BR>
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   SBBRRuntimeServicesBBTest.inf
++#
++# Abstract:
++#
++#   Component description file for SBBRRuntimeServices tests.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010005
++  BASE_NAME            = SBBRRuntimeServicesBBTest
++  FILE_GUID            = 8906d7fb-39d8-4f90-ba35-ee838fee1805
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTestSBBRRuntimeServices
++
++[Sources.common]
++  Guid.c
++  SBBRRuntimeServicesBBTestFunction.c
++  SBBRRuntimeServicesBBTestMain.c
++
++[Packages]
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  EfiTestLib
++  SctLib
++  UefiDriverEntryPoint
++
++[Protocols]
++  gEfiTestRecoveryLibraryGuid
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestFunction.c b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestFunction.c
+new file mode 100644
+index 0000000..3cee3ab
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestFunction.c
+@@ -0,0 +1,609 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SBBRRuntimeServicesBBTestFunction.c
++
++Abstract:
++
++  Test cases for SBBRRuntimeServices.
++
++--*/
++#include "Guid.h"
++#include "SctLib.h"
++#include <Library/EfiTestLib.h>
++#include "SBBRRuntimeServicesBBTestMain.h"
++#include "SBBRRuntimeServicesBBTestFunction.h"
++#include EFI_TEST_PROTOCOL_DEFINITION(TestRecoveryLibrary)
++
++
++
++
++/**
++ *  Entrypoint for Runtime Services Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTestRuntimeServices (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  EFI_TEST_ASSERTION                  AssertionType;
++  UINT32              CRC32;
++  UINT32              LocalCRC32;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++                   SupportHandle,
++                   &gEfiStandardTestLibraryGuid,
++                   (VOID **) &StandardLib
++                   );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Check the EFI Runtime Services Table
++  //
++  CRC32 = gtRT->Hdr.CRC32;
++  gtRT->Hdr.CRC32 = 0;
++
++  LocalCRC32 = 0;
++  Status = SctCalculateCrc32 ((UINT8 *)gtRT, gtRT->Hdr.HeaderSize, &LocalCRC32);
++  if (EFI_ERROR (Status)) {
++    AssertionType = EFI_TEST_ASSERTION_FAILED;
++  } else {
++    if ((gtRT->Hdr.Signature             == EFI_RUNTIME_SERVICES_SIGNATURE) &&
++        (gtRT->Hdr.Revision              >= 0x00020000                    ) &&
++        (gtRT->Hdr.Reserved              == 0x00000000                    ) &&
++        (gtRT->GetTime                   != NULL                          ) &&
++        (gtRT->SetTime                   != NULL                          ) &&
++        (gtRT->GetWakeupTime             != NULL                          ) &&
++        (gtRT->SetWakeupTime             != NULL                          ) &&
++        (gtRT->SetVirtualAddressMap      != NULL                          ) &&
++        (gtRT->ConvertPointer            != NULL                          ) &&
++        (gtRT->GetVariable               != NULL                          ) &&
++        (gtRT->GetNextVariableName       != NULL                          ) &&
++        (gtRT->SetVariable               != NULL                          ) &&
++        (gtRT->GetNextHighMonotonicCount != NULL                          ) &&
++        (gtRT->ResetSystem               != NULL                          ) &&
++        (gtRT->QueryVariableInfo         != NULL                          ) &&
++        (gtRT->QueryCapsuleCapabilities  != NULL                          ) &&
++        (gtRT->UpdateCapsule             != NULL                          ) &&
++        (LocalCRC32                      == CRC32                         )) {
++      AssertionType = EFI_TEST_ASSERTION_PASSED;
++    } else {
++      AssertionType = EFI_TEST_ASSERTION_FAILED;
++    }
++
++    gtRT->Hdr.CRC32 = CRC32;
++  }
++
++  StandardLib->RecordAssertion (
++                 StandardLib,
++                 AssertionType,
++                 gSBBRRuntimeServicesAssertion001Guid,
++                 L"UEFI Compliant - EFI Runtime Services Table must be implemented",
++                 L"%a:%d:Signature - %lX, Expected - %lX",
++                 __FILE__,
++                 (UINTN)__LINE__,
++                 gtRT->Hdr.Signature,
++                 EFI_RUNTIME_SERVICES_SIGNATURE
++                 );
++
++  //
++  // Record the entire EFI Runtime Services Table
++  //
++  StandardLib->RecordMessage (
++                 StandardLib,
++                 EFI_VERBOSE_LEVEL_DEFAULT,
++                 L"  Hdr.Signature             : %lX\n"
++                 L"  Hdr.Revision              : %X\n"
++                 L"  Hdr.HeaderSize            : %X\n"
++                 L"  Hdr.CRC32                 : %X\n"
++                 L"  Hdr.Reserved              : %X\n",
++                 gtRT->Hdr.Signature,
++                 gtRT->Hdr.Revision,
++                 gtRT->Hdr.HeaderSize,
++                 gtRT->Hdr.CRC32,
++                 gtRT->Hdr.Reserved
++                 );
++
++
++  StandardLib->RecordMessage (
++                 StandardLib,
++                 EFI_VERBOSE_LEVEL_DEFAULT,
++                 L"  GetTime                   : %X\n"
++                 L"  SetTime                   : %X\n"
++                 L"  GetWakeupTime             : %X\n"
++                 L"  SetWakeupTime             : %X\n"
++                 L"  SetVirtualAddressMap      : %X\n"
++                 L"  ConvertPointer            : %X\n"
++                 L"  GetVariable               : %X\n"
++                 L"  GetNextVariableName       : %X\n"
++                 L"  SetVariable               : %X\n"
++                 L"  GetNextHighMonotonicCount : %X\n"
++                 L"  ResetSystem               : %X\n"
++                 L"  QueryVariableInfo         : %X\n"
++                 L"  QueryCapsuleCapabilities  : %X\n"
++                 L"  UpdateCapsule             : %X\n",
++                 gtRT->GetTime,
++                 gtRT->SetTime,
++                 gtRT->GetWakeupTime,
++                 gtRT->SetWakeupTime,
++                 gtRT->SetVirtualAddressMap,
++                 gtRT->ConvertPointer,
++                 gtRT->GetVariable,
++                 gtRT->GetNextVariableName,
++                 gtRT->SetVariable,
++                 gtRT->GetNextHighMonotonicCount,
++                 gtRT->ResetSystem,
++                 gtRT->QueryVariableInfo,
++                 gtRT->QueryCapsuleCapabilities,
++                 gtRT->UpdateCapsule
++                 );
++
++  //
++  // Done
++  //
++
++  //
++  // Function calls like above are used to record test results.
++  // The actual return value of this function is used to tell
++  // the framework whether the tests completed successfully or
++  // if there was some fault in the test itself.  For example, not
++  // being able to allocate a buffer because the system is out of
++  // memory would return an error, but a test case failing because
++  // a register being checked does not contain the right value
++  // would return EFI_SUCCESS.
++  //
++
++  return EFI_SUCCESS;
++}
++
++
++extern EFI_TPL TplArray [];
++
++
++/**
++ *  Entrypoint for gtRT->ResetSystem() Manual Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++//
++// SBBR 3.5.4
++//
++EFI_STATUS
++BBTestResetShutdown (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL   *StandardLib;
++  EFI_TEST_RECOVERY_LIBRARY_PROTOCOL   *RecoveryLib;
++  EFI_STATUS                           Status;
++  EFI_TEST_ASSERTION                   AssertionType;
++  UINTN                                Index;
++  EFI_TPL                              OldTpl;
++  UINT8                                Buffer[1024];
++  RESET_DATA                           *ResetData;
++  UINTN                                Size;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Get the Recovery Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiTestRecoveryLibraryGuid,
++              (VOID **) &RecoveryLib
++              );
++
++  if (EFI_ERROR (Status)) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gTestGenericFailureGuid,
++                L"BS.HandleProtocol - Handle recovery library",
++                L"%a:%d:Status - %r",
++                __FILE__,
++                (UINTN)__LINE__,
++                Status
++                );
++    return Status;
++  }
++
++  //
++  // Read reset record
++  //
++  Status = RecoveryLib->ReadResetRecord (
++              RecoveryLib,
++              &Size,
++              Buffer
++              );
++  ResetData = (RESET_DATA *)Buffer;
++  if (EFI_ERROR (Status) || (Size < sizeof (RESET_DATA))) {
++    //
++    // Step 1
++    //
++  } else if (ResetData->Step == 1) {
++    //
++    // Step 2
++    //
++    if (ResetData->TplIndex < TPL_ARRAY_SIZE) {
++      Index = ResetData->TplIndex;
++      AssertionType = EFI_TEST_ASSERTION_PASSED;
++      goto ManualTestStep2;
++    }
++  } else {
++    return EFI_LOAD_ERROR;
++  }
++
++  for (Index = 0; Index < TPL_ARRAY_SIZE; Index++) {
++    //
++    // 4.2.2.1  ResetSystem must succeed when ResetType is EfiResetShutdown
++    //
++    ResetData->Step = 1;
++    ResetData->TplIndex = Index;
++    Status = RecoveryLib->WriteResetRecord (
++                RecoveryLib,
++                sizeof (RESET_DATA),
++                Buffer
++                );
++    if (EFI_ERROR (Status)) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"TestRecoveryLib - WriteResetRecord",
++                  L"%a:%d:Status - %r, TPL - %d",
++                  __FILE__,
++                  (UINTN)__LINE__,
++                  Status,
++                  TplArray[Index]
++                  );
++      return Status;
++    }
++
++    //
++    // Print out some information to avoid the user thought it is an error.
++    //
++    // And the stall a second is required to make sure the recovery data has
++    // been written into the storage device.
++    //
++    SctPrint (L"System will shut down (or cold reset) after 1 second...");
++    gtBS->Stall (1000000);
++
++    OldTpl = gtBS->RaiseTPL (TplArray[Index]);
++    gtRT->ResetSystem (
++                EfiResetShutdown,
++                EFI_SUCCESS,
++                0,
++                NULL
++                );
++    gtBS->RestoreTPL (OldTpl);
++    AssertionType = EFI_TEST_ASSERTION_FAILED;
++
++ManualTestStep2:
++    StandardLib->RecordAssertion (
++                StandardLib,
++                AssertionType,
++                Index==0? \
++                  gSBBRRuntimeServicesAssertion003Guid: \
++                  (Index == 1? \
++                  gSBBRRuntimeServicesAssertion002Guid: \
++                  gSBBRRuntimeServicesAssertion003Guid),
++                L"RT.ResetSystem - EfiResetShutdown",
++                L"%a:%d:Status - %r, TPL - %d",
++                __FILE__,
++                (UINTN)__LINE__,
++                Status,
++                TplArray[Index]
++                );
++  }
++
++  return EFI_SUCCESS;
++}
++
++/**
++ *  Entrypoint for NonVolatileVariable test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++//
++// SBBR 3.5.5
++//
++EFI_STATUS
++BBTestNonVolatileVariable (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL   *StandardLib;
++  EFI_TEST_RECOVERY_LIBRARY_PROTOCOL   *RecoveryLib;
++  EFI_STATUS                           Status;
++  EFI_TEST_ASSERTION                   AssertionType;
++  UINT8                                Buffer[20];
++  EFI_GUID                             ResetGuid = SBBRRUNTIMESERVICES_NONVOLATILEVARIABLE_RESET_GUID;
++  EFI_GUID                             *TestResetGuid;
++  EFI_GUID                             VarVendorGuid = VENDOR_GUID;
++  UINTN                                Size;
++  UINT32                               Attributes;
++  UINT32                               VariableValue = UEFI_VARIABLE_TEST_VALUE;
++  UINT32                               *TestVariableValue;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++
++  if (EFI_ERROR(Status)) {
++    return Status;
++  }
++
++  //
++  // Get the Recovery Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiTestRecoveryLibraryGuid,
++              (VOID **) &RecoveryLib
++              );
++  if (EFI_ERROR(Status)) {
++    StandardLib->RecordAssertion (
++                StandardLib,
++                EFI_TEST_ASSERTION_FAILED,
++                gTestGenericFailureGuid,
++                L"BS.HandleProtocol - Handle recovery library",
++                L"%a:%d:Status - %r",
++                __FILE__,
++                (UINTN)__LINE__,
++                Status
++                );
++    return Status;
++  }
++
++  //
++  // Read reset record
++  //
++  Status = RecoveryLib->ReadResetRecord (
++              RecoveryLib,
++              &Size,
++              Buffer
++              );
++  TestResetGuid = (EFI_GUID *)Buffer;
++  if (EFI_ERROR(Status) || SctCompareGuid((void *)TestResetGuid, (void *)&ResetGuid) != 0) {
++    //
++    // Writing a new non-volatile variable for testing after making sure it doesn't already exist.
++    //
++
++    // Making a variable of the same name and vendor GUID with a size of zero to delete anything that might be left over
++    Size = 0;
++    Status = gtRT->SetVariable (
++                TEST_VAR_NAME,
++                &VarVendorGuid,
++                NULL,
++                Size,
++                NULL
++                );
++    if (EFI_ERROR(Status) && Status != EFI_NOT_FOUND) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"RS.SetVariable",
++                  L"%a:%d:Status - %r",
++                  __FILE__,
++                  (UINTN)__LINE__,
++                  Status
++                  );
++      return Status;
++    }
++
++    // Writing a known value into the UEFI variable with nonvolatile flag
++    Size = sizeof (UINT32);
++    Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS;
++    Status = gtRT->SetVariable (
++                TEST_VAR_NAME,
++                &VarVendorGuid,
++                Attributes,
++                Size,
++                (VOID *)&VariableValue
++                );
++    if (EFI_ERROR(Status)) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"RS.SetVariable",
++                  L"%a:%d:Status - %r",
++                  __FILE__,
++                  (UINTN)__LINE__,
++                  Status
++                  );
++      return Status;
++    }
++
++    // Writing reset record and doing a cold reset
++    SctPrint (L"System will cold reboot...");
++    Status = RecoveryLib->WriteResetRecord (
++                RecoveryLib,
++                sizeof (EFI_GUID),
++                &ResetGuid
++                );
++    gtBS->Stall (1000000);
++    gtRT->ResetSystem (
++                EfiResetCold,
++                EFI_SUCCESS,
++                0,
++                NULL
++                );
++
++    // Execution should never get here
++    StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"RT.ResetSystem",
++                  L"%a:%d - System failed to reboot.",
++                  __FILE__,
++                  (UINTN)__LINE__
++                  );
++    return EFI_ABORTED;
++
++  } else if (SctCompareGuid((void *)TestResetGuid, (void *)&ResetGuid) == 0) {
++    //
++    // Reading non-volatile variable to see if it's value was retained.
++    //
++
++    // Calling GetVariable to see if our new variable is still there.
++    Status = gtRT->GetVariable (
++                TEST_VAR_NAME,
++                &VarVendorGuid,
++                &Attributes,
++                &Size,
++                Buffer
++                );
++    if (EFI_ERROR(Status)) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"RS.GetVariable",
++                  L"%a:%d:Status - %r",
++                  __FILE__,
++                  (UINTN)__LINE__,
++                  Status
++                  );
++      return Status;
++    }
++
++    // Erasing the variable we created from the system
++    Size = 0;
++    Status = gtRT->SetVariable (
++                TEST_VAR_NAME,
++                &VarVendorGuid,
++                NULL,
++                Size,
++                NULL
++                );
++    if (EFI_ERROR(Status)) {
++      StandardLib->RecordAssertion (
++                  StandardLib,
++                  EFI_TEST_ASSERTION_FAILED,
++                  gTestGenericFailureGuid,
++                  L"RS.SetVariable",
++                  L"%a:%d:Status - %r",
++                  __FILE__,
++                  (UINTN)__LINE__,
++                  Status
++                  );
++      return Status;
++    }
++
++    // Checking value received against value written.
++    TestVariableValue = (UINT32 *)Buffer;
++    if (*TestVariableValue == VariableValue) {
++      AssertionType = EFI_TEST_ASSERTION_PASSED;
++    } else {
++      AssertionType = EFI_TEST_ASSERTION_FAILED;
++    }
++    StandardLib->RecordAssertion (
++                StandardLib,
++                AssertionType,
++                gSBBRRuntimeServicesAssertion004Guid,
++                L"NonVolatileVariable",
++                L"%a:%d",
++                __FILE__,
++                (UINTN)__LINE__
++                );
++
++    return EFI_SUCCESS;
++  } else {
++    return EFI_LOAD_ERROR;
++  }
++}
+\ No newline at end of file
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestFunction.h b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestFunction.h
+new file mode 100644
+index 0000000..f8ae376
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestFunction.h
+@@ -0,0 +1,90 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SBBRRuntimeServicesBBTestFunction.h
++
++Abstract:
++
++  Header file for SBBRRuntimeServicesBBTestFunction.h.
++
++--*/
++
++#ifndef _SBBRRUNTIMESERVICES_BB_TEST_FUNCTION_H_
++#define _SBBRRUNTIMESERVICES_BB_TEST_FUNCTION_H_
++
++#include <Library/EfiTestLib.h>
++
++#define TEST_VAR_NAME (L"SCT_NON_VOLATILE_TEST")
++#define UEFI_VARIABLE_TEST_VALUE 0xDEADBEEF
++
++EFI_STATUS
++BBTestRuntimeServices (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestResetShutdown (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++EFI_STATUS
++BBTestNonVolatileVariable (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _SBBRRUNTIMESERVICES_BB_TEST_FUNCTION_H_ */
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestMain.c b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestMain.c
+new file mode 100644
+index 0000000..8ce604d
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestMain.c
+@@ -0,0 +1,156 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SBBRRuntimeServicesBBTestMain.c
++
++Abstract:
++
++  Test driver for SBBRRuntimeServices tests.
++
++--*/
++
++#include "SctLib.h"
++#include "SBBRRuntimeServicesBBTestFunction.h"
++#include "SBBRRuntimeServicesBBTestMain.h"
++
++
++EFI_TPL TplArray [TPL_ARRAY_SIZE] = {
++  TPL_APPLICATION,
++  TPL_CALLBACK,
++  TPL_NOTIFY
++};
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  SBBRRUNTIMESERVICES_TEST_REVISION,
++  SBBRRUNTIMESERVICES_TEST_GUID,
++  L"SBBRRuntimeServices Tests",
++  L"Tests to test Runtime Services Exception Level, Memory Map, Real Time Clock , Reset, Shutdown and Set Variable."
++};
++
++EFI_GUID gSupportProtocolGuid[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    SBBRRUNTIMESERVICES_TEST_CASE_GUID,
++    L"Runtime Services Test",
++    L"Test to check runtime services exist or not.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestRuntimeServices
++  },
++  {
++    SBBRRUNTIMESERVICES_TEST_CASE_RESETSHUTDOWN_GUID,
++    L"ResetSystem Shutdown Test",
++    L"Manual Test for ResetSystem Shutdown.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_MANUAL,
++    BBTestResetShutdown
++  },
++  {
++    SBBRRUNTIMESERVICES_TEST_CASE_NONVOLATILEVARIABLE_GUID,
++    L"Non-volatile Variable Reset Test",
++    L"Ensures that non-volatile UEFI variables can survive cold resets.",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid,
++    EFI_TEST_CASE_AUTO,
++    BBTestNonVolatileVariable
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/**
++ *  The driver's Unload function
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was Uninstalled
++*/
++EFI_STATUS
++BBTestSBBRRuntimeServicesUnload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++           ImageHandle,
++           gBBTestProtocolInterface
++           );
++}
++
++/**
++ *  Creates/installs the BlackBox Interface and eminating Entry Point
++ *  node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER: One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTestSBBRRuntimeServices (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++  SctInitializeLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++           &ImageHandle,
++           &gBBTestProtocolField,
++           gBBTestEntryField,
++           BBTestSBBRRuntimeServicesUnload,
++           &gBBTestProtocolInterface
++           );
++}
+diff --git a/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestMain.h b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestMain.h
+new file mode 100644
+index 0000000..5b46068
+--- /dev/null
++++ b/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTestMain.h
+@@ -0,0 +1,106 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - 2016 Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) 2016, ARM Corporation. All rights reserved.<BR>
++
++--*/
++/*++
++
++Module Name:
++
++  SBBRRuntimeServicesBBTestMain.h
++
++Abstract:
++
++  Header file for SBBRRuntimeServicesBBTestMain.c.
++
++--*/
++
++#ifndef _SBBRRUNTIMESERVICES_TEST_MAIN_H_
++#define _SBBRRUNTIMESERVICES_TEST_MAIN_H_
++
++#include "Efi.h"
++
++#define SBBRRUNTIMESERVICES_TEST_REVISION 0x00010000
++
++#define SBBRRUNTIMESERVICES_TEST_GUID     \
++  { 0x52A69BBF, 0xE19F, 0x4e82, {0x93, 0xD6, 0xAA, 0xC4, 0x6E, 0x2E, 0x1E, 0x06 }}
++
++#define SBBRRUNTIMESERVICES_NONVOLATILEVARIABLE_RESET_GUID \
++{ 0xf3a95660, 0xce09, 0x418b, {0x93, 0xfe, 0xd3, 0xfa, 0x9d, 0xe3, 0x9b, 0x45 }}
++
++#define VENDOR_GUID \
++{ 0xb110c08e, 0x9756, 0x4d88, {0xb5, 0x5a, 0x4a, 0x4f, 0x60, 0x3e, 0x71, 0x70 }}
++
++#define TPL_ARRAY_SIZE 3
++
++typedef struct _RESET_DATA {
++  UINTN           Step;
++  UINTN           TplIndex;
++  UINT32          RepeatTimes;
++} RESET_DATA;
++
++EFI_STATUS
++InitializeBBTestSBBRRuntimeServices (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++EFI_STATUS
++BBTestSBBRRuntimeServices (
++  IN EFI_HANDLE       ImageHandle
++  );
++
++//
++// Entry GUIDs
++//
++
++#define SBBRRUNTIMESERVICES_TEST_CASE_GUID \
++  { 0xe867fa15, 0x942b, 0x4c69, {0xad, 0xee, 0xf9, 0x3b, 0x11, 0x71, 0xd0, 0x8c }}
++
++#define SBBRRUNTIMESERVICES_TEST_CASE_RESETSHUTDOWN_GUID \
++  { 0x877143a4, 0xad97, 0x4213, {0x8f, 0x7f, 0x7d, 0xd3, 0x7e, 0xa4, 0x63, 0xd5 }}
++
++#define SBBRRUNTIMESERVICES_TEST_CASE_NONVOLATILEVARIABLE_GUID \
++  { 0xa5936aeb, 0x3642, 0x4d1d, {0xb2, 0x26, 0x09, 0xe0, 0xe0, 0xa5, 0x2b, 0xaf }}
++
++#endif /* _SBBRRUNTIMESERVICES_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCreationScript/data.xml b/SctPkg/TestCreationScript/data.xml
+new file mode 100644
+index 0000000..2824d10
+--- /dev/null
++++ b/SctPkg/TestCreationScript/data.xml
+@@ -0,0 +1,23 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<data>
++    <category>
++        <name>GenericTest</name>
++        <path>Generic</path>
++        <uuid>71652D04-BF38-434A-BCB8-6547D7FD8384</uuid>
++    </category>
++    <category>
++        <name>BootServicesTest</name>
++        <path>BootServices</path>
++        <uuid>E9EF7553-F833-4E56-96E8-38AE679523CC</uuid>
++    </category>
++    <category>
++        <name>RuntimeServicesTest</name>
++        <path>RuntimeServices</path>
++        <uuid>AFF115FB-387B-4c18-8C41-6AFC7F03BB90</uuid>
++    </category>
++    <category>
++        <name>ProtocolTest</name>
++        <path>Protocol</path>
++        <uuid>None</uuid>
++    </category>
++</data>
+\ No newline at end of file
+diff --git a/SctPkg/TestCreationScript/new_test.py b/SctPkg/TestCreationScript/new_test.py
+new file mode 100755
+index 0000000..3f2f43e
+--- /dev/null
++++ b/SctPkg/TestCreationScript/new_test.py
+@@ -0,0 +1,398 @@
++#!/usr/bin/env python
++
++import os
++import sys
++import shutil
++import fileinput
++import datetime
++import uuid
++import xml.etree.ElementTree
++from collections import namedtuple
++import re
++import argparse
++
++# configuration file paths
++
++path_to_sctpkg = "../"
++path_to_efi_categories = "TestCase/UEFI/EFI/"
++path_to_xml = "data.xml"
++
++# test configuration variables
++
++ConfigCategory = ""
++ConfigFileGuid = ""
++ConfigTestName = ""
++ConfigTestDescription = ""
++ConfigTestGuid = ""
++ConfigTestCaseName = ""
++ConfigTestCaseGuid = ""
++ConfigTestCaseDescription = ""
++ConfigAssertionGuid = ""
++ConfigProtocolGuid = ""
++ConfigCGFWCategory = ""
++
++# checkpoint variables so the script can undo changes in the event of some failure
++CheckPointCreatedFileStructure = False
++CheckPointCreatedNewCategoryIni = False
++CheckPointCreatedNewCommonGenFrameworkSh = False
++
++#function declarations
++
++def isInt(s):
++    try:
++        int(s)
++        return True
++    except ValueError:
++        return False
++
++def isHex(s):
++    try:
++        int(s, 16)
++        return True
++    except ValueError:
++        return False
++
++def openFile(path, options):
++    try:
++        file = open(path, options)
++        return file
++    except IOError:
++        return None
++
++def replaceTextPlaceholderInFile(inFilePath):
++    now = datetime.datetime.now()
++
++    renamedInFilePath = ("%s.old" % inFilePath)
++    os.rename(inFilePath, renamedInFilePath)
++
++    inFile = openFile(inFilePath, "w")
++    if inFile == None:
++        print "ERROR: Could not open \"%s\"" % inFilePath
++        return 1
++
++    renamedInFile = openFile(renamedInFilePath, "r")
++    if inFile == None:
++        print "ERROR: Could not open \"%s\"" % renamedInFilePath
++        return 1
++
++    for line in renamedInFile:
++        line = line.replace("$<currentyear>$", ("%d" % now.year))
++        line = line.replace("$<fileguid>$", getHyphenGuid(ConfigFileGuid))
++        line = line.replace("$<testname>$", ConfigTestName)
++        line = line.replace("$<testnameupper>$", ConfigTestName.upper())
++        line = line.replace("$<testdescription>$", ConfigTestDescription)
++        line = line.replace("$<testcasename>$", ConfigTestCaseName)
++        line = line.replace("$<testcasenameupper>$", ConfigTestCaseName.upper())
++        line = line.replace("$<testcasedescription>$", ConfigTestCaseDescription)
++        line = line.replace("$<testcaseguid>$", getCodeGuid(ConfigTestCaseGuid))
++        line = line.replace("$<assertionguid>$", getCodeGuid(ConfigAssertionGuid))
++        if ConfigCategory.name == "ProtocolTest":
++            line = line.replace("$<testguid>$", getCodeGuid(ConfigProtocolGuid))
++        else:
++            line = line.replace("$<testguid>$", getCodeGuid(ConfigTestGuid))
++        inFile.write(line)
++
++    inFile.close()
++    renamedInFile.close()
++    os.remove(renamedInFilePath)
++
++    return 0
++
++def getRawGuid():
++    guid = uuid.uuid4()
++    s = "%s" % guid.hex
++    return s
++
++def getCodeGuid(s):
++    return "{ 0x%s, 0x%s, 0x%s, {0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s }}" % (s[0:8],s[8:12],s[12:16],s[16:18],s[18:20],s[20:22],s[22:24],s[24:26],s[26:28],s[28:30],s[30:])
++
++def getHyphenGuid(s):
++    return "%s-%s-%s-%s-%s" % (s[0:8], s[8:12], s[12:16], s[16:20], s[20:32])
++
++def faultHandler(s):
++    print "Undoing changes made to file structure..."
++    if CheckPointCreatedFileStructure:
++        shutil.rmtree(os.path.join(path_to_sctpkg, path_to_efi_categories, ConfigCategory.path, ConfigTestName))
++    if CheckPointCreatedNewCategoryIni:
++        os.remove(os.path.join(path_to_sctpkg, "Config/Data/Category.ini.new"))
++    if CheckPointCreatedNewCommonGenFrameworkSh:
++        os.remove(os.path.join(path_to_sctpkg, "CommonGenFramework.sh.new"))
++    print "Exiting..."
++    sys.exit()
++
++def isValidSentence(s):
++    if all(x.isalpha() or x.isspace() or isInt(x) or x == "." for x in s):
++        return True
++    else:
++        return False
++
++# entry point
++
++parser = argparse.ArgumentParser(description='Process output from UEFI in FVP.')
++parser.add_argument("-g", "--guid", required=False, default=False, action="store_true", help="Generates a GUID.")
++args = parser.parse_args()
++
++if args.guid == True:
++    guid = getRawGuid()
++    print ""
++    print "%s" % getCodeGuid(guid)
++    print ""
++    print "%s" % getHyphenGuid(guid)
++    print ""
++    sys.exit()
++
++# welcome text
++print "*******************************************************************************"
++print "*                   SCT Test Case Template Creation Wizard                    *"
++print "*******************************************************************************"
++print ""
++
++
++# requesting category
++CategoryEntry = namedtuple("CategoryEntry", "name path uuid")
++Categories = []
++i = 0
++tree = xml.etree.ElementTree.parse(path_to_xml)
++root = tree.getroot()
++for category in root.findall("category"):
++    Categories.append(CategoryEntry(category.find("name").text, category.find("path").text, category.find("uuid").text))
++    print "(%d) %s" % (i, Categories[i].name)
++    i = i + 1
++while True:
++    print "Which category do you want to use for your test? (integer)"
++    UserString = raw_input("> ")
++    if isInt(UserString):
++        UserValue = int(UserString)
++        if UserValue >= i or UserValue < 0:
++            print "Invalid entry \"%s\"" % UserString
++        else:
++            ConfigCategory = Categories[UserValue]
++            print ""
++            break
++    else:
++        print "Invalid entry \"%s\"" % UserString
++
++
++# if protocol test is selected
++if ConfigCategory.name == "ProtocolTest":
++    print "You have selected ProtocolTest, you must enter the UUID of the protocol under test now as a string of 32 hex digits."
++    while True:
++        UserString = raw_input("> ")
++        if len(UserString) == 32 and isHex(UserString):
++            ConfigTestGuid = UserString
++            ConfigProtocolGuid = UserString
++            break
++        else:
++            print "Invalid entry \"%s\"" % UserString
++    print ""
++
++
++# requesting test name
++print "What do you want to call your test? (string)"
++while True:
++    ConfigTestName = raw_input("> ")
++    if ConfigTestName.isalnum() == True and os.path.isdir(os.path.join(path_to_sctpkg, path_to_efi_categories, ConfigCategory.path, ConfigTestName)) == False:
++        break
++    else:
++        print "Invalid entry \"%s\"" % ConfigTestName
++print ""
++
++
++# requestion test description
++print "Please enter a short (~1 sentence) description of your test. (string)"
++while True:
++    ConfigTestDescription = raw_input("> ")
++    if isValidSentence(ConfigTestDescription):
++        break
++    else:
++        print "Invalid entry \"%s\"" % ConfigTestDescription
++print ""
++
++
++# requesting name of first test case
++print "What do you want to call the first test case? (string)"
++while True:
++    ConfigTestCaseName = raw_input("> ")
++    if ConfigTestCaseName.isalnum():
++        break
++    else:
++        print "Invalid entry \"%s\"" % ConfigTestCaseName
++print ""
++
++
++# requesting description of the test case
++print "Please enter a short (~1 sentence) description of your test case. (string)"
++while True:
++    ConfigTestCaseDescription = raw_input("> ")
++    if isValidSentence(ConfigTestCaseDescription):
++        break
++    else:
++        print "Invalid entry \"%s\"" % ConfigTestCaseDescription
++print ""
++
++
++# asking where to place the new test in CommonGenFramework.sh
++cgfwCategories = []
++cgfw = openFile(os.path.join(path_to_sctpkg, "CommonGenFramework.sh"), "r")
++if cgfw == None:
++    print "ERROR: Could not open \"%s\"" % (os.path.join(path_to_sctpkg, "CommonGenFramework.sh"))
++    faultHandler()
++print "Groups in CommonGenFramework.sh"
++i = 0
++for line in cgfw:
++    line = line.split()
++    if len(line) > 4 and line[0] == "if" and line[1] == "[" and line[2] == "$1" and line[3] == "=":
++        cgfwCategories.append(line[4].replace("\"", ""))
++        print "(%d) %s" % (i, cgfwCategories[i])
++        i = i + 1
++print "What group would you like to place your new test in?  Leave it blank if you wish to do this yourself. (integer)"
++while True:
++    UserString = raw_input("> ")
++    if isInt(UserString) and int(UserString) >= 0 and int(UserString) < i:
++        ConfigCGFWCategory = cgfwCategories[int(UserString)]
++        break
++    else:
++        print "Invalid entry \"%s\"" % UserString
++print ""
++
++
++# making sure options are correct
++print "New Test Parameters"
++print "  Category:                 %s" % ConfigCategory.name
++print "  Test Name:                %s" % ConfigTestName
++print "  Test Description:         %s" % ConfigTestDescription
++print "  Test Case Name:           %s" % ConfigTestCaseName
++print "  Test Case Description:    %s" % ConfigTestCaseDescription
++print "  CommonGenFramework Group: %s" % ConfigCGFWCategory
++
++while True:
++    print "Do you wish to apply these changes? (y/n)"
++    UserString = raw_input("> ")
++    if UserString[0] == "y" or UserString[0] == "Y":
++        print ""
++        break
++    elif UserString[0] == "n" or UserString[0] == "N":
++        print "Exiting..."
++        sys.exit()
++    else:
++        print "Invalid entry \"%s\"" % UserString
++
++
++# building test files
++print "Building Test Files..."
++PathToTestDirectory = os.path.join(path_to_sctpkg, path_to_efi_categories, ConfigCategory.path, ConfigTestName, "BlackBoxTest")
++os.makedirs(PathToTestDirectory)
++CheckPointCreatedFileStructure = True
++shutil.copyfile("template_BBTest.inf", os.path.join(PathToTestDirectory, ("%sBBTest.inf" % ConfigTestName)))
++shutil.copyfile("template_Guid.c", os.path.join(PathToTestDirectory, "Guid.c"))
++shutil.copyfile("template_Guid.h", os.path.join(PathToTestDirectory, "Guid.h"))
++shutil.copyfile("template_BBTestFunction.c", os.path.join(PathToTestDirectory, ("%sBBTestFunction.c" % ConfigTestName)))
++shutil.copyfile("template_BBTestFunction.h", os.path.join(PathToTestDirectory, ("%sBBTestFunction.h" % ConfigTestName)))
++shutil.copyfile("template_BBTestMain.c", os.path.join(PathToTestDirectory, ("%sBBTestMain.c" % ConfigTestName)))
++shutil.copyfile("template_BBTestMain.h", os.path.join(PathToTestDirectory, ("%sBBTestMain.h" % ConfigTestName)))
++
++
++# generating guids
++print "Generating GUIDs..."
++ConfigFileGuid = getRawGuid()
++ConfigTestCaseGuid = getRawGuid()
++ConfigAssertionGuid = getRawGuid()
++if ConfigCategory.name != "ProtocolTest":
++    ConfigTestGuid = getRawGuid()
++
++
++# replacing placeholder text in files
++print "Applying changes to templates..."
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, ("%sBBTest.inf" % ConfigTestName)))
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, "Guid.c"))
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, "Guid.h"))
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, ("%sBBTestFunction.c" % ConfigTestName)))
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, ("%sBBTestFunction.h" % ConfigTestName)))
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, ("%sBBTestMain.c" % ConfigTestName)))
++replaceTextPlaceholderInFile(os.path.join(PathToTestDirectory, ("%sBBTestMain.h" % ConfigTestName)))
++
++
++# adding entry to SctPkg/Config/Data/Category.ini
++print "Updating SctPkg/Config/Data/Category.ini..."
++if(os.path.isfile("Category.ini.backup")):
++    os.remove("Category.ini.backup")
++shutil.copyfile(os.path.join(path_to_sctpkg, "Config/Data/Category.ini"), "Category.ini.backup")
++if ConfigCategory.name == "ProtocolTest":
++    CategoryFileEntry = "\n[Category Data]\nRevision      = 0x00010000\nCategoryGuid  = %s\nInterfaceGuid = %s\nName          = %s\%s\nDescription   = %s\n" % (getHyphenGuid(ConfigTestGuid), getHyphenGuid(ConfigProtocolGuid), ConfigCategory.name, ConfigTestName, ConfigTestDescription)
++else:
++    CategoryFileEntry = "\n[Category Data]\nRevision      = 0x00010000\nCategoryGuid  = %s\nInterfaceGuid = %s\nName          = %s\%s\nDescription   = %s\n" % (getHyphenGuid(ConfigTestGuid), ConfigCategory.uuid, ConfigCategory.name, ConfigTestName, ConfigTestDescription)
++CategoryIni = openFile(os.path.join(path_to_sctpkg, "Config/Data/Category.ini"), "r")
++if CategoryIni == None:
++    print "ERROR: Could not open \"%s\"" % os.path.join(path_to_sctpkg, "Config/Data/Category.ini")
++    faultHandler()
++CategoryIniNew = openFile(os.path.join(path_to_sctpkg, "Config/Data/Category.ini.new"), "w")
++if CategoryIniNew == None:
++    print "ERROR: Could not open \"%s\"" % os.path.join(path_to_sctpkg, "Config/Data/Category.ini.new")
++    faultHandler()
++CheckPointCreatedNewCategoryIni = True
++while True:
++    line = CategoryIni.readline()
++    if line == "":
++        if ConfigCategory.name == "ProtocolTest":
++            CategoryIniNew.write(CategoryFileEntry)
++        break
++    CategoryIniNew.write(line)
++    line = line.split()
++    if len(line) == 3 and line[0] == "Name" and line[1] == "=" and line[2] == ConfigCategory.name:
++        line = CategoryIni.readline()
++        CategoryIniNew.write(line)
++        CategoryIniNew.write(CategoryFileEntry)
++CategoryIni.close()
++CategoryIniNew.close()
++
++
++# adding entry to CommonGenFramework.sh
++print "Updating SctPkg/CommonGenFramework.sh..."
++if os.path.isfile("CommonGenFramework.sh.backup"):
++    os.remove("CommonGenFramework.sh.backup")
++shutil.copyfile(os.path.join(path_to_sctpkg, "CommonGenFramework.sh"), "CommonGenFramework.sh.backup")
++ComGenFwSh = openFile(os.path.join(path_to_sctpkg, "CommonGenFramework.sh"), "r")
++if ComGenFwSh == None:
++    print "ERROR: Could not open \"%s\"" % os.path.join(path_to_sctpkg, "CommonGenFramework.sh")
++    faultHandler()
++ComGenFwShNew = openFile(os.path.join(path_to_sctpkg, "CommonGenFramework.sh.new"), "w")
++if ComGenFwShNew == None:
++    print "ERROR: Could not open \"%s\"" % os.path.join(path_to_sctpkg, "CommonGenFramework.sh.new")
++    faultHandler()
++CheckPointCreatedNewCommonGenFrameworkSh = True
++while True:
++    line = ComGenFwSh.readline()
++    if line == "":
++        break
++    ComGenFwShNew.write(line)
++    if line.find(ConfigCGFWCategory) != -1:
++        while True:
++            line = ComGenFwSh.readline()
++            if line == "":
++                break
++            if line[0] == "f" and line[1] == "i" and line[2] == "\n":
++                ComGenFwShNew.write("    # automatically generated test entry\n")
++                ComGenFwShNew.write("    cp $ProcessorType/%sBBTest.efi    $Framework/Test/  > NUL\n\n" % ConfigTestName)
++                ComGenFwShNew.write(line)
++                break
++            ComGenFwShNew.write(line)
++ComGenFwSh.close()
++ComGenFwShNew.close()
++
++
++# finishing up by removing original versions of files and renaming the new ones
++os.remove(os.path.join(path_to_sctpkg, "Config/Data/Category.ini"))
++os.remove(os.path.join(path_to_sctpkg, "CommonGenFramework.sh"))
++os.rename(os.path.join(path_to_sctpkg, "Config/Data/Category.ini.new"), os.path.join(path_to_sctpkg, "Config/Data/Category.ini"))
++os.rename(os.path.join(path_to_sctpkg, "CommonGenFramework.sh.new"), os.path.join(path_to_sctpkg, "CommonGenFramework.sh"))
++os.system("chmod +x %s" % os.path.join(path_to_sctpkg, "CommonGenFramework.sh"))
++
++
++# prompting user to modify their DSC file
++print ""
++print "IMPORTANT: Paste the following line into your projects .dsc file."
++print "SctPkg/TestCase/UEFI/EFI/%s/%s/BlackBoxTest/%sBBTest.inf" % (ConfigCategory.path, ConfigTestName, ConfigTestName)
++print ""
++print "Done, backups of the original Category.ini and CommonGenFramework.sh can be found in the TestCreationScript directory."
++
++sys.exit()
+diff --git a/SctPkg/TestCreationScript/template_BBTest.inf b/SctPkg/TestCreationScript/template_BBTest.inf
+new file mode 100644
+index 0000000..5cb5a67
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_BBTest.inf
+@@ -0,0 +1,81 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++#
++#
++#/*++
++#
++# Module Name:
++#
++#   $<testname>$BBTest.inf
++#
++# Abstract:
++#
++#   Component description file for $<testname>$ tests.
++#
++#--*/
++
++[Defines]
++  INF_VERSION          = 0x00010005
++  BASE_NAME            = $<testname>$BBTest
++  FILE_GUID            = $<fileguid>$
++  MODULE_TYPE          = UEFI_DRIVER
++  VERSION_STRING       = 1.0
++  ENTRY_POINT          = InitializeBBTest$<testname>$
++
++[Sources.common]
++  $<testname>$BBTestMain.c
++  $<testname>$BBTestFunction.c
++  Guid.c
++
++[Packages]
++  MdePkg/MdePkg.dec
++  SctPkg/SctPkg.dec
++  SctPkg/UEFI/UEFI.dec
++
++[LibraryClasses]
++  UefiDriverEntryPoint
++  SctLib
++  EfiTestLib
++
++[Protocols]
+diff --git a/SctPkg/TestCreationScript/template_BBTestFunction.c b/SctPkg/TestCreationScript/template_BBTestFunction.c
+new file mode 100644
+index 0000000..2cd0e68
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_BBTestFunction.c
+@@ -0,0 +1,123 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  $<testname>$BBTestFunction.c
++
++Abstract:
++
++  Test case function definitions for $<testname>$.
++
++--*/
++
++#include "$<testname>$BBTestMain.h"
++#include "$<testname>$BBTestFunction.h"
++#include "SctLib.h"
++#include "Guid.h"
++
++/**
++ *  Entrypoint for $<testcasename>$ Test.
++ *  @param This a pointer of EFI_BB_TEST_PROTOCOL.
++ *  @param ClientInterface a pointer to the interface to be tested.
++ *  @param TestLevel test "thoroughness" control.
++ *  @param SupportHandle a handle containing protocols required.
++ *  @return EFI_SUCCESS Finish the test successfully.
++ */
++
++EFI_STATUS
++BBTest$<testcasename>$Test (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  )
++{
++
++  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
++  EFI_STATUS                          Status;
++  EFI_TEST_ASSERTION                  AssertionType;
++
++  //
++  // Get the Standard Library Interface
++  //
++  Status = gtBS->HandleProtocol (
++              SupportHandle,
++              &gEfiStandardTestLibraryGuid,
++              (VOID **) &StandardLib
++              );
++  if (EFI_ERROR (Status)) {
++    return Status;
++  }
++
++  //
++  // Your code goes here
++  //
++
++  StandardLib->RecordAssertion (
++              StandardLib,
++              EFI_TEST_ASSERTION_PASSED,
++              g$<testname>$Assertion001Guid,
++              L"$<testcasename>$",
++              L"%a:%d",
++              __FILE__,
++              __LINE__
++              );
++
++  //
++  // Function calls like above are used to record test results.
++  // The actual return value of this function is used to tell
++  // the framework whether the tests completed successfully or
++  // if there was some fault in the test itself.  For example, not
++  // being able to allocate a buffer because the system is out of
++  // memory would return an error, but a test case failing because
++  // a register being checked does not contain the right value
++  // would return EFI_SUCCESS.
++  //
++
++  return EFI_SUCCESS;
++}
+diff --git a/SctPkg/TestCreationScript/template_BBTestFunction.h b/SctPkg/TestCreationScript/template_BBTestFunction.h
+new file mode 100644
+index 0000000..1f4b70b
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_BBTestFunction.h
+@@ -0,0 +1,69 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  $<testname>$BBTestFunction.h
++
++Abstract:
++
++  Contains definitions and prototypes for test case functions.
++
++--*/
++
++#ifndef _$<testnameupper>$_BB_TEST_FUNCTION_H_
++#define _$<testnameupper>$_BB_TEST_FUNCTION_H_
++
++EFI_STATUS
++BBTest$<testcasename>$Test (
++  IN EFI_BB_TEST_PROTOCOL       *This,
++  IN VOID                       *ClientInterface,
++  IN EFI_TEST_LEVEL             TestLevel,
++  IN EFI_HANDLE                 SupportHandle
++  );
++
++#endif /* _$<testnameupper>$_BB_TEST_FUNCTION_H_ */
+diff --git a/SctPkg/TestCreationScript/template_BBTestMain.c b/SctPkg/TestCreationScript/template_BBTestMain.c
+new file mode 100644
+index 0000000..1bd4845
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_BBTestMain.c
+@@ -0,0 +1,130 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  $<testname>$BBTestMain.c
++
++Abstract:
++
++  Test driver for $<testname>$ tests.
++
++--*/
++
++#include "SctLib.h"
++#include "$<testname>$BBTestMain.h"
++#include "$<testname>$BBTestFunction.h"
++
++EFI_BB_TEST_PROTOCOL_FIELD gBBTestProtocolField = {
++  $<testnameupper>$_TEST_REVISION,
++  $<testnameupper>$_TEST_GUID,
++  L"$<testname>$ Tests",
++  L"$<testdescription>$"
++};
++
++EFI_GUID gSupportProtocolGuid1[2] = {
++  EFI_STANDARD_TEST_LIBRARY_GUID,
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
++  {
++    $<testnameupper>$_$<testcasenameupper>$_GUID,
++    L"$<testcasename>$",
++    L"$<testcasedescription>$",
++    EFI_TEST_LEVEL_DEFAULT,
++    gSupportProtocolGuid1,
++    EFI_TEST_CASE_AUTO,
++    BBTest$<testcasename>$Test
++  },
++  EFI_NULL_GUID
++};
++
++EFI_BB_TEST_PROTOCOL *gBBTestProtocolInterface;
++
++/**
++ *  The driver's Unload function
++ *  @param  ImageHandle The test driver image handle
++ *  @return EFI_SUCCESS Indicates the interface was Uninstalled
++*/
++EFI_STATUS
++BBTest$<testname>$Unload (
++  IN EFI_HANDLE       ImageHandle
++  )
++{
++  return EfiUninstallAndFreeBBTestInterface (
++              ImageHandle,
++              gBBTestProtocolInterface
++           );
++}
++
++/**
++ *  Creates/installs the BlackBox Interface and eminating Entry Point
++ *  node list.
++ *  @param  ImageHandle The test driver image handle
++ *  @param  SystemTable Pointer to System Table
++ *  @return EFI_SUCCESS Indicates the interface was installed
++ *  @return EFI_OUT_OF_RESOURCES Indicates space for the new handle could not be allocated
++ *  @return EFI_INVALID_PARAMETER: One of the parameters has an invalid value.
++ */
++EFI_STATUS
++InitializeBBTest$<testname>$ (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  )
++{
++
++  EfiInitializeTestLib (ImageHandle, SystemTable);
++
++  return EfiInitAndInstallBBTestInterface (
++              &ImageHandle,
++              &gBBTestProtocolField,
++              gBBTestEntryField,
++              BBTest$<testname>$Unload,
++              &gBBTestProtocolInterface
++           );
++}
+diff --git a/SctPkg/TestCreationScript/template_BBTestMain.h b/SctPkg/TestCreationScript/template_BBTestMain.h
+new file mode 100644
+index 0000000..c146984
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_BBTestMain.h
+@@ -0,0 +1,88 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  $<testname>$BBTestMain.h
++
++Abstract:
++
++  Contains definitions for test information and test GUIDs.
++
++--*/
++
++#ifndef _$<testnameupper>$_TEST_MAIN_H_
++#define _$<testnameupper>$_TEST_MAIN_H_
++
++#include "Efi.h"
++#include "Guid.h"
++#include <Library/EfiTestLib.h>
++
++#define $<testnameupper>$_TEST_REVISION 0x00010000
++
++#define $<testnameupper>$_TEST_GUID     \
++  $<testguid>$
++
++EFI_STATUS
++InitializeBBTest$<testname>$ (
++  IN EFI_HANDLE           ImageHandle,
++  IN EFI_SYSTEM_TABLE     *SystemTable
++  );
++
++EFI_STATUS
++BBTest$<testname>$Unload (
++  IN EFI_HANDLE       ImageHandle
++  );
++
++//
++// Entry GUIDs
++//
++
++#define $<testnameupper>$_$<testcasenameupper>$_GUID \
++  $<testcaseguid>$
++
++#endif /* _$<testnameupper>$_TEST_MAIN_H_ */
+diff --git a/SctPkg/TestCreationScript/template_Guid.c b/SctPkg/TestCreationScript/template_Guid.c
+new file mode 100644
+index 0000000..dc675e0
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_Guid.c
+@@ -0,0 +1,61 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.c
++
++Abstract:
++
++  Global variable assignments for GUIDs used in test assertions.
++
++--*/
++
++#include "Efi.h"
++#include "Guid.h"
++
++EFI_GUID g$<testname>$Assertion001Guid = $<testnameupper>$_ASSERTION_001_GUID;
+diff --git a/SctPkg/TestCreationScript/template_Guid.h b/SctPkg/TestCreationScript/template_Guid.h
+new file mode 100644
+index 0000000..bc31564
+--- /dev/null
++++ b/SctPkg/TestCreationScript/template_Guid.h
+@@ -0,0 +1,66 @@
++/*++
++  The material contained herein is not a license, either
++  expressly or impliedly, to any intellectual property owned
++  or controlled by any of the authors or developers of this
++  material or to any contribution thereto. The material
++  contained herein is provided on an "AS IS" basis and, to the
++  maximum extent permitted by applicable law, this information
++  is provided AS IS AND WITH ALL FAULTS, and the authors and
++  developers of this material hereby disclaim all other
++  warranties and conditions, either express, implied or
++  statutory, including, but not limited to, any (if any)
++  implied warranties, duties or conditions of merchantability,
++  of fitness for a particular purpose, of accuracy or
++  completeness of responses, of results, of workmanlike
++  effort, of lack of viruses and of lack of negligence, all
++  with regard to this material and any contribution thereto.
++  Designers must not rely on the absence or characteristics of
++  any features or instructions marked "reserved" or
++  "undefined." The Unified EFI Forum, Inc. reserves any
++  features or instructions so marked for future definition and
++  shall have no responsibility whatsoever for conflicts or
++  incompatibilities arising from future changes to them. ALSO,
++  THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++  QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++  NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++  CONTRIBUTION THERETO.
++
++  IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++  ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++  THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++  PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++  CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++  UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++  WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++  DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++  THE POSSIBILITY OF SUCH DAMAGES.
++
++  Copyright 2006 - $<currentyear>$ Unified EFI, Inc. All
++  Rights Reserved, subject to all existing rights in all
++  matters included within this Test Suite, to which United
++  EFI, Inc. makes no claim of right.
++
++  Copyright (c) $<currentyear>$, ARM Corporation. All rights reserved.
++
++--*/
++/*++
++
++Module Name:
++
++  Guid.h
++
++Abstract:
++
++  Definitions for GUIDs used in test assertions.
++
++--*/
++
++#ifndef _$<testnameupper>$_GUID_H_
++#define _$<testnameupper>$_GUID_H_
++
++#define $<testnameupper>$_ASSERTION_001_GUID \
++  $<assertionguid>$
++
++extern EFI_GUID g$<testname>$Assertion001Guid;
++
++#endif /* _$<testnameupper>$_GUID_H_ */
+diff --git a/SctPkg/TestInfrastructure/SCT/Framework/Include/SctDef.h b/SctPkg/TestInfrastructure/SCT/Framework/Include/SctDef.h
+index 7c78d07..9d19e9a 100644
+--- a/SctPkg/TestInfrastructure/SCT/Framework/Include/SctDef.h
++++ b/SctPkg/TestInfrastructure/SCT/Framework/Include/SctDef.h
+@@ -75,6 +75,8 @@ Abstract:
+ #define EFI_SCT_NAME                        L"UEFI2.4B Self Certification Test(SCT2)"
+ #elif (EFI_SPECIFICATION_VERSION == EFI_2_50_SYSTEM_TABLE_REVISION)
+ #define EFI_SCT_NAME                        L"UEFI2.5 Self Certification Test(SCT2)"
++#elif (EFI_SPECIFICATION_VERSION == EFI_2_60_SYSTEM_TABLE_REVISION)
++#define EFI_SCT_NAME                        L"UEFI2.6 Self Certification Test(SCT2)"
+ #else
+ #error Unknown EFI_SPECIFICATION_VERSION
+ #endif
+diff --git a/SctPkg/UEFI/SBBR_SCT.dsc b/SctPkg/UEFI/SBBR_SCT.dsc
+new file mode 100644
+index 0000000..f6583cc
+--- /dev/null
++++ b/SctPkg/UEFI/SBBR_SCT.dsc
+@@ -0,0 +1,308 @@
++#
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2016 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2010 - 2016, Intel Corporation. All rights reserved.<BR>
++#
++# Copyright (c) 2016, ARM Ltd. All rights reserved.<BR>
++#
++#
++#/*++
++#
++# Module Name:
++#
++#    SBBR_SCT.dsc
++#
++# Abstract:
++#
++#   This is a build description file used to build the test modules of SBBR SCT.
++#
++# Notes:
++#
++#   The info in this file is broken down into sections. The start of a section
++#   is designated by a "[" in the first column. So the [=====] separater ends
++#   a section.
++#
++#--*/
++
++################################################################################
++#
++# Defines Section - statements that will be processed to create a Makefile.
++#
++################################################################################
++[Defines]
++  PLATFORM_NAME                  = SbbrSct
++  PLATFORM_GUID                  = d513138b-9d4a-479c-8058-4a5160018663
++  PLATFORM_VERSION               = 0.1
++  DSC_SPECIFICATION              = 0x00010005
++  OUTPUT_DIRECTORY               = Build/SbbrSct
++  SUPPORTED_ARCHITECTURES        = AARCH64
++  BUILD_TARGETS                  = DEBUG|RELEASE
++  SKUID_IDENTIFIER               = DEFAULT
++
++  DEFINE GCC_VER_MACRO           = -D EFI_SPECIFICATION_VERSION=0x00020028 -D TIANO_RELEASE_VERSION=0x00080006
++  DEFINE MSFT_VER_MACRO          = /D EFI_SPECIFICATION_VERSION=0x00020028 /D TIANO_RELEASE_VERSION=0x00080006
++
++
++################################################################################
++#
++# SKU Identification section - list of all SKU IDs supported by this
++#                              Platform.
++#
++################################################################################
++[SkuIds]
++  0|DEFAULT              # The entry: 0|DEFAULT is reserved and always required.
++
++[BuildOptions]
++  *_*_AARCH64_CC_FLAGS         = -D EFIAARCH64 -I$(WORKSPACE)/MdePkg/Include/AArch64 $(GCC_VER_MACRO)
++  GCC:*_*_AARCH64_CC_FLAGS     = -D EFIAARCH64 $(GCC_VER_MACRO) -ffreestanding -nostdinc -nostdlib -Wno-error=unused-function -Wno-error=unused-but-set-variable -Wno-error
++  *_*_AARCH64_VFRPP_FLAGS      = -D EFIAARCH64 $(GCC_VER_MACRO)
++  *_*_AARCH64_APP_FLAGS        = -D EFIAARCH64 $(GCC_VER_MACRO)
++  *_*_AARCH64_PP_FLAGS         = -D EFIAARCH64 $(GCC_VER_MACRO)
++  RVCT:*_*_AARCH64_DLINK_FLAGS = --muldefweak
++
++  DEBUG_*_*_CC_FLAGS  = -DEFI_DEBUG
++  RELEASE_*_*_CC_FLAGS  = -DMDEPKG_NDEBUG
++
++[Libraries]
++  SctPkg/Library/SctLib/SctLib.inf
++  SctPkg/Library/SctGuidLib/SctGuidLib.inf
++  SctPkg/Library/EfiTestLib/EfiTestLib.inf
++
++  SctPkg/TestInfrastructure/SCT/Framework/ENTS/EasLib/EntsLib.inf
++
++  MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
++
++[Libraries.ARM]
++  ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
++
++[Libraries.AARCH64]
++  ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
++
++[LibraryClasses.common]
++  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
++  UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
++  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
++  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
++  BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
++  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
++  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
++  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
++  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
++  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
++  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
++  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
++  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
++  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
++
++  SctLib|SctPkg/Library/SctLib/SctLib.inf
++  NetLib|SctPkg/Library/NetLib/NetLib.inf
++  EntsLib|SctPkg/TestInfrastructure/SCT/Framework/ENTS/EasLib/EntsLib.inf
++  EasLib|SctPkg/TestInfrastructure/SCT/Framework/ENTS/EasDispatcher/Eas.inf
++  EfiTestLib|SctPkg/Library/EfiTestLib/EfiTestLib.inf
++
++[LibraryClasses.ARM]
++  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
++
++[LibraryClasses.AARCH64]
++  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
++  ArmLib|ArmPkg/Library/ArmLib/ArmBaseLib.inf
++
++###############################################################################
++#
++# These are the components that will be built by the master makefile
++#
++###############################################################################
++
++[Components]
++
++#
++# The default package
++#
++DEFINE PACKAGE=Default
++
++#
++# Components
++#
++
++#
++# Following are the SCT suite & related drivers
++#
++
++SctPkg/TestInfrastructure/SCT/Framework/Sct.inf
++SctPkg/TestInfrastructure/SCT/Drivers/StandardTest/StandardTest.inf
++SctPkg/TestInfrastructure/SCT/Drivers/TestProfile/TestProfile.inf
++SctPkg/TestInfrastructure/SCT/Drivers/TestRecovery/TestRecovery.inf
++SctPkg/TestInfrastructure/SCT/Drivers/TestLogging/TestLogging.inf
++
++#
++# Related SCT applications
++#
++
++SctPkg/Application/InstallSct/InstallSct.inf
++SctPkg/Application/StallForKey/StallForKey.inf
++
++SctPkg/SCRT/SCRTApp/SCRTApp.inf
++SctPkg/SCRT/SCRTDriver/SCRTDriver.inf
++
++#
++# Test cases for SBBR SCT
++#
++
++# Boot Services Tests - SBBR v1.0 Appendix A
++#
++##  1. EFI_RAISE_TPL
++##  2. EFI_RESTORE_TPL
++##  3. EFI_CREATE_EVENT
++##  4. EFI_SET_TIMER
++##  5. EFI_WAIT_FOR_EVENT
++##  6. EFI_SIGNAL_EVENT
++##  7. EFI_CLOSE_EVENT
++##  8. EFI_CREATE_EVENT_EX
++SctPkg/TestCase/UEFI/EFI/BootServices/EventTimerTaskPriorityServices/BlackBoxTest/EventTimerTaskPriorityServicesBBTest_uefi.inf
++#
++##  9. EFI_IMAGE_LOAD
++## 10. EFI_IMAGE_START
++## 11. EFI_EXIT
++## 12. EFI_IMAGE_UNLOAD
++## 13. EFI_EXIT_BOOT_SERVICES
++SctPkg/TestCase/UEFI/EFI/BootServices/ImageServices/BlackBoxTest/ImageBBTest.inf
++#
++## 14. EFI_ALLOCATE_PAGES
++## 15. EFI_FREE_PAGES
++## 16. EFI_GET_MEMORY_MAP
++## 17. EFI_ALLOCATE_POOL
++## 18. EFI_FREE_POOL
++SctPkg/TestCase/UEFI/EFI/BootServices/MemoryAllocationServices/BlackBoxTest/MemoryAllocationServicesBBTest.inf
++#
++## 19. EFI_INSTALL_CONFIGURATION_TABLE
++## 20. EFI_GET_NEXT_MONOTONIC_COUNT
++## 21. EFI_STALL
++## 22. EFI_SET_WATCHDOG_TIMER
++## 23. EFI_CALCULATE_CRC32
++## 24. EFI_COPY_MEM
++## 25. EFI_SET_MEM
++SctPkg/TestCase/UEFI/EFI/BootServices/MiscBootServices/BlackBoxTest/MiscBootServicesBBTest.inf
++#
++## 26. EFI_INSTALL_PROTOCOL_INTERFACE
++## 27. EFI_REINSTALL_PROTOCOL_INTERFACE
++## 28. EFI_UNINSTALL_PROTOCOL_INTERFACE
++## 29. EFI_HANDLE_PROTOCOL
++## 30. EFI_REGISTER_PROTOCOL_NOTIFY
++## 31. EFI_LOCATE_HANDLE
++## 32. EFI_LOCATE_PROTOCOL
++## 33. EFI_LOCATE_DEVICE_PATH
++## 34. EFI_CONNECT_CONTROLLER
++## 35. EFI_DISCONNECT_CONTROLLER
++## 36. EFI_OPEN_PROTOCOL
++## 37. EFI_CLOSE_PROTOCOL
++## 38. EFI_OPEN_PROTOCOL_INFORMATION
++## 39. EFI_PROTOCOLS_PER_HANDLE
++## 40. EFI_LOCATE_HANDLE_BUFFER
++## 41. EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES
++## 42. EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES
++SctPkg/TestCase/UEFI/EFI/BootServices/ProtocolHandlerServices/BlackBoxTest/ProtocolHandlerBBTest.inf
++# End of Boot Services Tests - SBBR v1.0 Appendix A
++
++#
++# UEFI System Environment and Configuration Tests - SBBR v1.0 3.3
++#
++SctPkg/TestCase/UEFI/EFI/Generic/SbbrSysEnvConfig/BlackBoxTest/SysEnvConfigBBTest.inf
++#End of UEFI System Environment and Configuration Tests - SBBR v1.0 3.3
++#
++# Check if EFI Specification Version is 2.5 or greater
++SctPkg/TestCase/UEFI/EFI/Generic/SbbrEfiSpecVerLvl/BlackBoxTest/EfiSpecVerLvlBBTest.inf
++#
++# UEFI Boot Services - SBBR v1.0 3.4
++#
++## 3.4.4 Configuration Tables
++SctPkg/TestCase/UEFI/EFI/BootServices/SbbrBootServices/BlackBoxTest/SbbrBootServicesBBTest.inf
++# End of UEFI Boot Services - SBBR v1.0 3.4
++
++#
++# SMBIOS Requirements on UEFI - SBBR v1.0 5.1.1
++#
++SctPkg/TestCase/UEFI/EFI/Generic/SbbrSmbios/BlackBoxTest/SbbrSmbiosBBTest.inf
++
++#
++# Required UEFI Runtime Services Tests - SBBR v1.0 Appendix B
++#
++##  1. EFI_GET_TIME
++##  2. EFI_SET_TIME
++##  3. EFI_GET_WAKEUP_TIME
++##  4. EFI_SET_WAKEUP_TIME
++SctPkg/TestCase/UEFI/EFI/RuntimeServices/TimeServices/BlackBoxTest/TimeServicesBBTest.inf
++#
++##  5. EFI_GET_VARIABLE
++##  6. EFI_GET_NEXT_VARIABLE_NAME
++##  7. EFI_SET_VARIABLE
++##  8. EFI_QUERY_VARIABLE_INFO
++SctPkg/TestCase/UEFI/EFI/RuntimeServices/VariableServices/BlackBoxTest/VariableServicesBBTest.inf
++#
++##  9. EFI_QUERY_CAPSULE_CAPABILITIES
++## 10. EFI_UPDATE_CAPSULE
++## 11. EFI_RESET_SYSTEM
++SctPkg/TestCase/UEFI/EFI/RuntimeServices/MiscRuntimeServices/BlackBoxTest/MiscRuntimeServicesBBTest.inf
++#
++## 12. EFI_SET_VIRTUAL_ADDRESS_MAP
++## 13. EFI_CONVERT_POINTER
++SctPkg/TestCase/UEFI/EFI/RuntimeServices/SBBRRuntimeServices/BlackBoxTest/SBBRRuntimeServicesBBTest.inf
++# End of Runtime Services Tests - SBBR v1.0 Appendix B
++
++#
++# UEFI Required Protocols Tests - SBBR Appendix C
++#
++SctPkg/TestCase/UEFI/EFI/Generic/SbbrRequiredUefiProtocols/BlackBoxTest/RequiredUefiProtocolsBBTest.inf
++SctPkg/TestCase/UEFI/EFI/Generic/EfiCompliant/BlackBoxTest/EfiCompliantBBTest_uefi.inf
++# End of UEFI Required Protocols Tests - SBBR Appendix C
++
++#
++# Dependency files
++#
++
++#
++# Support Files
++#
++SctPkg/TestInfrastructure/SCT/Framework/ENTS/Eftp/Eftp.inf
++SctPkg/TestInfrastructure/SCT/Framework/ENTS/MonitorServices/SerialMonitor/SerialMonitor.inf
++SctPkg/TestInfrastructure/SCT/Framework/ENTS/MonitorServices/ManagedNetworkMonitor/ManagedNetworkMonitor.inf
++SctPkg/TestInfrastructure/SCT/Framework/ENTS/MonitorServices/IP4NetworkMonitor/IP4NetworkMonitor.inf
++
+diff --git a/SctPkg/build_sbbr.sh b/SctPkg/build_sbbr.sh
+new file mode 100755
+index 0000000..6956e9b
+--- /dev/null
++++ b/SctPkg/build_sbbr.sh
+@@ -0,0 +1,312 @@
++#!/bin/bash
++# The material contained herein is not a license, either
++# expressly or impliedly, to any intellectual property owned
++# or controlled by any of the authors or developers of this
++# material or to any contribution thereto. The material
++# contained herein is provided on an "AS IS" basis and, to the
++# maximum extent permitted by applicable law, this information
++# is provided AS IS AND WITH ALL FAULTS, and the authors and
++# developers of this material hereby disclaim all other
++# warranties and conditions, either express, implied or
++# statutory, including, but not limited to, any (if any)
++# implied warranties, duties or conditions of merchantability,
++# of fitness for a particular purpose, of accuracy or
++# completeness of responses, of results, of workmanlike
++# effort, of lack of viruses and of lack of negligence, all
++# with regard to this material and any contribution thereto.
++# Designers must not rely on the absence or characteristics of
++# any features or instructions marked "reserved" or
++# "undefined." The Unified EFI Forum, Inc. reserves any
++# features or instructions so marked for future definition and
++# shall have no responsibility whatsoever for conflicts or
++# incompatibilities arising from future changes to them. ALSO,
++# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
++# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
++# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
++# CONTRIBUTION THERETO.
++#
++# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
++# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
++# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
++# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
++# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
++# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
++# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
++# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
++# THE POSSIBILITY OF SUCH DAMAGES.
++#
++# Copyright 2006 - 2015 Unified EFI, Inc. All
++# Rights Reserved, subject to all existing rights in all
++# matters included within this Test Suite, to which United
++# EFI, Inc. makes no claim of right.
++#
++# Copyright (c) 2011, 2015 ARM Ltd. All rights reserved.<BR>
++#
++
++SctpackageDependencyList=(EdkCompatibilityPkg SctPkg BaseTools)
++
++function get_build_arch
++{
++	case `uname -m` in
++	    aarch64*)
++	        BUILD_ARCH=AARCH64;;
++	    *)
++	        BUILD_ARCH=other;;
++	esac
++}
++
++function set_cross_compile
++{
++	get_build_arch
++
++	echo "Target: $SCT_TARGET_ARCH"
++	echo "Build: $BUILD_ARCH"
++	if [ "$SCT_TARGET_ARCH" = "$BUILD_ARCH" ]; then
++	    TEMP_CROSS_COMPILE=
++	elif [ "$SCT_TARGET_ARCH" == "AARCH64" ]; then
++	    if [ X"$CROSS_COMPILE_64" != X"" ]; then
++	        TEMP_CROSS_COMPILE="$CROSS_COMPILE_64"
++	    else
++	        TEMP_CROSS_COMPILE=aarch64-linux-gnu-
++	    fi
++	else
++	    echo "Unsupported target architecture '$SCT_TARGET_ARCH'!" >&2
++	fi
++}
++
++function get_gcc_version
++{
++	gcc_version=$($1 -dumpversion)
++	case $gcc_version in
++		4.6*|4.7*|4.8*|4.9*)
++			echo GCC$(echo ${gcc_version} | awk -F. '{print $1$2}')
++			;;
++		*)
++			echo "Unknown toolchain version '$gcc_version'" >&2
++			echo "Attempting to build using GCC49 profile." >&2
++			echo GCC49
++			;;
++	esac
++}
++
++function get_clang_version
++{
++	clang_version=`$1 --version | head -1 | sed 's/^.*version\s*\([0-9]*\).\([0-9]*\).*/\1\2/g'`
++	echo "CLANG$clang_version"
++}
++
++
++GetBaseToolsBinSubDir() {
++	#
++	# Figure out a uniq directory name from the uname command
++	#
++	UNAME_DIRNAME=`uname -sm`
++	UNAME_DIRNAME=${UNAME_DIRNAME// /-}
++	UNAME_DIRNAME=${UNAME_DIRNAME//\//-}
++	echo $UNAME_DIRNAME
++}
++
++GetEdkToolsPathBinDirectory() {
++	#
++	# Figure out a uniq directory name from the uname
++	# command
++	#
++	BIN_SUB_DIR=`GetBaseToolsBinSubDir`
++
++	if [ -e	$EDK_TOOLS_PATH/BinWrappers/$BIN_SUB_DIR ]
++	then
++		EDK_TOOLS_PATH_BIN=$EDK_TOOLS_PATH/BinWrappers/$BIN_SUB_DIR
++	else
++		EDK_TOOLS_PATH_BIN=$EDK_TOOLS_PATH/BinWrappers/PosixLike
++	fi
++        echo $EDK_TOOLS_PATH_BIN
++}
++
++PrintUsage() {
++	#
++	#Print Help
++	#
++	echo "Usage:"
++	echo "    $0 <architecture (ARM, AARCH64, X64, etc)> \
++<toolchain name (RVCT or ARMGCC or GCC*)> \
++[build type (RELEASE OR DEBUG, DEFAULT: DEBUG)]"
++}
++
++#Iterate through the SCT package dependency list and check if they exist in the current directory
++for pkg in ${names[@]}
++do
++    if [ ! -d `pwd`/$name]
++    then
++    echo "Couldn't build SCT:"
++    echo The directory `pwd`/$name does not exist.
++    exit -1
++    fi
++done
++
++export EFI_SOURCE=`pwd`
++export EDK_SOURCE=`pwd`/EdkCompatibilityPkg
++
++# check if the last command was successful
++status=$?
++if test $status -ne 0; then
++	echo Could not Run the edksetup.sh script
++	exit -1
++fi
++
++SCT_TARGET_ARCH=${1}
++
++#
++# Pick a default tool type for a given OS
++#
++case `uname` in
++   Linux*)
++	case ${2} in
++		RVCT | rvct)
++			TARGET_TOOLS=RVCTLINUX
++		;;
++
++		ARMGCC | armgcc)
++			TARGET_TOOLS=ARMGCC
++		;;
++
++		GCC | gcc)
++            set_cross_compile
++	        CROSS_COMPILE="$TEMP_CROSS_COMPILE"
++            export TARGET_TOOLS=`get_gcc_version "$CROSS_COMPILE"gcc`
++
++		;;
++
++		*)
++			echo "Couldn't build SBBR SCT:"
++			PrintUsage
++			exit -1
++		;;
++	esac
++   ;;
++   CYGWIN*)
++	case ${2} in
++		RVCT | rvct)
++			TARGET_TOOLS=RVCT31CYGWIN
++		;;
++
++		ARMGCC | armgcc)
++			TARGET_TOOLS=ARMGCCCYGWIN
++		;;
++
++		*)
++			echo "Couldn't build SBBR SCT:"
++			PrintUsage
++			exit -1
++		;;
++	esac
++   ;;
++   *)
++     echo "Couldn't build SBBR SCT:"
++     echo "Unknown OS, Use this script either in Unix or Cygwin environment".
++     PrintUsage
++     exit -1
++   ;;
++esac
++
++echo "TOOLCHAIN is ${TARGET_TOOLS}"
++export ${TARGET_TOOLS}_${SCT_TARGET_ARCH}_PREFIX=$CROSS_COMPILE
++echo "Toolchain prefix: ${TARGET_TOOLS}_${SCT_TARGET_ARCH}_PREFIX=$CROSS_COMPILE"
++
++SCT_BUILD=DEBUG
++if [ "$3" = "RELEASE" -o "$3" = "DEBUG" ]; then
++  SCT_BUILD=$3
++  shift
++fi
++
++#
++# Setup workspace if it is not set
++#
++if [ -z "${WORKSPACE:-}" ]; then
++	echo Initializing workspace
++	# Uses an external BaseTools project
++	# Uses the BaseTools in edk2
++	export EDK_TOOLS_PATH=`pwd`/BaseTools
++	# We do not pass BuildArmSct.sh arguments to edksetup.sh
++	while (( "$#" )); do
++		shift
++	done
++	source ./edksetup.sh
++else
++	echo Building from: $WORKSPACE
++fi
++
++if  [[ ! -e $EDK_TOOLS_PATH/Source/C/bin ]]
++then
++  # build the tools if they don't yet exist
++  echo Building tools: $EDK_TOOLS_PATH
++  make -C $EDK_TOOLS_PATH
++  status=$?
++  if test $status -ne 0
++  then
++  echo Error while building EDK tools
++    exit -1
++  fi
++else
++  echo using prebuilt tools
++fi
++
++# Copy GenBin file to Base tools directory
++DEST_DIR=`GetEdkToolsPathBinDirectory`
++# Ensure the directory exist
++mkdir -p $DEST_DIR
++case `uname -m` in
++	x86_64)
++		cp SctPkg/Tools/Bin/GenBin_lin_64 $DEST_DIR/GenBin
++		;;
++	x86_32)
++		cp SctPkg/Tools/Bin/GenBin_lin_32 $DEST_DIR/GenBin
++		;;
++	*)
++		cp SctPkg/Tools/Bin/GenBin_lin_32 $DEST_DIR/GenBin
++		;;
++esac
++
++#
++# Build the SCT package
++#
++build -p SctPkg/UEFI/SBBR_SCT.dsc -a $SCT_TARGET_ARCH -t $TARGET_TOOLS -b $SCT_BUILD $3 $4 $5 $6 $7 $8 $9
++
++# Check if there is any error
++status=$?
++if test $status -ne 0
++then
++echo Could not build the SBBR SCT package
++        exit -1
++fi
++
++#
++# If the argument is clean, then don't have to generate Sct binary.
++#
++for arg in "$@"
++do
++  if [ $arg == clean ] || [ $arg == cleanall ]
++  then
++      # no need to post process if we are doing a clean
++      exit 1
++  fi
++done
++
++#
++# Change directory to Build directory
++#
++cd Build/SbbrSct/${SCT_BUILD}_${TARGET_TOOLS}
++pwd
++
++#
++# Run a script to generate Sct binary for the target architecture
++#
++../../../SctPkg/CommonGenFramework.sh sbbr_sct $SCT_TARGET_ARCH Install$SCT_TARGET_ARCH.efi
++
++status=$?
++if test $status -ne 0
++then
++echo Could not generate SBBR SCT binary
++     exit -1
++else
++echo The SBBR SCT binary "SctPackage${SCT_TARGET_ARCH}" is located at "$EFI_SOURCE/Build/SbbrSct/${SCT_BUILD}_${TARGET_TOOLS}"
++fi
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
new file mode 100644
index 0000000..68ec434
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
@@ -0,0 +1,101 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+SUMMARY = "SBBR is a test suite that runs Server Base Boot Requirements UEFI tests."
+
+DESCRIPTION = "This Server Base Boot Requirements (SBBR) test suite is intended \
+for SBSA[2]-compliant 64-bit ARMv8 servers. It defines the base firmware requirements \
+for out-of-box support of any ARM SBSA-compatible Operating System or hypervisor. \
+The tests are expected to be minimal yet complete for booting a multi-core \
+ARMv8 server platform, while leaving plenty of room \
+for OEM or ODM innovations and design details."
+
+# Home Page
+HOMEPAGE = "https://github.com/UEFI/UEFI-SCT"
+
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+SBBRVERSION="v1.0"
+PV="${SBBRVERSION}+git${SRCPV}"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+# No information for SRC_URI yet (only an external source tree was specified)
+SRCREV  = "c78ea66cb114390e8dd8de922bdf4ff3e9770f8c"
+SRC_URI = "git://github.com/UEFI/UEFI-SCT.git;protocol=https;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+           file://sbbr_v1.0.patch \
+           file://luv-test-sbbr \
+           file://luv-parser-sbbr \
+          "
+
+# NOTE: no Makefile found, unable to determine what needs to be done
+
+do_configure () {
+	# Specify any needed configure commands here
+	:
+	echo "do_configure()"
+	# Specify any needed configure commands here
+	rm -rf edk2
+	git clone http://ssg-sw.cambridge.arm.com/gerrit/css/src/fw/uefi/edk2
+	cd edk2
+	git checkout integration
+	ln -s ../SctPkg SctPkg
+	chmod +x SctPkg/build_sbbr.sh
+	cd ..
+
+	mkdir -p "tools/gcc"
+	cd "tools/gcc"
+	wget -nv "https://releases.linaro.org/components/toolchain/binaries/4.9-2016.02/aarch64-linux-gnu/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz"
+	#Untar the GCC Linaro files.
+	tar -xf gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz
+	cd ../..
+}
+
+do_compile () {
+	# Specify compilation commands here
+	:
+	echo "$PWD: do_compile()"
+	export PATH=$PATH:"$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE PATH"
+	echo "New PATH = $PATH"
+	export CROSS_COMPILE="$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE CROSS_COMPILE"
+	echo "NEW CROSS_COMPILE: $CROSS_COMPILE"
+
+	cd edk2
+	./SctPkg/build_sbbr.sh AARCH64 GCC
+	cd ..
+}
+
+do_install () {
+	# Specify install commands here
+	:
+	echo "do_install()"
+	echo "Destination Directory: ${D}"
+	echo "Source Directory: ${B}"
+	cp -r ${B}/edk2/Build/SbbrSct/DEBUG_GCC49/SctPackageAARCH64 ${D}/sbbr
+	cp ${B}/edk2/ShellBinPkg/UefiShell/AArch64/Shell.efi ${D}/sbbr/Shell.efi
+}
+
+do_deploy () {
+	# Specify deploy commands here
+	:
+	echo "do_deploy()"
+	echo "Destination Directory: ${DEPLOYDIR}"
+	echo "Source Directory: ${D}"
+	install -d ${DEPLOYDIR}
+	cp -r ${D}/sbbr ${DEPLOYDIR}/sbbr
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-bsp/sbsa/files/compile.sh b/meta-luv/recipes-bsp/sbsa/files/compile.sh
new file mode 100755
index 0000000..4b86191
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/files/compile.sh
@@ -0,0 +1,16 @@
+#!/usr/bin/env bash
+
+
+cd ${1}/edk2
+
+export GCC49_AARCH64_PREFIX=${1}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+
+echo "do_compile: Initializing EDK2 for building."
+set --
+source edksetup.sh
+
+echo "do_compile: Building BaseTools."
+make -C BaseTools/Source/C
+
+echo "do_compile: Building SBSA."
+source AppPkg/Applications/Sbsa/avsbuild.sh
\ No newline at end of file
diff --git a/meta-luv/recipes-bsp/sbsa/sbsa.bb b/meta-luv/recipes-bsp/sbsa/sbsa.bb
new file mode 100644
index 0000000..0543333
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/sbsa.bb
@@ -0,0 +1,105 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+# SCT files placed in ${WORKDIR}/git
+# GCC files placed in ${WORKDIR}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu
+SRC_URI = "git://github.com/ARM-software/sbsa-acs.git;protocol=https;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+           https://releases.linaro.org/components/toolchain/binaries/latest-5/aarch64-linux-gnu/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu.tar.xz \
+           file://compile.sh"
+
+PV = "1.0+git${SRCPV}"
+SRCREV = "${AUTOREV}"
+
+# GCC checksum.
+SRC_URI[md5sum] = "24ac2e26f50f49f3043f281440b41bba"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+do_configure () {
+
+    # Downloading EDK2 into ${WORKDIR}/edk2.
+    echo "do_configure: Checking if EDK2 repository already exists."
+    cd ${WORKDIR}
+    if [ ! -d ${WORKDIR}/edk2 ]
+    then
+        echo "do_configure: Cloning EDK2 repository."
+        git clone https://github.com/tianocore/edk2.git
+    fi
+
+    # Linking SBSA and EDK2.
+    echo "do_configure: Linking SBSA to EDK2."
+    cd ${WORKDIR}/git/suites/uefi_app
+    if [ -d val ]
+    then
+        echo "do_configure: Existing val found, deleted."
+        rm val
+    fi
+    if [ -d pal ]
+    then
+        echo "do_configure: Existing pal found, deleted."
+        rm pal
+    fi
+    if [ -d test_pool ]
+    then
+        echo "do_configure: Existing test_pool found, deleted."
+        rm test_pool
+    fi
+    cd ${WORKDIR}/edk2/AppPkg/Applications
+    if [ -d Sbsa ]
+    then
+        echo "do_configure: Existing Sbsa found, deleted."
+        rm Sbsa
+    fi
+    cd ${WORKDIR}/git
+    set -- "${WORKDIR}/git" "${WORKDIR}/edk2"
+    . ${WORKDIR}/git/tools/scripts/avssetup.sh
+    set --
+    cd ../..
+
+    # Modifying EDK2 to build SBSA.
+    echo "do_configure: Modifying edk2/ShellPkg/ShellPkg.dsc to build SBSA."
+    if ! grep -q SbsaPalLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaPalLib|AppPkg/Applications/Sbsa/pal/SbsaPalLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaValLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaValLib|AppPkg/Applications/Sbsa/val/SbsaValLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaAvs "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/Components/ a \ \ AppPkg/Applications/Sbsa/SbsaAvs.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+}
+
+do_compile () {
+    cd ${WORKDIR}
+    ./compile.sh ${WORKDIR}
+}
+
+do_install () {
+    echo "do_install: Copying SBSA files to destination ${D}"
+    mkdir ${D}/sbsa
+	cp ${WORKDIR}/edk2/Build/Shell/DEBUG_GCC49/AARCH64/Sbsa.efi ${D}/sbsa/Sbsa.efi
+}
+
+do_deploy () {
+    echo "do_deploy: Deploying SBSA files to destionation ${DEPLOYDIR}"
+    install -d ${DEPLOYDIR}
+    cp -r ${D}/sbsa ${DEPLOYDIR}/sbsa
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-core/fwts/fwts/sbbr.patch b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
new file mode 100644
index 0000000..53e5cb7
--- /dev/null
+++ b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
@@ -0,0 +1,823 @@
+diff --git a/src/acpi/acpitables/acpitables.c b/src/acpi/acpitables/acpitables.c
+index 064dabe..99ac65a 100644
+--- a/src/acpi/acpitables/acpitables.c
++++ b/src/acpi/acpitables/acpitables.c
+@@ -14,7 +14,10 @@
+  *
+  */
+ #include "fwts.h"
+-
++#include "acpi.h"
++#include "accommon.h"
++#include "acnamesp.h"
++#include "actables.h"
+ #if defined(FWTS_HAS_ACPI)
+ 
+ #include <stdio.h>
+@@ -27,6 +30,12 @@
+ #include <unistd.h>
+ #include <inttypes.h>
+ 
++#define MIN_SIG 4
++#define OEM_ID 6
++#define OEM_TABLE_ID 8
++#define OEM_CREATOR_ID 4
++#define FADT_MAX_MAJOR_REVISION ((uint8_t)6)
++
+ static bool acpi_table_check_field(const char *field, const size_t len)
+ {
+ 	size_t i;
+@@ -106,7 +115,7 @@ static int acpi_table_check_test1(fwts_framework *fw)
+ 		passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, 4) &
+ 			 acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, 6) &
+ 			 acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, 8) &
+-			acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, 4);
++			 acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, 4);
+ 		if (passed)
+ 			fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
+ 
+@@ -116,9 +125,193 @@ static int acpi_table_check_test1(fwts_framework *fw)
+ 
+ 	return FWTS_OK;
+ }
++/* Callback function used when searching for processor devices in namespace. */
++ACPI_STATUS processor_handler(ACPI_HANDLE ObjHandle, uint32_t level, void *context,
++                              void **returnvalue)
++{
++	ACPI_NAMESPACE_NODE *node = (ACPI_NAMESPACE_NODE *)ObjHandle;
++	ACPI_NAMESPACE_NODE *parent = node->Parent;
++	int error_count;
++
++	/* Unused parameters trigger errors. */
++	FWTS_UNUSED(level);
++	FWTS_UNUSED(context);
++
++	/* If the processor device is not located under _SB_, increment the error_count. */
++	if (strncmp(parent->Name.Ascii, "_SB_", sizeof(int32_t)) != 0) {
++		error_count = *((int *)returnvalue);
++		error_count++;
++		*((int *)returnvalue) = error_count;
++	}
++
++	/* Return 0 so namespace search continues. */
++	return 0;
++}
++
++/* Test function that makes sure processors are under the _SB_ namespace. */
++static int acpi_namespace_check_test2(fwts_framework *fw)
++{
++	int error_count = 0;
++
++	/* Initializing ACPICA library so we can call AcpiWalkNamespace. */
++	if (fwts_acpica_init(fw) != FWTS_OK)
++		return FWTS_ERROR;
++
++	/* Searching for all processor devices in the namespace. */
++	AcpiWalkNamespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
++	                  processor_handler, NULL, NULL, (void **)&error_count);
++
++	/* Deinitializing ACPICA, if we don't call this the terminal will break on exit. */
++	fwts_acpica_deinit();
++
++	/* error_count variable counts the number of processors outside of the _SB_ namespace. */
++	if (error_count > 0)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiCpuWrongNamespace", "%d Processor devices "
++		            "were found outside of the _SB_ namespace.", error_count);
++	else
++		fwts_passed(fw, "All processor devices were located in the _SB_ namespace.");
++
++	return FWTS_OK;
++}
++
++static int acpi_table_check_test3(fwts_framework *fw)
++{
++	int i;
++	bool checked = false;
++	bool dsdt_checked = false;
++	bool ssdt_checked = false;
++
++	for (i = 0; ; i++) {
++		fwts_acpi_table_info *info;
++		fwts_acpi_table_header *hdr;
++		char name[50];
++		bool passed;
++
++		if (fwts_acpi_get_table(fw, i, &info) != FWTS_OK)
++			break;
++		if (info == NULL)
++			continue;
++
++		checked = true;
++		if (!strcmp(info->name, "DSDT") ||
++			!strcmp(info->name, "SSDT")) {
++			if (!strcmp(info->name, "DSDT")) {
++				dsdt_checked = true;
++			}
++			if (!strcmp(info->name, "SSDT")) {
++				ssdt_checked = true;
++			}
++			hdr = (fwts_acpi_table_header *)info->data;
++			if (acpi_table_check_field(hdr->signature, MIN_SIG)) {
++				snprintf(name, sizeof(name), "%4.4s", hdr->signature);
++			} else {
++				/* Table name not printable, so identify it by the address */
++				snprintf(name, sizeof(name), "at address 0x%" PRIx64, info->addr);
++			}
++
++			/*
++			 * Tables shouldn't be short, however, they do have at
++			 * least 4 bytes with their signature else they would not
++			 * have been loaded by this stage.
++			 */
++			if (hdr->length < sizeof(fwts_acpi_table_header)) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, "ACPITableHdrShort",
++					"ACPI Table %s is too short, only %d bytes long. Further "
++					"header checks will be omitted.", name, hdr->length);
++				continue;
++			}
++			/* Warn about empty tables */
++			if (hdr->length == sizeof(fwts_acpi_table_header)) {
++				fwts_warning(fw,
++					"ACPI Table %s is empty and just contains a table header. Further "
++					"header checks will be omitted.", name);
++				continue;
++			}
++
++			passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, MIN_SIG) &
++			    acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, OEM_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, OEM_TABLE_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, OEM_CREATOR_ID);
++			if (passed)
++				fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
++		}
++	}
++	if (!checked)
++		fwts_aborted(fw, "Cannot find any ACPI tables.");
++	if (!dsdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test DSDT table is NOT implemented.");
++	}
++	if (!ssdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test SSDT table is NOT implemented.");
++	}
++	if ((!dsdt_checked) || (!ssdt_checked))
++	  return FWTS_ERROR;
++
++	return FWTS_OK;
++}
++
++/* List of ACPI tables recommended by SBBR 4.2.2 */
++char *recommended_acpi_tables[] = {
++	"MCFG",
++	"IORT",
++	"BERT",
++	"EINJ",
++	"ERST",
++	"HEST",
++	"RASF",
++	"SPMI",
++	"SLIT",
++	"SRAT",
++	"CSRT",
++	"ECDT",
++	"MPST",
++	"PCCT",
++	NULL
++};
++
++/* Searches ACPI tables by signature. */
++fwts_acpi_table_info *sbbr_search_acpi_tables(fwts_framework *fw, char *signature)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	i = 0;
++	while (fwts_acpi_get_table(fw, i, &info) == FWTS_OK) {
++		if (info != NULL && strncmp(info->name, signature, sizeof(uint32_t)) == 0) {
++			return info;
++		}
++		i++;
++	}
++
++	return NULL;
++}
++
++static int acpi_table_check_test4(fwts_framework *fw)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	for (i = 0; recommended_acpi_tables[i] != NULL; i++) {
++		info = sbbr_search_acpi_tables(fw, recommended_acpi_tables[i]);
++		if (info == NULL) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiRecommendedTableNotFound",
++			            "SBBR Recommended ACPI table \"%s\" not found.",
++			            recommended_acpi_tables[i]);
++		} else {
++			fwts_passed(fw, "SBBR Recommended ACPI table \"%s\" found.",
++			            recommended_acpi_tables[i]);
++		}
++	}
++	return FWTS_OK;
++}
+ 
+ static fwts_framework_minor_test acpi_table_check_tests[] = {
+ 	{ acpi_table_check_test1, "Test ACPI headers." },
++	{ acpi_namespace_check_test2, "Test that processors only exist in the _SB namespace." },
++	{ acpi_table_check_test3, "Test DSDT and SSDT tables are implemented." },
++	{ acpi_table_check_test4, "Check for recommended ACPI tables." },
+ 	{ NULL, NULL }
+ };
+ 
+diff --git a/src/acpi/dbg2/dbg2.c b/src/acpi/dbg2/dbg2.c
+index 38ca65e..85b2bce 100644
+--- a/src/acpi/dbg2/dbg2.c
++++ b/src/acpi/dbg2/dbg2.c
+@@ -39,8 +39,8 @@ static int dbg2_init(fwts_framework *fw)
+ 		return FWTS_ERROR;
+ 	}
+ 	if (table == NULL || (table && table->length == 0)) {
+-		fwts_log_error(fw, "ACPI DBG2 table does not exist, skipping test");
+-		return FWTS_SKIP;
++		fwts_log_error(fw, "ACPI DBG2 table does not exist");
++		return FWTS_ERROR;
+ 	}
+ 
+ 	return FWTS_OK;
+diff --git a/src/acpi/fadt/fadt.c b/src/acpi/fadt/fadt.c
+index 533882d..903ade3 100644
+--- a/src/acpi/fadt/fadt.c
++++ b/src/acpi/fadt/fadt.c
+@@ -213,14 +213,9 @@ static int fadt_revision(fwts_framework *fw)
+ 	if (major == LATEST_MAJOR && minor == LATEST_MINOR)
+ 		fwts_passed(fw, "FADT revision is up to date.");
+ 	else {
+-		fwts_warning(fw, "FADT revision is outdated: %d.%d",
+-			     major, minor);
+-		fwts_advice(fw, "The most recent revision of the FADT "
+-			    "defined in the ACPI specification is %d.%d.  "
+-			    "While older revisions of the FADT can be used, "
+-			    "newer ones may enable additional functionality "
+-			    "that cannot be used until the FADT is updated.",
+-			    LATEST_MAJOR, LATEST_MINOR);
++		fwts_failed(fw, LOG_LEVEL_HIGH, "fadt_revision",
++		    "FADT revision Not up to date");
++		return FWTS_ERROR;
+ 	}
+ 
+ 	return FWTS_OK;
+@@ -1591,6 +1586,18 @@ static void acpi_table_check_fadt_sleep_status_reg(fwts_framework *fw)
+ 				    "will be ignored reduced hardware mode.");
+ 	}
+ }
++static int fadt_arm_boot_arch_psci_compliant_test(fwts_framework *fw)
++{
++	/* ARM SBBR 4.2.1.3 FADT */
++	if (fadt->arm_boot_flags &
++		FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT)
++		  fwts_passed(fw, "PSCI_COMPLIANT is set, PSCI is implemented.");
++	else
++	  fwts_failed(fw, LOG_LEVEL_MEDIUM,
++	      "FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT_flag is not set",
++	      "PSCI is NOT implemented.");
++	return FWTS_OK;
++}
+ 
+ static int fadt_test1(fwts_framework *fw)
+ {
+@@ -1829,6 +1836,7 @@ static fwts_framework_minor_test fadt_tests[] = {
+ 	{ fadt_test1, "ACPI FADT Description Table tests." },
+ 	{ fadt_test2, "Test FADT SCI_EN bit is enabled." },
+ 	{ fadt_test3, "Test FADT reset register." },
++	{ fadt_arm_boot_arch_psci_compliant_test, "Test ARM_BOOT_ARCH for psci compliance" },
+ 	{ NULL, NULL }
+ };
+ 
+diff --git a/src/acpi/method/method.c b/src/acpi/method/method.c
+index bc18224..5da9c3e 100644
+--- a/src/acpi/method/method.c
++++ b/src/acpi/method/method.c
+@@ -210,7 +210,7 @@
+  * _SLI 	 N
+  * _SPD 	 Y
+  * _SRS 	 n/a
+- * _SRT 	 n/a
++ * _SRT 	 Y
+  * _SRV 	 Y
+  * _SST 	 Y
+  * _STA 	 Y
+@@ -255,7 +255,7 @@
+  */
+ 
+ /* Test types */
+-#define	METHOD_MANDITORY	1
++#define	METHOD_MANDATORY	1
+ #define METHOD_OPTIONAL		2
+ #define METHOD_MOBILE		4
+ #define METHOD_SILENT		8
+@@ -548,7 +548,7 @@ static int method_evaluate_method(fwts_framework *fw,
+ 	} else {
+ 		if (!(test_type & METHOD_SILENT)) {
+ 			/* Manditory not-found test are a failure */
+-			if (test_type & METHOD_MANDITORY) {
++			if (test_type & METHOD_MANDATORY) {
+ 				fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodNotExist",
+ 					"Object %s did not exist.", name);
+ 			}
+@@ -2235,7 +2235,7 @@ static void method_test_CRS_return(
+ 
+ static int method_test_CRS(fwts_framework *fw)
+ {
+-	return method_evaluate_method(fw, METHOD_MANDITORY,
++	return method_evaluate_method(fw, METHOD_MANDATORY,
+ 		"_CRS", NULL, 0, method_test_CRS_return, "_CRS");
+ }
+ 
+@@ -4786,6 +4786,34 @@ static int method_test_CWS(fwts_framework *fw)
+ 	return ret;
+ }
+ 
++static void method_test_SRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value & ~0x1)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SRTReturn",
++			"%s returned %" PRId64 ", should be between 0 and 1, "
++			"one or more of the reserved bits 1..31 seem "
++			"to be set.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_SRT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SRT", NULL, 0, method_test_SRT_return, NULL);
++}
+ 
+ static int method_test_STP(fwts_framework *fw)
+ {
+@@ -6389,7 +6417,7 @@ static int method_test_PTS(fwts_framework *fw)
+ 
+ 		fwts_log_info(fw, "Test _PTS(%d).", i);
+ 
+-		if (method_evaluate_method(fw, METHOD_MANDITORY, "_PTS", arg, 1,
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_PTS", arg, 1,
+ 			method_test_NULL_return, NULL) == FWTS_NOT_EXIST) {
+ 			fwts_advice(fw,
+ 				"Could not find _PTS. This method provides a "
+@@ -6422,7 +6450,7 @@ static int method_test_TTS(fwts_framework *fw)
+ 			fwts_log_info(fw,
+ 				"Test _TTS(%d) Transition To State S%d.", i, i);
+ 
+-			if (method_evaluate_method(fw, METHOD_MANDITORY,
++			if (method_evaluate_method(fw, METHOD_MANDATORY,
+ 				"_TTS", arg, 1, method_test_NULL_return,
+ 				NULL) == FWTS_NOT_EXIST) {
+ 				fwts_advice(fw,
+@@ -6474,7 +6502,7 @@ static int method_test_WAK(fwts_framework *fw)
+ 		arg[0].Type = ACPI_TYPE_INTEGER;
+ 		arg[0].Integer.Value = i;
+ 		fwts_log_info(fw, "Test _WAK(%d) System Wake, State S%d.", i, i);
+-		if (method_evaluate_method(fw, METHOD_MANDITORY, "_WAK", arg, 1,
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_WAK", arg, 1,
+ 			method_test_WAK_return, &i) == FWTS_NOT_EXIST) {
+ 			fwts_advice(fw,
+ 				"Section 7.3.7 states that a system that wakes "
+@@ -6879,6 +6907,85 @@ static int method_test_SRV(fwts_framework *fw)
+ 		"_SRV", NULL, 0, method_test_integer_return, NULL);
+ }
+ 
++/* ARM SBBR Test Definitions */
++static int sbbr_method_test_ADR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_ADR", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_AEI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_AEI_return, NULL);
++}
++
++static int sbbr_method_test_CCA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_CCA", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_EVT(fwts_framework *fw)
++{
++	int ret;
++
++	/* Only test the _EVT method with pins defined in AEI. */
++	ret = method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_EVT_return, NULL);
++
++	if (ret == FWTS_NOT_EXIST)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiEvtDoesNotExist", "Method _EVT does not exist.");
++
++	return ret;
++}
++
++static int sbbr_method_test_HID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_HID", NULL, 0, method_test_HID_return, NULL);
++}
++
++static int sbbr_method_test_OSI(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_STRING;
++	arg[0].String.Pointer = "Linux";
++
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_OSI", arg, 1, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_SST(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int ret, i;
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	for (i = 0; i <= 4; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_MANDATORY,
++			"_SST", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static int sbbr_method_test_STA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_STA", NULL, 0, method_test_STA_return, "_STA");
++}
++
++static int sbbr_method_test_UID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_UID", NULL, 0, method_test_UID_return, NULL);
++}
++
+ /*
+  * Tests
+  */
+@@ -7081,7 +7188,7 @@ static fwts_framework_minor_test method_tests[] = {
+ 	{ method_test_GRT, "Test _GRT (Get Real Time)." },
+ 	{ method_test_GWS, "Test _GWS (Get Wake Status)." },
+ 	{ method_test_CWS, "Test _CWS (Clear Wake Status)." },
+-	/* { method_test_SRT, "Test _SRT (Set Real Time)." }, */
++	{ method_test_SRT, "Test _SRT (Set Real Time)." },
+ 	{ method_test_STP, "Test _STP (Set Expired Timer Wake Policy)." },
+ 	{ method_test_STV, "Test _STV (Set Timer Value)." },
+ 	{ method_test_TIP, "Test _TIP (Expired Timer Wake Policy)." },
+@@ -7196,6 +7303,17 @@ static fwts_framework_minor_test method_tests[] = {
+ 	{ method_test_IFT, "Test _IFT (IPMI Interface Type)." },
+ 	{ method_test_SRV, "Test _SRV (IPMI Interface Revision)." },
+ 
++	/* From ARM SBBR */
++	{ sbbr_method_test_ADR, "SBBR Test _ADR (Return Unique ID for Device)." },
++	{ sbbr_method_test_AEI, "SBBR Test _AEI (Event Information)." },
++	{ sbbr_method_test_CCA, "SBBR Test _CCA (Cache Coherency Attribute)." },
++	{ sbbr_method_test_EVT, "SBBR Test _EVT (Event Method)." },
++	{ sbbr_method_test_HID, "SBBR Test _HID (Hardware ID)." },
++	{ sbbr_method_test_OSI, "SBBR Test _OSI (Operating System Interfaces)." },
++	{ sbbr_method_test_SST, "SBBR Test _SST (System Status)." },
++	{ sbbr_method_test_STA, "SBBR Test _STA (Status)." },
++	{ sbbr_method_test_UID, "SBBR Test _UID (Unique ID)." },
++
+ 	/* End! */
+ 
+ 	{ NULL, NULL }
+diff --git a/src/acpi/rsdp/rsdp.c b/src/acpi/rsdp/rsdp.c
+index f7e10bb..09ec1be 100644
+--- a/src/acpi/rsdp/rsdp.c
++++ b/src/acpi/rsdp/rsdp.c
+@@ -123,6 +123,17 @@ static int rsdp_test1(fwts_framework *fw)
+ 			    "RSDP: at least one of RsdtAddress or XsdtAddress "
+ 			    "is non-zero.");
+ 
++	/* ARM SBBR 4.2.1.1  RSDP */
++	if ((rsdp->rsdt_address == 0) && (rsdp->xsdt_address != 0))
++		fwts_passed(fw,
++				"RSDP: the RsdtAddress is zero "
++				"and the XsdtAddress is non-zero.");
++	else
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++				"RSDPNoAddressesFound",
++				"RSDP: the RsdtAddress must be zero "
++				"and the XsdtAddress must be non-zero.");
++
+ 	if (rsdp->rsdt_address && rsdp->xsdt_address) {
+ 		fwts_log_warning(fw, "NOTE: The RSDT and XSDT are both "
+ 			"defined. An operating system supporting ACPI "
+diff --git a/src/acpi/spcr/spcr.c b/src/acpi/spcr/spcr.c
+index 26cae54..e100ff3 100644
+--- a/src/acpi/spcr/spcr.c
++++ b/src/acpi/spcr/spcr.c
+@@ -39,8 +39,8 @@ static int spcr_init(fwts_framework *fw)
+ 		return FWTS_ERROR;
+ 	}
+ 	if (table == NULL || (table && table->length == 0)) {
+-		fwts_log_error(fw, "ACPI SPCR table does not exist, skipping test");
+-		return FWTS_SKIP;
++		fwts_log_error(fw, "ACPI SPCR table does not exist");
++		return FWTS_ERROR;
+ 	}
+ 	spcr = (const fwts_acpi_table_spcr*)table->data;
+ 
+diff --git a/src/acpi/xsdt/xsdt.c b/src/acpi/xsdt/xsdt.c
+index 032f1a1..7042a59 100644
+--- a/src/acpi/xsdt/xsdt.c
++++ b/src/acpi/xsdt/xsdt.c
+@@ -45,6 +45,8 @@ static int xsdt_init(fwts_framework *fw)
+ 
+ /*
+  *  XSDT Extended System Description Table
++ *
++ *  ARM SBBR 4.2.1.2 XSDT
+  */
+ static int xsdt_test1(fwts_framework *fw)
+ {
+@@ -68,7 +70,8 @@ static int xsdt_test1(fwts_framework *fw)
+ 		}
+ 	}
+ 	if (passed)
+-		fwts_passed(fw, "No issues found in XSDT table.");
++		fwts_passed(fw, "No issues found in XSDT table."
++		    "Number of tables pointed by XSDT = %d", (int)n);
+ 
+ 	return FWTS_OK;
+ }
+diff --git a/src/dmi/dmicheck/dmicheck.c b/src/dmi/dmicheck/dmicheck.c
+index 1934ebe..d00411c 100644
+--- a/src/dmi/dmicheck/dmicheck.c
++++ b/src/dmi/dmicheck/dmicheck.c
+@@ -313,12 +313,15 @@ static int dmi_load_file(const char* filename, void *buf, size_t size)
+ 
+ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ {
+-	off_t addr = (off_t)entry->struct_table_address;
+ 	size_t length = (size_t)entry->struct_table_length;
+ 	void *table;
+-	void *mem;
+ 	char anchor[8];
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
++	off_t addr = (off_t)entry->struct_table_address;
++	void *mem;
++	#endif
++
+ 	/* 32 bit entry sanity check on length */
+ 	if ((length == 0) || (length > 0xffff)) {
+ 		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
+@@ -326,6 +329,7 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 		return NULL;
+ 	}
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
+ 	mem = fwts_mmap(addr, length);
+ 	if (mem != FWTS_MAP_FAILED) {
+ 		table = malloc(length);
+@@ -334,6 +338,7 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 		(void)fwts_munmap(mem, length);
+ 		return table;
+ 	}
++	#endif
+ 
+ 	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, 4) == FWTS_OK
+ 			&& strncmp(anchor, "_SM_", 4) == 0) {
+@@ -354,12 +359,15 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 
+ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ {
+-	off_t addr = (off_t)entry->struct_table_address;
+ 	size_t length = (size_t)entry->struct_table_max_size;
+ 	void *table;
+-	void *mem;
+ 	char anchor[8];
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
++	off_t addr = (off_t)entry->struct_table_address;
++	void *mem;
++	#endif
++
+ 	/* 64 bit entry sanity check on length */
+ 	if ((length == 0) || (length > 0xffffff)) {
+ 		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
+@@ -367,6 +375,7 @@ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ 		return NULL;
+ 	}
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
+ 	mem = fwts_mmap(addr, length);
+ 	if (mem != FWTS_MAP_FAILED) {
+ 		table = malloc(length);
+@@ -375,6 +384,7 @@ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ 		(void)fwts_munmap(mem, length);
+ 		return table;
+ 	}
++	#endif
+ 
+ 	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, 5) == FWTS_OK
+ 			&& strncmp(anchor, "_SM3_", 5) == 0) {
+@@ -1877,10 +1887,15 @@ static int dmicheck_test3(fwts_framework *fw)
+ 	return FWTS_OK;
+ }
+ 
++static int sbbr_smbios30_locate_structure (fwts_framework *fw, fwts_smbios30_entry *entry,
++	                                       uint8_t *table, uint8_t type, fwts_dmi_header *hdr);
++static int sbbr_smbios_test(fwts_framework *fw);
++
+ static fwts_framework_minor_test dmicheck_tests[] = {
+ 	{ dmicheck_test1, "Find and test SMBIOS Table Entry Points." },
+ 	{ dmicheck_test2, "Test DMI/SMBIOS tables for errors." },
+ 	{ dmicheck_test3, "Test DMI/SMBIOS3 tables for errors." },
++	{ sbbr_smbios_test, "Test ARM SBBR SMBIOS structure requirements."},
+ 	{ NULL, NULL }
+ };
+ 
+@@ -1892,3 +1907,124 @@ static fwts_framework_ops dmicheck_ops = {
+ FWTS_REGISTER("dmicheck", &dmicheck_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_BATCH | FWTS_FLAG_ROOT_PRIV)
+ 
+ #endif
++
++/*
++ * ARM SBBR SMBIOS Structure Test
++ */
++
++/* Test Entry Structure */
++typedef struct {
++	const char *name;
++	const uint8_t type;
++} sbbr_test_entry;
++
++/* Test Definition Array */
++sbbr_test_entry sbbr_test[] = {
++	{"BIOS Information", 0},
++	{"System Information", 1},
++	{"Baseboard Information", 2},
++	{"System Enclosure or Chassis", 3},
++	{"Processor Information", 4},
++	{"Cache Information", 7},
++	{"Port Connector Information", 8},
++	{"System Slots", 9},
++	{"OEM Strings", 11},
++	{"BIOS Language Information", 13},
++	{"System Event Log", 15},
++	{"Physical Memory Array", 16},
++	{"Memory Device", 17},
++	{"Memory Array Mapped Address", 19},
++	{"System Boot Information", 32},
++	{"IPMI Device Information", 38},
++	{"Onboard Devices Extended Information", 41},
++	{0, 0}
++};
++
++#define HEADER_TYPE_OFFSET 0
++#define HEADER_LENGTH_OFFSET 1
++#define HEADER_HANDLE_OFFSET 2
++
++/* Finds SMBIOS structure of a given type in an SMBIOS30 table. */
++static int sbbr_smbios30_locate_structure (fwts_framework *fw, fwts_smbios30_entry *entry,
++	                                       uint8_t *table, uint8_t type, fwts_dmi_header *hdr){
++	uint8_t *entry_data = table;
++	uint16_t table_max_length;
++	int i = 0;
++	uint8_t *next_entry;
++	table_max_length = entry->struct_table_max_size;
++
++	for (i = 0; entry_data <= (table + table_max_length - 4); i++) {
++
++		hdr->type   = entry_data[0];
++		hdr->length = entry_data[1];
++		hdr->handle = GET_UINT16(entry_data + 2);
++		hdr->data   = entry_data;
++
++		/* We found the entry we're looking for. */
++		if (hdr->type == type)
++			return FWTS_OK;
++
++		/* We found DMI end of table */
++		if (hdr->type == SMBIOS_END_OF_TABLE)
++			return FWTS_ERROR;
++
++		/* Real Physical Address */
++		next_entry = entry_data + hdr->length;
++
++		/* Look for structure terminator, ends in two zero bytes */
++		while (((next_entry - table + 1) < table_max_length) && ((next_entry[0] != 0) || (next_entry[1] != 0)))
++			next_entry++;
++
++		/* Skip over terminating two zero bytes, see section 6.1 of spec */
++		next_entry += 2;
++
++		if ((next_entry - table) > table_max_length){
++			fwts_failed(fw, LOG_LEVEL_HIGH, DMI_BAD_TABLE_LENGTH,
++				"DMI table maximum size was %" PRId32 " bytes (as specified by "
++				"the SMBIOS 3.0 header) but the DMI entries over the maximum "
++				"length without finding the End-of-Table(Type 127).",
++				table_max_length);
++			break;
++		}
++
++		entry_data = next_entry;
++	}
++	return FWTS_ERROR;
++}
++
++/* SBBR SMBIOS structure test function. */
++static int sbbr_smbios_test(fwts_framework *fw)
++{
++	fwts_smbios30_entry entry;
++	fwts_dmi_header hdr;
++	uint16_t version;
++	void *addr;
++	uint32_t i;
++	uint8_t *table;
++
++	/* Finding SMBIOS30 entry point. */
++	addr = fwts_smbios30_find_entry(fw, &entry, &version);
++	if (addr == NULL) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoTable", "Cannot find SMBIOS30 table "
++		            "entry.");
++		return FWTS_ERROR;
++	}
++
++	/* Getting SMBIOS table contents. */
++	table = dmi_table_smbios30(fw, &entry);
++	if (table == NULL)
++		return FWTS_ERROR;
++
++	/* Searching for each SMBIOS structure needed by SBBR. */
++	for (i = 0; sbbr_test[i].name != NULL; i++) {
++		if (sbbr_smbios30_locate_structure(fw, &entry, table, sbbr_test[i].type, &hdr) == FWTS_OK)
++			dmicheck_entry(fw, (uintptr_t)hdr.data, &hdr);
++		else
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoStruct", "Cannot find SMBIOS "
++			            "structure: %s (Type %d)", sbbr_test[i].name, sbbr_test[i].type);
++	}
++
++	dmi_table_free(table);
++
++	return FWTS_OK;
++}
+diff --git a/src/lib/src/fwts_smbios.c b/src/lib/src/fwts_smbios.c
+index 21263b4..0ed57eb 100644
+--- a/src/lib/src/fwts_smbios.c
++++ b/src/lib/src/fwts_smbios.c
+@@ -52,6 +52,8 @@ static void *fwts_smbios_find_entry_uefi(fwts_framework *fw, fwts_smbios_entry *
+ 	void *addr;
+ 
+ 	if ((addr = fwts_scan_efi_systab("SMBIOS")) != NULL) {
++
++		#if !defined(FWTS_ARCH_AARCH64)
+ 		fwts_smbios_entry *mapped_entry;
+ 
+ 		if ((mapped_entry = fwts_mmap((off_t)addr, sizeof(fwts_smbios_entry))) != FWTS_MAP_FAILED) {
+@@ -60,6 +62,7 @@ static void *fwts_smbios_find_entry_uefi(fwts_framework *fw, fwts_smbios_entry *
+ 			*type  = FWTS_SMBIOS;
+ 			return addr;
+ 		}
++		#endif
+ 
+ 		if (fwts_load_file("/sys/firmware/dmi/tables/smbios_entry_point",
+ 				entry, sizeof(fwts_smbios_entry)) == FWTS_OK && !strncmp((char*)entry, "_SM_", 4)) {
+@@ -82,13 +85,16 @@ static void *fwts_smbios30_find_entry_uefi(fwts_framework *fw, fwts_smbios30_ent
+ 	void *addr;
+ 
+ 	if ((addr = fwts_scan_efi_systab("SMBIOS3")) != NULL) {
+-		fwts_smbios30_entry *mapped_entry;
+ 
++		#if !defined(FWTS_ARCH_AARCH64)
++		fwts_smbios30_entry *mapped_entry;
++		
+ 		if ((mapped_entry = fwts_mmap((off_t)addr, sizeof(fwts_smbios30_entry))) != FWTS_MAP_FAILED) {
+ 			*entry = *mapped_entry;
+ 			(void)fwts_munmap(mapped_entry, sizeof(fwts_smbios30_entry));
+ 			return addr;
+ 		}
++		#endif
+ 
+ 		if (fwts_load_file("/sys/firmware/dmi/tables/smbios_entry_point",
+ 				entry, sizeof(fwts_smbios30_entry)) == FWTS_OK && !strncmp((char*)entry, "_SM3_", 5)) {
diff --git a/meta-luv/recipes-core/fwts/fwts_git.bb b/meta-luv/recipes-core/fwts/fwts_git.bb
index 73e6b61..5a2a5b1 100644
--- a/meta-luv/recipes-core/fwts/fwts_git.bb
+++ b/meta-luv/recipes-core/fwts/fwts_git.bb
@@ -4,11 +4,12 @@ HOMEPAGE = "https://wiki.ubuntu.com/Kernel/Reference/fwts"
 LICENSE = "GPLv2+"
 LIC_FILES_CHKSUM = "file://src/main.c;beginline=1;endline=16;md5=31da590f3e9f3bd34dcdb9e4db568519"
 
-PV = "V16.09.00+git${SRCPV}"
+PV = "V16.11.00+git${SRCPV}"
 
-SRCREV = "7fd1834a879f27647b371c18284868c9a54f6474"
+SRCREV = "e2ed99a74c06f62e3bb7ab1dcb4c344f5abc3a29"
 SRC_URI = "git://kernel.ubuntu.com/hwe/fwts.git \
            file://luv-parser-fwts \
+           file://sbbr.patch \
           "
 
 S = "${WORKDIR}/git"
diff --git a/meta-luv/recipes-core/images/luv-live-image.bb b/meta-luv/recipes-core/images/luv-live-image.bb
index 20c2194..8464c8c 100644
--- a/meta-luv/recipes-core/images/luv-live-image.bb
+++ b/meta-luv/recipes-core/images/luv-live-image.bb
@@ -12,11 +12,11 @@ INITRD = "${DEPLOY_DIR_IMAGE}/${INITRD_IMAGE}-${MACHINE}.cpio.gz"
 MACHINE_FEATURES += "efi"
 APPEND = "debug crashkernel=256M console=ttyS0,115200 console=ttyPCH0,115200 ip=dhcp log_buf_len=1M"
 APPEND_netconsole = "luv_netconsole=10.11.12.13,64001"
-APPEND_aarch64 = "crashkernel=256M console=ttyAMA0 uefi_debug acpi=force"
+APPEND_aarch64 = "crashkernel=256M earlycon uefi_debug acpi=force"
 
 SPLASH_IMAGE = "blue-luv.jpg"
 
-GRUB_TIMEOUT = "2"
+GRUB_TIMEOUT = "1"
 
 inherit bootimg
 
@@ -32,8 +32,8 @@ build_img() {
     # Sectors: 512 bytes
     # Blocks: 1024 bytes
     VFAT_RESULTS=${DEPLOY_DIR_IMAGE}/${PN}-results.hddimg
-    # 16MB of space for test results
-    VFAT_RESULTS_SPACE=16777216
+    # 128 MB of space for test results and SCT installation
+    VFAT_RESULTS_SPACE=134217728
     VFAT_RESULTS_BLOCKS=$(expr $VFAT_RESULTS_SPACE / 1024)
     # TODO: do we need to dynamically generate the UUID?
     # For now, every time this UUID changes, the file etc/init.d/luv-test-manager
diff --git a/meta-luv/recipes-core/images/luv-netboot-image.bb b/meta-luv/recipes-core/images/luv-netboot-image.bb
index 0fc7333..0962380 100644
--- a/meta-luv/recipes-core/images/luv-netboot-image.bb
+++ b/meta-luv/recipes-core/images/luv-netboot-image.bb
@@ -1,7 +1,7 @@
 LICENSE = "MIT"
 LIC_FILES_CHKSUM = "file://${COREBASE}/LICENSE;md5=4d92cd373abda3937c2bc47fbc49d690"
 
-DEPENDS_${PN} = "bits"
+DEPENDS_${PN} = "bits sbbr"
 
 INITRD_IMAGE = "core-image-efi-initramfs"
 INITRD = "${DEPLOY_DIR_IMAGE}/${INITRD_IMAGE}-${MACHINE}.cpio.gz"
@@ -15,7 +15,7 @@ PCBIOS_append = "0"
 
 APPEND = "debug crashkernel=256M console=ttyS0,115200 console=ttyPCH0,115200 luv.netboot ip=dhcp log_buf_len=1M"
 APPEND_netconsole = "luv_netconsole=10.11.12.13,64001"
-APPEND_aarch64 = "crashkernel=256M console=ttyAMA0 uefi_debug acpi=force luv.netboot"
+APPEND_aarch64 = "crashkernel=256M earlycon uefi_debug acpi=force luv.netboot"
 
 HDDDIR = "${S}/hddimg"
 
@@ -33,7 +33,8 @@ do_mkimage[depends] += "${EXTRABOOTIMGDEPS} \
                         mtools-native:do_populate_sysroot \
                         cdrtools-native:do_populate_sysroot \
                         virtual/kernel:do_deploy \
-			${_BITSDEPENDS}"
+                        ${_BITSDEPENDS} \
+                        ${_SBBRDEPENDS}"
 
 do_bootimg[noexec] = "1"
 
@@ -42,7 +43,8 @@ do_populate_image() {
 	if [ "${TARGET_ARCH}" != "aarch64" ]; then
 		efi_populate_bits ${HDDDIR}
 	else
-		echo "bootaa64.efi" > ${HDDDIR}${EFIDIR}/startup.nsh
+		efi_populate_sbbr ${HDDDIR}
+		efi_populate_sbsa ${HDDDIR}
 		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${HDDDIR}${EFIDIR}
 	fi
 	install -m 0644 ${GRUBCFG} ${HDDDIR}${EFIDIR}
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/0005-ACPI-Console-Through-SPCR-Table.patch b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/0005-ACPI-Console-Through-SPCR-Table.patch
new file mode 100644
index 0000000..19ad9e8
--- /dev/null
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/0005-ACPI-Console-Through-SPCR-Table.patch
@@ -0,0 +1,419 @@
+From 55148bc607319db1f439fdff3ac76923e20b4283 Mon Sep 17 00:00:00 2001
+From: Supreeth Venkatesh <supreeth.venkatesh@arm.com>
+Date: Sat, 3 Dec 2016 01:14:00 +0000
+Subject: [PATCH] ACPI: Console Through SPCR Table.
+
+---
+ arch/arm64/Kconfig              |   1 +
+ arch/arm64/kernel/acpi.c        |  12 ++++-
+ drivers/acpi/Kconfig            |   3 ++
+ drivers/acpi/Makefile           |   1 +
+ drivers/acpi/spcr.c             | 111 ++++++++++++++++++++++++++++++++++++++++
+ drivers/of/fdt.c                |  10 +---
+ drivers/tty/serial/amba-pl011.c |  54 +++++++++++++++++++
+ drivers/tty/serial/earlycon.c   |  19 ++++++-
+ include/linux/acpi.h            |   6 +++
+ include/linux/of_fdt.h          |   3 ++
+ include/linux/serial_core.h     |   9 +++-
+ 11 files changed, 216 insertions(+), 13 deletions(-)
+ create mode 100644 drivers/acpi/spcr.c
+
+diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
+index 5a0a691..cc78080 100644
+--- a/arch/arm64/Kconfig
++++ b/arch/arm64/Kconfig
+@@ -3,6 +3,7 @@ config ARM64
+ 	select ACPI_CCA_REQUIRED if ACPI
+ 	select ACPI_GENERIC_GSI if ACPI
+ 	select ACPI_REDUCED_HARDWARE_ONLY if ACPI
++	select ACPI_SPCR_TABLE if ACPI
+ 	select ARCH_HAS_DEVMEM_IS_ALLOWED
+ 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
+ 	select ARCH_HAS_ELF_RANDOMIZE
+diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
+index 3e4f1a4..191acdd 100644
+--- a/arch/arm64/kernel/acpi.c
++++ b/arch/arm64/kernel/acpi.c
+@@ -24,6 +24,7 @@
+ #include <linux/memblock.h>
+ #include <linux/of_fdt.h>
+ #include <linux/smp.h>
++#include <linux/serial_core.h>
+ 
+ #include <asm/cputype.h>
+ #include <asm/cpu_ops.h>
+@@ -206,7 +207,7 @@ void __init acpi_boot_table_init(void)
+ 	if (param_acpi_off ||
+ 	    (!param_acpi_on && !param_acpi_force &&
+ 	     of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
+-		return;
++		goto done;;
+ 
+ 	/*
+ 	 * ACPI is disabled at this point. Enable it in order to parse
+@@ -226,6 +227,15 @@ void __init acpi_boot_table_init(void)
+ 		if (!param_acpi_force)
+ 			disable_acpi();
+ 	}
++
++done:
++	if (acpi_disabled) {
++		if (earlycon_init_is_deferred)
++			early_init_dt_scan_chosen_stdout();
++	} else {
++		parse_spcr(earlycon_init_is_deferred);
++	}
++
+ }
+ 
+ #ifdef CONFIG_ACPI_APEI
+diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
+index b7e2e77..89218ea 100644
+--- a/drivers/acpi/Kconfig
++++ b/drivers/acpi/Kconfig
+@@ -77,6 +77,9 @@ config ACPI_DEBUGGER_USER
+ 
+ endif
+ 
++config ACPI_SPCR_TABLE
++	bool
++
+ config ACPI_SLEEP
+ 	bool
+ 	depends on SUSPEND || HIBERNATION
+diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
+index 251ce85..43cde68 100644
+--- a/drivers/acpi/Makefile
++++ b/drivers/acpi/Makefile
+@@ -81,6 +81,7 @@ obj-$(CONFIG_ACPI_EC_DEBUGFS)	+= ec_sys.o
+ obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o
+ obj-$(CONFIG_ACPI_BGRT)		+= bgrt.o
+ obj-$(CONFIG_ACPI_CPPC_LIB)	+= cppc_acpi.o
++obj-$(CONFIG_ACPI_SPCR_TABLE)	+= spcr.o
+ obj-$(CONFIG_ACPI_DEBUGGER_USER) += acpi_dbg.o
+ 
+ # processor has its own "processor." module_param namespace
+diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
+new file mode 100644
+index 0000000..01c0e15
+--- /dev/null
++++ b/drivers/acpi/spcr.c
+@@ -0,0 +1,111 @@
++/*
++ * Copyright (c) 2012, Intel Corporation
++ * Copyright (c) 2015, Red Hat, Inc.
++ * Copyright (c) 2015, 2016 Linaro Ltd.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ */
++
++#define pr_fmt(fmt) "ACPI: SPCR: " fmt
++
++#include <linux/acpi.h>
++#include <linux/console.h>
++#include <linux/kernel.h>
++#include <linux/serial_core.h>
++
++/**
++ * parse_spcr() - parse ACPI SPCR table and add preferred console
++ *
++ * @earlycon: set up earlycon for the console specified by the table
++ *
++ * For the architectures with support for ACPI, CONFIG_ACPI_SPCR_TABLE may be
++ * defined to parse ACPI SPCR table.  As a result of the parsing preferred
++ * console is registered and if @earlycon is true, earlycon is set up.
++ *
++ * When CONFIG_ACPI_SPCR_TABLE is defined, this function should be called
++ * from arch inintialization code as soon as the DT/ACPI decision is made.
++ *
++ */
++int __init parse_spcr(bool earlycon)
++{
++	static char opts[64];
++	struct acpi_table_spcr *table;
++	acpi_size table_size;
++	acpi_status status;
++	char *uart;
++	char *iotype;
++	int baud_rate;
++	int err;
++
++	if (acpi_disabled)
++		return -ENODEV;
++
++	status = acpi_get_table_with_size(ACPI_SIG_SPCR, 0,
++					  (struct acpi_table_header **)&table,
++					  &table_size);
++
++	if (ACPI_FAILURE(status))
++		return -ENOENT;
++
++	if (table->header.revision < 2) {
++		err = -ENOENT;
++		pr_err("wrong table version\n");
++		goto done;
++	}
++
++	iotype = table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY ?
++			"mmio" : "io";
++
++	switch (table->interface_type) {
++	case ACPI_DBG2_ARM_SBSA_32BIT:
++		iotype = "mmio32";
++		/* fall through */
++	case ACPI_DBG2_ARM_PL011:
++	case ACPI_DBG2_ARM_SBSA_GENERIC:
++	case ACPI_DBG2_BCM2835:
++		uart = "pl011";
++		break;
++	case ACPI_DBG2_16550_COMPATIBLE:
++	case ACPI_DBG2_16550_SUBSET:
++		uart = "uart";
++		break;
++	default:
++		err = -ENOENT;
++		goto done;
++	}
++
++	switch (table->baud_rate) {
++	case 3:
++		baud_rate = 9600;
++		break;
++	case 4:
++		baud_rate = 19200;
++		break;
++	case 6:
++		baud_rate = 57600;
++		break;
++	case 7:
++		baud_rate = 115200;
++		break;
++	default:
++		err = -ENOENT;
++		goto done;
++	}
++
++	snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
++		 table->serial_port.address, baud_rate);
++
++	pr_info("console: %s\n", opts);
++
++	if (earlycon)
++		setup_earlycon(opts);
++
++	err = add_preferred_console(uart, 0, opts + strlen(uart) + 1);
++
++done:
++	early_acpi_os_unmap_memory((void __iomem *)table, table_size);
++	return err;
++}
+diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
+index 33daffc..bc8d9e2 100644
+--- a/drivers/of/fdt.c
++++ b/drivers/of/fdt.c
+@@ -904,7 +904,7 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
+ 
+ #ifdef CONFIG_SERIAL_EARLYCON
+ 
+-static int __init early_init_dt_scan_chosen_serial(void)
++int __init early_init_dt_scan_chosen_stdout(void)
+ {
+ 	int offset;
+ 	const char *p, *q, *options = NULL;
+@@ -949,14 +949,6 @@ static int __init early_init_dt_scan_chosen_serial(void)
+ 	return -ENODEV;
+ }
+ 
+-static int __init setup_of_earlycon(char *buf)
+-{
+-	if (buf)
+-		return 0;
+-
+-	return early_init_dt_scan_chosen_serial();
+-}
+-early_param("earlycon", setup_of_earlycon);
+ #endif
+ 
+ /**
+diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
+index 1b7331e..fa7c5fa 100644
+--- a/drivers/tty/serial/amba-pl011.c
++++ b/drivers/tty/serial/amba-pl011.c
+@@ -2288,6 +2288,60 @@ static int __init pl011_console_setup(struct console *co, char *options)
+ 	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
+ }
+ 
++/**
++ *	pl011_console_match - non-standard console matching
++ *	@co:	  registering console
++ *	@name:	  name from console command line
++ *	@idx:	  index from console command line
++ *	@options: ptr to option string from console command line
++ *
++ *	Only attempts to match console command lines of the form:
++ *	    console=pl011,mmio|mmio32,<addr>[,<options>]
++ *	    console=pl011,0x<addr>[,<options>]
++ *	This form is used to register an initial earlycon boot console and
++ *	replace it with the amba_console at pl011 driver init.
++ *
++ *	Performs console setup for a match (as required by interface)
++ *	If no <options> are specified, then assume the h/w is already setup.
++ *
++ *	Returns 0 if console matches; otherwise non-zero to use default matching
++ */
++static int __init pl011_console_match(struct console *co, char *name, int idx,
++				      char *options)
++{
++	unsigned char iotype;
++	unsigned long addr;
++	int i;
++
++	if (strcmp(name, "pl011") != 0)
++		return -ENODEV;
++
++	if (uart_parse_earlycon(options, &iotype, &addr, &options))
++		return -ENODEV;
++
++	if (iotype != UPIO_MEM && iotype != UPIO_MEM32)
++		return -ENODEV;
++
++	/* try to match the port specified on the command line */
++	for (i = 0; i < ARRAY_SIZE(amba_ports); i++) {
++		struct uart_port *port;
++
++		if (!amba_ports[i])
++			continue;
++
++		port = &amba_ports[i]->port;
++
++		if (port->mapbase != addr)
++			continue;
++
++		co->index = i;
++		port->cons = co;
++		return pl011_console_setup(co, options);
++	}
++
++	return -ENODEV;
++}
++
+ static struct uart_driver amba_reg;
+ static struct console amba_console = {
+ 	.name		= "ttyAMA",
+diff --git a/drivers/tty/serial/earlycon.c b/drivers/tty/serial/earlycon.c
+index 067783f..ea00b9f 100644
+--- a/drivers/tty/serial/earlycon.c
++++ b/drivers/tty/serial/earlycon.c
+@@ -21,6 +21,7 @@
+ #include <linux/sizes.h>
+ #include <linux/of.h>
+ #include <linux/of_fdt.h>
++#include <linux/acpi.h>
+ 
+ #ifdef CONFIG_FIX_EARLYCON_MEM
+ #include <asm/fixmap.h>
+@@ -199,6 +200,14 @@ int __init setup_earlycon(char *buf)
+ 	return -ENOENT;
+ }
+ 
++/*
++ * When CONFIG_ACPI_SPCR_TABLE is defined, "earlycon" without parameters in
++ * command line does not start DT earlycon immediately, instead it defers
++ * starting it until DT/ACPI decision is made.  At that time if ACPI is enabled
++ * call parse_spcr(), else call early_init_dt_scan_chosen_stdout()
++ */
++bool earlycon_init_is_deferred __initdata;
++
+ /* early_param wrapper for setup_earlycon() */
+ static int __init param_setup_earlycon(char *buf)
+ {
+@@ -208,8 +217,14 @@ static int __init param_setup_earlycon(char *buf)
+ 	 * Just 'earlycon' is a valid param for devicetree earlycons;
+ 	 * don't generate a warning from parse_early_params() in that case
+ 	 */
+-	if (!buf || !buf[0])
+-		return 0;
++	if (!buf || !buf[0]) {
++		if (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) {
++			earlycon_init_is_deferred = true;
++			return 0;
++		} else {
++			return early_init_dt_scan_chosen_stdout();
++		}
++	}
+ 
+ 	err = setup_earlycon(buf);
+ 	if (err == -ENOENT || err == -EALREADY)
+diff --git a/include/linux/acpi.h b/include/linux/acpi.h
+index 288fac5..1de43be 100644
+--- a/include/linux/acpi.h
++++ b/include/linux/acpi.h
+@@ -997,4 +997,10 @@ static inline struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
+ #define acpi_probe_device_table(t)	({ int __r = 0; __r;})
+ #endif
+ 
++#ifdef CONFIG_ACPI_SPCR_TABLE
++int parse_spcr(bool earlycon);
++#else
++static inline int parse_spcr(bool earlycon) { return 0; }
++#endif
++
+ #endif	/*_LINUX_ACPI_H*/
+diff --git a/include/linux/of_fdt.h b/include/linux/of_fdt.h
+index 901ec01..11eb9a7 100644
+--- a/include/linux/of_fdt.h
++++ b/include/linux/of_fdt.h
+@@ -14,6 +14,7 @@
+ 
+ #include <linux/types.h>
+ #include <linux/init.h>
++#include <linux/errno.h>
+ 
+ /* Definitions used by the flattened device tree */
+ #define OF_DT_HEADER		0xd00dfeed	/* marker */
+@@ -64,6 +65,7 @@ extern int early_init_dt_scan_chosen(unsigned long node, const char *uname,
+ 				     int depth, void *data);
+ extern int early_init_dt_scan_memory(unsigned long node, const char *uname,
+ 				     int depth, void *data);
++extern int early_init_dt_scan_chosen_stdout(void);
+ extern void early_init_fdt_scan_reserved_mem(void);
+ extern void early_init_fdt_reserve_self(void);
+ extern void early_init_dt_add_memory_arch(u64 base, u64 size);
+@@ -92,6 +94,7 @@ extern void early_get_first_memblock_info(void *, phys_addr_t *);
+ extern u64 of_flat_dt_translate_address(unsigned long node);
+ extern void of_fdt_limit_memory(int limit);
+ #else /* CONFIG_OF_FLATTREE */
++static inline int early_init_dt_scan_chosen_stdout(void) { return -ENODEV; }
+ static inline void early_init_fdt_scan_reserved_mem(void) {}
+ static inline void early_init_fdt_reserve_self(void) {}
+ static inline const char *of_flat_dt_get_machine_name(void) { return NULL; }
+diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
+index a3d7c0d..926c416 100644
+--- a/include/linux/serial_core.h
++++ b/include/linux/serial_core.h
+@@ -361,11 +361,18 @@ extern const struct earlycon_id __earlycon_table_end[];
+ 
+ #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
+ 
+-extern int setup_earlycon(char *buf);
+ extern int of_setup_earlycon(const struct earlycon_id *match,
+ 			     unsigned long node,
+ 			     const char *options);
+ 
++#ifdef CONFIG_SERIAL_EARLYCON
++extern bool earlycon_init_is_deferred __initdata;
++int setup_earlycon(char *buf);
++#else
++static const bool earlycon_init_is_deferred;
++static inline int setup_earlycon(char *buf) { return 0; }
++#endif
++
+ struct uart_port *uart_get_console(struct uart_port *ports, int nr,
+ 				   struct console *c);
+ int uart_parse_earlycon(char *p, unsigned char *iotype, unsigned long *addr,
+-- 
+2.7.4
+
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg
index 09fe7c7..155a101 100644
--- a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/qemuarm64/acpi.cfg
@@ -1,2 +1,3 @@
 CONFIG_EXPERT = y
 CONFIG_EMBEDDED=y
+CONFIG_ACPI=y
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb
index 5a577cc..d4c73d6 100644
--- a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.7.bb
@@ -64,6 +64,7 @@ SRC_URI += "file://0001-Add-function-to-fixup-page-faults-in-BOOT_SERVICES_-.pat
             file://0002-efi-allow-efi_mem_desc_lookup-find-EFI_BOOT_SERVICES.patch \
             file://0003-x86-efi-Fixup-faults-from-UEFI-firmware.patch \
             file://0004-x86-efi-Introduce-EFI_BOOT_SERVICES_WARN.patch \
+            file://0005-ACPI-Console-Through-SPCR-Table.patch \
            "
 
 # Add the defconfig from v4.6 kernel and the configuration x86 fragments
