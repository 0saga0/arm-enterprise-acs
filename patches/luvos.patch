From 4d5c86a226d611533b9cbfe1f76130fe705f6325 Mon Sep 17 00:00:00 2001
From: Sakar Arora <Sakar.Arora@arm.com>
Date: Thu, 23 Mar 2017 21:16:07 +0530
Subject: [PATCH] luv v4.10

---
 build_luvos.sh                                     |  97 +++
 meta-luv/classes/luv-efi.bbclass                   |  59 +-
 meta-luv/conf/distro/luv.conf                      |   2 +-
 meta-luv/recipes-bsp/sbbr/sbbr/README.md           |   2 +
 meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb             |  98 +++
 meta-luv/recipes-bsp/sbsa/files/compile.sh         |  16 +
 meta-luv/recipes-bsp/sbsa/sbsa.bb                  | 103 +++
 meta-luv/recipes-core/fwts/fwts/sbbr.patch         | 814 +++++++++++++++++++++
 meta-luv/recipes-core/fwts/fwts_git.bb             |   1 +
 .../images/core-image-efi-initramfs.bb             |   1 +
 meta-luv/recipes-core/images/luv-live-image.bb     |   8 +-
 meta-luv/recipes-core/images/luv-netboot-image.bb  |  10 +-
 meta-luv/recipes-core/luv-test/luv-test.bb         |   6 +
 .../luv-test/luv-test/luv-collect-results          | 209 ++++++
 .../recipes-core/luv-test/luv-test/luv-sbsa-test   |   5 +
 .../luv-test/luv-test/luv-test-manager             |   5 +
 .../linux/linux-yocto-efi-test_4.10.bb             |   3 +
 meta/conf/bitbake.conf                             |   2 +-
 sbsa_setup.sh                                      |  25 +
 19 files changed, 1453 insertions(+), 13 deletions(-)
 create mode 100755 build_luvos.sh
 create mode 100644 meta-luv/recipes-bsp/sbbr/sbbr/README.md
 create mode 100644 meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
 create mode 100755 meta-luv/recipes-bsp/sbsa/files/compile.sh
 create mode 100644 meta-luv/recipes-bsp/sbsa/sbsa.bb
 create mode 100644 meta-luv/recipes-core/fwts/fwts/sbbr.patch
 create mode 100644 meta-luv/recipes-core/luv-test/luv-test/luv-collect-results
 create mode 100755 meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test
 create mode 100755 sbsa_setup.sh

diff --git a/build_luvos.sh b/build_luvos.sh
new file mode 100755
index 0000000..412450e
--- /dev/null
+++ b/build_luvos.sh
@@ -0,0 +1,97 @@
+#!/bin/bash
+# The material contained herein is not a license, either
+# expressly or impliedly, to any intellectual property owned
+# or controlled by any of the authors or developers of this
+# material or to any contribution thereto. The material
+# contained herein is provided on an "AS IS" basis and, to the
+# maximum extent permitted by applicable law, this information
+# is provided AS IS AND WITH ALL FAULTS, and the authors and
+# developers of this material hereby disclaim all other
+# warranties and conditions, either express, implied or
+# statutory, including, but not limited to, any (if any)
+# implied warranties, duties or conditions of merchantability,
+# of fitness for a particular purpose, of accuracy or
+# completeness of responses, of results, of workmanlike
+# effort, of lack of viruses and of lack of negligence, all
+# with regard to this material and any contribution thereto.
+# Designers must not rely on the absence or characteristics of
+# any features or instructions marked "reserved" or
+# "undefined." The ARM, Inc. reserves any
+# features or instructions so marked for future definition and
+# shall have no responsibility whatsoever for conflicts or
+# incompatibilities arising from future changes to them. ALSO,
+# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
+# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
+# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
+# CONTRIBUTION THERETO.
+#
+# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
+# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
+# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
+# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
+# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
+# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
+# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
+# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
+# THE POSSIBILITY OF SUCH DAMAGES.
+#
+# Copyright 2016 ARM, Inc. All
+# Rights Reserved, subject to all existing rights in all
+# matters included within this Test Suite, to which ARM, Inc.
+# makes no claim of right.
+#
+# Copyright (c) 2016 ARM Ltd. All rights reserved.<BR>
+#
+TOPDIR=`pwd`
+
+METALUV="$TOPDIR/meta-luv \\\\"
+METAOE="$TOPDIR/meta-oe \\\\"
+BB_CONF="conf/bblayers.conf"
+LOCAL_CONF="conf/local.conf"
+MACHINE="\"qemuarm64\""
+LUV="\"luv\""
+NUM_THREADS="BB_NUMBER_THREADS ?= \"16\""
+OUTPUT_FILE="$PWD/build/tmp/deploy/images/qemuarm64/luv-live-image-gpt.img"
+
+echo "Building LuvOS Image with SBBR and SBSA for AARCH4 ..."
+echo "UEFI-SCT source is available only to members of UEFI Forum."
+echo "Please abort, if you are not a member."
+echo "Authentication Required for https://github.com/UEFI/UEFI-SCT"
+echo -n User:
+read SCTUSERNAME
+echo -n Password:
+read -s SCTPASSWORD
+echo ""
+echo "Default kernel command line parameters: 'systemd.log_target=null plymouth.ignore-serial-consoles debug ip=dhcp log_buf_len=1M efi=debug acpi=on crashkernel=256M earlycon uefi_debug'"
+echo -n "Append parameters (press Enter for default):"
+read ACS_CMDLINE_APPEND
+export SCTUSERNAME
+export SCTPASSWORD
+export ACS_CMDLINE_APPEND
+./sbsa_setup.sh
+rm -rf build
+source oe-init-build-env
+export BB_ENV_EXTRAWHITE="BB_ENV_EXTRAWHITE SCTUSERNAME SCTPASSWORD ACS_CMDLINE_APPEND"
+# include meta-luv  for building
+line=`grep -n "meta-yocto-bsp" $BB_CONF | cut -d : -f 1`
+sed -i "$line a $(echo "  $METALUV")" $BB_CONF
+sed -i "$line a $(echo "  $METAOE")" $BB_CONF
+
+# modify local.conf to edit Machine Type, Distro and Number of Threads
+sed -i -e "s/\(MACHINE ??= \).*/\1$MACHINE/" $LOCAL_CONF
+sed -i -e "s/\(DISTRO ?= \).*/\1$LUV/" $LOCAL_CONF
+sed -i -e "\$aEXTRA_IMAGE_FEATURES += \"dev-pkgs\"" $LOCAL_CONF
+echo >> $LOCAL_CONF
+echo "$NUM_THREADS" >> $LOCAL_CONF
+
+bitbake -c cleanall sbbr
+bitbake -c cleanall sbsa
+bitbake -c cleanall luv-live-image
+bitbake sbbr
+bitbake sbsa
+bitbake luv-live-image
+unset BB_ENV_EXTRAWHITE
+unset SCTPASSWORD
+unset SCTUSERNAME
+echo "Built image can be found at $OUTPUT_FILE"
+exit
diff --git a/meta-luv/classes/luv-efi.bbclass b/meta-luv/classes/luv-efi.bbclass
index d23c33d..88977a8 100644
--- a/meta-luv/classes/luv-efi.bbclass
+++ b/meta-luv/classes/luv-efi.bbclass
@@ -16,6 +16,13 @@ def get_bits_depends(bb, d):
                  return ""
 _BITSDEPENDS = "${@get_bits_depends(bb, d)}"
 
+def get_sbbr_depends(bb, d):
+         import re
+         deps = bb.data.getVar('TARGET_PREFIX', d, True)
+         if re.search("aarch64",deps):
+                 return "sbbr:do_deploy"
+_SBBRDEPENDS = "${@get_sbbr_depends(bb, d)}"
+
 # The x86 build is depends on grub-efi and AArch64 build depends on grub_git
 def get_grub_depends(bb, d):
          import re
@@ -57,8 +64,9 @@ efi_populate() {
 
     # Install grub2 in EFI directory
     if [ "${TARGET_ARCH}" = "aarch64" ]; then
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
-                echo "bootaa64.efi" > ${DEST}${EFIDIR}/startup.nsh
+                efi_populate_sbbr ${DEST}
+                efi_populate_sbsa ${DEST}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
 
     # TODO: need conditional signing; e.g., if (DISTRO_FEATURES contains secure_boot)
     # shim bootloader does not seem to work with i386. Thus we don't use it for 32-bit
@@ -82,7 +90,7 @@ efi_populate() {
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEPLOY_DIR_IMAGE}/shim.efi
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}-unsigned ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}
     else
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
     fi
 
     if echo "${TARGET_ARCH}" | grep -q "i.86" || [ "${TARGET_ARCH}" = "x86_64" ]; then
@@ -98,6 +106,41 @@ efi_populate() {
     install -m 0644 ${LUV_CFG} ${DEST}
 }
 
+efi_populate_sbbr() {
+    DEST=$1
+    cp -r ${DEPLOY_DIR_IMAGE}/sbbr ${DEST}${EFIDIR}/sbbr
+    mv ${DEST}${EFIDIR}/sbbr/Shell.efi ${DEST}${EFIDIR}/Shell.efi
+    echo "echo -off
+          for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F
+            if exist FS%i:\SCT\Overall\Summary.log then
+              bootaa64.efi
+              goto Done
+            endif
+          endfor
+          :Done" > ${DEST}${EFIDIR}/startup.nsh
+}
+
+efi_populate_sbsa() {
+        DEST=$1
+        cp -r ${DEPLOY_DIR_IMAGE}/sbsa ${DEST}${EFIDIR}/sbsa
+        echo "echo -off
+              if not exist sbsa_results then
+                mkdir sbsa_results
+              endif
+              cd sbsa_results
+              if not exist uefi then
+                mkdir uefi
+              endif
+              cd uefi
+              for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F then
+                if exist FS%i:\EFI\BOOT\sbsa\Sbsa.efi then
+                  FS%i:\EFI\BOOT\sbsa\Sbsa.efi -f SbsaResults.log
+                  goto Done
+                endif
+              endfor
+              :Done" > ${DEST}${EFIDIR}/sbsa/sbsa.nsh
+}
+
 efi_populate_bits() {
     DEST=$1
     # TODO: weird behavior here. When building luv-live-image,
@@ -177,6 +220,11 @@ python build_efi_cfg() {
        cfgfile.write('timeout=0\n')
        cfgfile.write('fallback=0\n')
 
+    if re.search("aarch64", target):
+       cfgfile.write('default=sbbr/sbsa\n')
+       cfgfile.write('timeout=10\n')
+       cfgfile.write('fallback=0\n')
+
     cfgfile.write('menuentry \'luv\' {\n')
     cfgfile.write('linux /vmlinuz ')
 
@@ -203,6 +251,11 @@ python build_efi_cfg() {
        cfgfile.write('chainloader /EFI/BOOT/bits/%s\n' % loader)
        cfgfile.write('}\n')
 
+    if re.search("aarch64", target):
+       cfgfile.write('menuentry \'sbbr/sbsa\' {\n')
+       cfgfile.write('chainloader /EFI/BOOT/Shell.efi\n')
+       cfgfile.write('}\n')
+
     cfgfile.close()
 }
 
diff --git a/meta-luv/conf/distro/luv.conf b/meta-luv/conf/distro/luv.conf
index 1676a0e..a36d97c 100644
--- a/meta-luv/conf/distro/luv.conf
+++ b/meta-luv/conf/distro/luv.conf
@@ -17,4 +17,4 @@ VIRTUAL-RUNTIME_init_manager = "systemd"
 VIRTUAL-RUNTIME_initscripts = ""
 DISTRO_FEATURES_BACKFILL_CONSIDERED += "sysvinit"
 
-INITRAMFS_MAXSIZE = "200000"
+INITRAMFS_MAXSIZE = "400000"
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/README.md b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
new file mode 100644
index 0000000..06f0264
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
@@ -0,0 +1,2 @@
+UEFI-SCT
+========
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
new file mode 100644
index 0000000..758cdcc
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
@@ -0,0 +1,98 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+SUMMARY = "SBBR is a test suite that runs Server Base Boot Requirements UEFI tests."
+
+DESCRIPTION = "This Server Base Boot Requirements (SBBR) test suite is intended \
+for SBSA[2]-compliant 64-bit ARMv8 servers. It defines the base firmware requirements \
+for out-of-box support of any ARM SBSA-compatible Operating System or hypervisor. \
+The tests are expected to be minimal yet complete for booting a multi-core \
+ARMv8 server platform, while leaving plenty of room \
+for OEM or ODM innovations and design details."
+
+# Home Page
+HOMEPAGE = "https://github.com/UEFI/UEFI-SCT"
+
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+SBBRVERSION="v1.0"
+PV="${SBBRVERSION}+git${SRCPV}"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+# No information for SRC_URI yet (only an external source tree was specified)
+SRCREV  = "d38be6dae3e7f67bdf52595288906d6832e0d893"
+SRC_URI = "git://github.com/UEFI/UEFI-SCT.git;protocol=https;branch=sbbr;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+          "
+
+# NOTE: no Makefile found, unable to determine what needs to be done
+
+do_configure () {
+	# Specify any needed configure commands here
+	:
+	echo "do_configure()"
+	# Specify any needed configure commands here
+	rm -rf edk2
+	git clone https://github.com/tianocore/edk2
+	cd edk2
+	git checkout c0584d0bdd4463551db8f8c62a5e2936ec97b407
+	ln -s ../SctPkg SctPkg
+	chmod +x SctPkg/build_sbbr.sh
+	cd ..
+
+	mkdir -p "tools/gcc"
+	cd "tools/gcc"
+	wget -nv "https://releases.linaro.org/components/toolchain/binaries/4.9-2016.02/aarch64-linux-gnu/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz"
+	#Untar the GCC Linaro files.
+	tar -xf gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz
+	cd ../..
+}
+
+do_compile () {
+	# Specify compilation commands here
+	:
+	echo "$PWD: do_compile()"
+	export PATH=$PATH:"$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE PATH"
+	echo "New PATH = $PATH"
+	export CROSS_COMPILE="$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE CROSS_COMPILE"
+	echo "NEW CROSS_COMPILE: $CROSS_COMPILE"
+
+	cd edk2
+	./SctPkg/build_sbbr.sh AARCH64 GCC
+	cd ..
+}
+
+do_install () {
+	# Specify install commands here
+	:
+	echo "do_install()"
+	echo "Destination Directory: ${D}"
+	echo "Source Directory: ${B}"
+	cp -r ${B}/edk2/Build/SbbrSct/DEBUG_GCC49/SctPackageAARCH64 ${D}/sbbr
+	cp ${B}/edk2/ShellBinPkg/UefiShell/AArch64/Shell.efi ${D}/sbbr/Shell.efi
+}
+
+do_deploy () {
+	# Specify deploy commands here
+	:
+	echo "do_deploy()"
+	echo "Destination Directory: ${DEPLOYDIR}"
+	echo "Source Directory: ${D}"
+	install -d ${DEPLOYDIR}
+	cp -r ${D}/sbbr ${DEPLOYDIR}/sbbr
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-bsp/sbsa/files/compile.sh b/meta-luv/recipes-bsp/sbsa/files/compile.sh
new file mode 100755
index 0000000..a47251a
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/files/compile.sh
@@ -0,0 +1,16 @@
+#!/usr/bin/env bash
+
+
+cd ${1}/edk2
+
+export GCC49_AARCH64_PREFIX=${1}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+
+echo "do_compile: Initializing EDK2 for building."
+set --
+source edksetup.sh
+
+echo "do_compile: Building BaseTools."
+make -C BaseTools/Source/C
+
+echo "do_compile: Building SBSA."
+source AppPkg/Applications/sbsa-acs/tools/scripts/avsbuild.sh
diff --git a/meta-luv/recipes-bsp/sbsa/sbsa.bb b/meta-luv/recipes-bsp/sbsa/sbsa.bb
new file mode 100644
index 0000000..631da02
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/sbsa.bb
@@ -0,0 +1,103 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+# SCT files placed in ${WORKDIR}/git
+# GCC files placed in ${WORKDIR}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu
+SRC_URI = "git://github.com/ARM-software/sbsa-acs.git;protocol=https;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+           https://releases.linaro.org/components/toolchain/binaries/5.3-2016.05/aarch64-linux-gnu/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu.tar.xz \
+           file://compile.sh"
+
+PV = "1.0+git${SRCPV}"
+SRCREV = "${AUTOREV}"
+
+# GCC checksum.
+SRC_URI[md5sum] = "24ac2e26f50f49f3043f281440b41bba"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+do_configure () {
+    # Downloading EDK2 into ${WORKDIR}/edk2.
+    echo "do_configure: Checking if EDK2 repository already exists."
+    cd ${WORKDIR}
+    if [ ! -d ${WORKDIR}/edk2 ]
+    then
+        echo "do_configure: Cloning EDK2 repository."
+        git clone https://github.com/tianocore/edk2.git
+    fi
+
+    # Linking SBSA and EDK2.
+    echo "do_configure: Linking SBSA to EDK2."
+    cd ${WORKDIR}/git/uefi_app
+    if [ -d val ]
+    then
+        echo "do_configure: Existing val found, deleted."
+        rm val
+    fi
+    if [ -d pal ]
+    then
+        echo "do_configure: Existing pal found, deleted."
+        rm pal
+    fi
+    if [ -d test_pool ]
+    then
+        echo "do_configure: Existing test_pool found, deleted."
+        rm test_pool
+    fi
+    cd ${WORKDIR}/edk2/AppPkg/Applications
+    if [ -d sbsa-acs ]
+    then
+        echo "do_configure: Existing sbsa-acs found, deleted."
+        rm sbsa-acs
+    fi
+    cd ${WORKDIR}/git
+    set -- "${WORKDIR}/git" "${WORKDIR}/edk2"
+    . ${WORKDIR}/git/tools/scripts/avssetup.sh
+    set --
+
+    # Modifying EDK2 to build SBSA.
+    echo "do_configure: Modifying edk2/ShellPkg/ShellPkg.dsc to build SBSA."
+    if ! grep -q SbsaPalLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaPalLib|AppPkg/Applications/sbsa-acs/platform/pal_uefi/SbsaPalLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaValLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaValLib|AppPkg/Applications/sbsa-acs/val/SbsaValLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaAvs "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/Components/ a \ \ AppPkg/Applications/sbsa-acs/uefi_app/SbsaAvs.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+}
+
+do_compile () {
+    cd ${WORKDIR}
+    ./compile.sh ${WORKDIR}
+}
+
+do_install () {
+    echo "do_install: Copying SBSA files to destination ${D}"
+    mkdir ${D}/sbsa
+	cp ${WORKDIR}/edk2/Build/Shell/DEBUG_GCC49/AARCH64/Sbsa.efi ${D}/sbsa/Sbsa.efi
+}
+
+do_deploy () {
+    echo "do_deploy: Deploying SBSA files to destionation ${DEPLOYDIR}"
+    install -d ${DEPLOYDIR}
+    cp -r ${D}/sbsa ${DEPLOYDIR}/sbsa
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-core/fwts/fwts/sbbr.patch b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
new file mode 100644
index 0000000..ef5cc09
--- /dev/null
+++ b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
@@ -0,0 +1,814 @@
+diff --git a/src/acpi/acpitables/acpitables.c b/src/acpi/acpitables/acpitables.c
+index 1fcf32a..3a0a0d3 100644
+--- a/src/acpi/acpitables/acpitables.c
++++ b/src/acpi/acpitables/acpitables.c
+@@ -14,7 +14,10 @@
+  *
+  */
+ #include "fwts.h"
+-
++#include "acpi.h"
++#include "accommon.h"
++#include "acnamesp.h"
++#include "actables.h"
+ #if defined(FWTS_HAS_ACPI)
+ 
+ #include <stdio.h>
+@@ -27,6 +30,12 @@
+ #include <unistd.h>
+ #include <inttypes.h>
+ 
++#define MIN_SIG 4
++#define OEM_ID 6
++#define OEM_TABLE_ID 8
++#define OEM_CREATOR_ID 4
++#define FADT_MAX_MAJOR_REVISION ((uint8_t)6)
++
+ static bool acpi_table_check_field(const char *field, const size_t len)
+ {
+ 	size_t i;
+@@ -116,9 +125,193 @@ static int acpi_table_check_test1(fwts_framework *fw)
+ 
+ 	return FWTS_OK;
+ }
++/* Callback function used when searching for processor devices in namespace. */
++ACPI_STATUS processor_handler(ACPI_HANDLE ObjHandle, uint32_t level, void *context,
++                              void **returnvalue)
++{
++	ACPI_NAMESPACE_NODE *node = (ACPI_NAMESPACE_NODE *)ObjHandle;
++	ACPI_NAMESPACE_NODE *parent = node->Parent;
++	int error_count;
++
++	/* Unused parameters trigger errors. */
++	FWTS_UNUSED(level);
++	FWTS_UNUSED(context);
++
++	/* If the processor device is not located under _SB_, increment the error_count. */
++	if (strncmp(parent->Name.Ascii, "_SB_", sizeof(int32_t)) != 0) {
++		error_count = *((int *)returnvalue);
++		error_count++;
++		*((int *)returnvalue) = error_count;
++	}
++
++	/* Return 0 so namespace search continues. */
++	return 0;
++}
++
++/* Test function that makes sure processors are under the _SB_ namespace. */
++static int acpi_namespace_check_test2(fwts_framework *fw)
++{
++	int error_count = 0;
++
++	/* Initializing ACPICA library so we can call AcpiWalkNamespace. */
++	if (fwts_acpica_init(fw) != FWTS_OK)
++		return FWTS_ERROR;
++
++	/* Searching for all processor devices in the namespace. */
++	AcpiWalkNamespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
++	                  processor_handler, NULL, NULL, (void **)&error_count);
++
++	/* Deinitializing ACPICA, if we don't call this the terminal will break on exit. */
++	fwts_acpica_deinit();
++
++	/* error_count variable counts the number of processors outside of the _SB_ namespace. */
++	if (error_count > 0)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiCpuWrongNamespace", "%d Processor devices "
++		            "were found outside of the _SB_ namespace.", error_count);
++	else
++		fwts_passed(fw, "All processor devices were located in the _SB_ namespace.");
++
++	return FWTS_OK;
++}
++
++static int acpi_table_check_test3(fwts_framework *fw)
++{
++	int i;
++	bool checked = false;
++	bool dsdt_checked = false;
++	bool ssdt_checked = false;
++
++	for (i = 0; ; i++) {
++		fwts_acpi_table_info *info;
++		fwts_acpi_table_header *hdr;
++		char name[50];
++		bool passed;
++
++		if (fwts_acpi_get_table(fw, i, &info) != FWTS_OK)
++			break;
++		if (info == NULL)
++			continue;
++
++		checked = true;
++		if (!strcmp(info->name, "DSDT") ||
++			!strcmp(info->name, "SSDT")) {
++			if (!strcmp(info->name, "DSDT")) {
++				dsdt_checked = true;
++			}
++			if (!strcmp(info->name, "SSDT")) {
++				ssdt_checked = true;
++			}
++			hdr = (fwts_acpi_table_header *)info->data;
++			if (acpi_table_check_field(hdr->signature, MIN_SIG)) {
++				snprintf(name, sizeof(name), "%4.4s", hdr->signature);
++			} else {
++				/* Table name not printable, so identify it by the address */
++				snprintf(name, sizeof(name), "at address 0x%" PRIx64, info->addr);
++			}
++
++			/*
++			 * Tables shouldn't be short, however, they do have at
++			 * least 4 bytes with their signature else they would not
++			 * have been loaded by this stage.
++			 */
++			if (hdr->length < sizeof(fwts_acpi_table_header)) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, "ACPITableHdrShort",
++					"ACPI Table %s is too short, only %d bytes long. Further "
++					"header checks will be omitted.", name, hdr->length);
++				continue;
++			}
++			/* Warn about empty tables */
++			if (hdr->length == sizeof(fwts_acpi_table_header)) {
++				fwts_warning(fw,
++					"ACPI Table %s is empty and just contains a table header. Further "
++					"header checks will be omitted.", name);
++				continue;
++			}
++
++			passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, MIN_SIG) &
++			    acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, OEM_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, OEM_TABLE_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, OEM_CREATOR_ID);
++			if (passed)
++				fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
++		}
++	}
++	if (!checked)
++		fwts_aborted(fw, "Cannot find any ACPI tables.");
++	if (!dsdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test DSDT table is NOT implemented.");
++	}
++	if (!ssdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test SSDT table is NOT implemented.");
++	}
++	if ((!dsdt_checked) || (!ssdt_checked))
++	  return FWTS_ERROR;
++
++	return FWTS_OK;
++}
++
++/* List of ACPI tables recommended by SBBR 4.2.2 */
++char *recommended_acpi_tables[] = {
++	"MCFG",
++	"IORT",
++	"BERT",
++	"EINJ",
++	"ERST",
++	"HEST",
++	"RASF",
++	"SPMI",
++	"SLIT",
++	"SRAT",
++	"CSRT",
++	"ECDT",
++	"MPST",
++	"PCCT",
++	NULL
++};
++
++/* Searches ACPI tables by signature. */
++fwts_acpi_table_info *sbbr_search_acpi_tables(fwts_framework *fw, char *signature)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	i = 0;
++	while (fwts_acpi_get_table(fw, i, &info) == FWTS_OK) {
++		if (info != NULL && strncmp(info->name, signature, sizeof(uint32_t)) == 0) {
++			return info;
++		}
++		i++;
++	}
++
++	return NULL;
++}
++
++static int acpi_table_check_test4(fwts_framework *fw)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	for (i = 0; recommended_acpi_tables[i] != NULL; i++) {
++		info = sbbr_search_acpi_tables(fw, recommended_acpi_tables[i]);
++		if (info == NULL) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiRecommendedTableNotFound",
++			            "SBBR Recommended ACPI table \"%s\" not found.",
++			            recommended_acpi_tables[i]);
++		} else {
++			fwts_passed(fw, "SBBR Recommended ACPI table \"%s\" found.",
++			            recommended_acpi_tables[i]);
++		}
++	}
++	return FWTS_OK;
++}
+ 
+ static fwts_framework_minor_test acpi_table_check_tests[] = {
+ 	{ acpi_table_check_test1, "Test ACPI headers." },
++	{ acpi_namespace_check_test2, "Test that processors only exist in the _SB namespace." },
++	{ acpi_table_check_test3, "Test DSDT and SSDT tables are implemented." },
++	{ acpi_table_check_test4, "Check for recommended ACPI tables." },
+ 	{ NULL, NULL }
+ };
+ 
+diff --git a/src/acpi/dbg2/dbg2.c b/src/acpi/dbg2/dbg2.c
+index e6f6f09..cb6356d 100644
+--- a/src/acpi/dbg2/dbg2.c
++++ b/src/acpi/dbg2/dbg2.c
+@@ -39,8 +39,8 @@ static int dbg2_init(fwts_framework *fw)
+ 		return FWTS_ERROR;
+ 	}
+ 	if (table == NULL || (table && table->length == 0)) {
+-		fwts_log_error(fw, "ACPI DBG2 table does not exist, skipping test");
+-		return FWTS_SKIP;
++		fwts_log_error(fw, "ACPI DBG2 table does not exist");
++		return FWTS_ERROR;
+ 	}
+ 
+ 	return FWTS_OK;
+diff --git a/src/acpi/fadt/fadt.c b/src/acpi/fadt/fadt.c
+index d2bea65..0581006 100644
+--- a/src/acpi/fadt/fadt.c
++++ b/src/acpi/fadt/fadt.c
+@@ -213,14 +213,9 @@ static int fadt_revision(fwts_framework *fw)
+ 	if (major == LATEST_MAJOR && minor == LATEST_MINOR)
+ 		fwts_passed(fw, "FADT revision is up to date.");
+ 	else {
+-		fwts_warning(fw, "FADT revision is outdated: %d.%d",
+-			     major, minor);
+-		fwts_advice(fw, "The most recent revision of the FADT "
+-			    "defined in the ACPI specification is %d.%d.  "
+-			    "While older revisions of the FADT can be used, "
+-			    "newer ones may enable additional functionality "
+-			    "that cannot be used until the FADT is updated.",
+-			    LATEST_MAJOR, LATEST_MINOR);
++		fwts_failed(fw, LOG_LEVEL_HIGH, "fadt_revision",
++		    "FADT revision Not up to date");
++		return FWTS_ERROR;
+ 	}
+ 
+ 	return FWTS_OK;
+@@ -1591,6 +1586,18 @@ static void acpi_table_check_fadt_sleep_status_reg(fwts_framework *fw)
+ 				    "will be ignored reduced hardware mode.");
+ 	}
+ }
++static int fadt_arm_boot_arch_psci_compliant_test(fwts_framework *fw)
++{
++	/* ARM SBBR 4.2.1.3 FADT */
++	if (fadt->arm_boot_flags &
++		FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT)
++		  fwts_passed(fw, "PSCI_COMPLIANT is set, PSCI is implemented.");
++	else
++	  fwts_failed(fw, LOG_LEVEL_MEDIUM,
++	      "FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT_flag is not set",
++	      "PSCI is NOT implemented.");
++	return FWTS_OK;
++}
+ 
+ static int fadt_test1(fwts_framework *fw)
+ {
+@@ -1829,6 +1836,7 @@ static fwts_framework_minor_test fadt_tests[] = {
+ 	{ fadt_test1, "ACPI FADT Description Table tests." },
+ 	{ fadt_test2, "Test FADT SCI_EN bit is enabled." },
+ 	{ fadt_test3, "Test FADT reset register." },
++	{ fadt_arm_boot_arch_psci_compliant_test, "Test ARM_BOOT_ARCH for psci compliance" },
+ 	{ NULL, NULL }
+ };
+ 
+diff --git a/src/acpi/method/method.c b/src/acpi/method/method.c
+index 0a56159..5f17b9f 100644
+--- a/src/acpi/method/method.c
++++ b/src/acpi/method/method.c
+@@ -210,7 +210,7 @@
+  * _SLI 	 N
+  * _SPD 	 Y
+  * _SRS 	 n/a
+- * _SRT 	 n/a
++ * _SRT 	 Y
+  * _SRV 	 Y
+  * _SST 	 Y
+  * _STA 	 Y
+@@ -255,7 +255,7 @@
+  */
+ 
+ /* Test types */
+-#define	METHOD_MANDITORY	1
++#define	METHOD_MANDATORY	1
+ #define METHOD_OPTIONAL		2
+ #define METHOD_MOBILE		4
+ #define METHOD_SILENT		8
+@@ -548,7 +548,7 @@ static int method_evaluate_method(fwts_framework *fw,
+ 	} else {
+ 		if (!(test_type & METHOD_SILENT)) {
+ 			/* Manditory not-found test are a failure */
+-			if (test_type & METHOD_MANDITORY) {
++			if (test_type & METHOD_MANDATORY) {
+ 				fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodNotExist",
+ 					"Object %s did not exist.", name);
+ 			}
+@@ -2235,7 +2235,7 @@ static void method_test_CRS_return(
+ 
+ static int method_test_CRS(fwts_framework *fw)
+ {
+-	return method_evaluate_method(fw, METHOD_MANDITORY,
++	return method_evaluate_method(fw, METHOD_MANDATORY,
+ 		"_CRS", NULL, 0, method_test_CRS_return, "_CRS");
+ }
+ 
+@@ -4786,6 +4786,34 @@ static int method_test_CWS(fwts_framework *fw)
+ 	return ret;
+ }
+ 
++static void method_test_SRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value & ~0x1)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SRTReturn",
++			"%s returned %" PRId64 ", should be between 0 and 1, "
++			"one or more of the reserved bits 1..31 seem "
++			"to be set.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_SRT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SRT", NULL, 0, method_test_SRT_return, NULL);
++}
+ 
+ static int method_test_STP(fwts_framework *fw)
+ {
+@@ -6389,7 +6417,7 @@ static int method_test_PTS(fwts_framework *fw)
+ 
+ 		fwts_log_info(fw, "Test _PTS(%d).", i);
+ 
+-		if (method_evaluate_method(fw, METHOD_MANDITORY, "_PTS", arg, 1,
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_PTS", arg, 1,
+ 			method_test_NULL_return, NULL) == FWTS_NOT_EXIST) {
+ 			fwts_advice(fw,
+ 				"Could not find _PTS. This method provides a "
+@@ -6422,7 +6450,7 @@ static int method_test_TTS(fwts_framework *fw)
+ 			fwts_log_info(fw,
+ 				"Test _TTS(%d) Transition To State S%d.", i, i);
+ 
+-			if (method_evaluate_method(fw, METHOD_MANDITORY,
++			if (method_evaluate_method(fw, METHOD_MANDATORY,
+ 				"_TTS", arg, 1, method_test_NULL_return,
+ 				NULL) == FWTS_NOT_EXIST) {
+ 				fwts_advice(fw,
+@@ -6474,7 +6502,7 @@ static int method_test_WAK(fwts_framework *fw)
+ 		arg[0].Type = ACPI_TYPE_INTEGER;
+ 		arg[0].Integer.Value = i;
+ 		fwts_log_info(fw, "Test _WAK(%d) System Wake, State S%d.", i, i);
+-		if (method_evaluate_method(fw, METHOD_MANDITORY, "_WAK", arg, 1,
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_WAK", arg, 1,
+ 			method_test_WAK_return, &i) == FWTS_NOT_EXIST) {
+ 			fwts_advice(fw,
+ 				"Section 7.3.7 states that a system that wakes "
+@@ -6879,6 +6907,85 @@ static int method_test_SRV(fwts_framework *fw)
+ 		"_SRV", NULL, 0, method_test_integer_return, NULL);
+ }
+ 
++/* ARM SBBR Test Definitions */
++static int sbbr_method_test_ADR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_ADR", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_AEI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_AEI_return, NULL);
++}
++
++static int sbbr_method_test_CCA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_CCA", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_EVT(fwts_framework *fw)
++{
++	int ret;
++
++	/* Only test the _EVT method with pins defined in AEI. */
++	ret = method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_EVT_return, NULL);
++
++	if (ret == FWTS_NOT_EXIST)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiEvtDoesNotExist", "Method _EVT does not exist.");
++
++	return ret;
++}
++
++static int sbbr_method_test_HID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_HID", NULL, 0, method_test_HID_return, NULL);
++}
++
++static int sbbr_method_test_OSI(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_STRING;
++	arg[0].String.Pointer = "Linux";
++
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_OSI", arg, 1, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_SST(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int ret, i;
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	for (i = 0; i <= 4; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_MANDATORY,
++			"_SST", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static int sbbr_method_test_STA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_STA", NULL, 0, method_test_STA_return, "_STA");
++}
++
++static int sbbr_method_test_UID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_UID", NULL, 0, method_test_UID_return, NULL);
++}
++
+ /*
+  * Tests
+  */
+@@ -7081,7 +7188,7 @@ static fwts_framework_minor_test method_tests[] = {
+ 	{ method_test_GRT, "Test _GRT (Get Real Time)." },
+ 	{ method_test_GWS, "Test _GWS (Get Wake Status)." },
+ 	{ method_test_CWS, "Test _CWS (Clear Wake Status)." },
+-	/* { method_test_SRT, "Test _SRT (Set Real Time)." }, */
++	{ method_test_SRT, "Test _SRT (Set Real Time)." },
+ 	{ method_test_STP, "Test _STP (Set Expired Timer Wake Policy)." },
+ 	{ method_test_STV, "Test _STV (Set Timer Value)." },
+ 	{ method_test_TIP, "Test _TIP (Expired Timer Wake Policy)." },
+@@ -7196,6 +7303,17 @@ static fwts_framework_minor_test method_tests[] = {
+ 	{ method_test_IFT, "Test _IFT (IPMI Interface Type)." },
+ 	{ method_test_SRV, "Test _SRV (IPMI Interface Revision)." },
+ 
++	/* From ARM SBBR */
++	{ sbbr_method_test_ADR, "SBBR Test _ADR (Return Unique ID for Device)." },
++	{ sbbr_method_test_AEI, "SBBR Test _AEI (Event Information)." },
++	{ sbbr_method_test_CCA, "SBBR Test _CCA (Cache Coherency Attribute)." },
++	{ sbbr_method_test_EVT, "SBBR Test _EVT (Event Method)." },
++	{ sbbr_method_test_HID, "SBBR Test _HID (Hardware ID)." },
++	{ sbbr_method_test_OSI, "SBBR Test _OSI (Operating System Interfaces)." },
++	{ sbbr_method_test_SST, "SBBR Test _SST (System Status)." },
++	{ sbbr_method_test_STA, "SBBR Test _STA (Status)." },
++	{ sbbr_method_test_UID, "SBBR Test _UID (Unique ID)." },
++
+ 	/* End! */
+ 
+ 	{ NULL, NULL }
+diff --git a/src/acpi/rsdp/rsdp.c b/src/acpi/rsdp/rsdp.c
+index a084d9c..3c00de2 100644
+--- a/src/acpi/rsdp/rsdp.c
++++ b/src/acpi/rsdp/rsdp.c
+@@ -123,6 +123,17 @@ static int rsdp_test1(fwts_framework *fw)
+ 			    "RSDP: at least one of RsdtAddress or XsdtAddress "
+ 			    "is non-zero.");
+ 
++	/* ARM SBBR 4.2.1.1  RSDP */
++	if ((rsdp->rsdt_address == 0) && (rsdp->xsdt_address != 0))
++		fwts_passed(fw,
++				"RSDP: the RsdtAddress is zero "
++				"and the XsdtAddress is non-zero.");
++	else
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++				"RSDPNoAddressesFound",
++				"RSDP: the RsdtAddress must be zero "
++				"and the XsdtAddress must be non-zero.");
++
+ 	if (rsdp->rsdt_address && rsdp->xsdt_address) {
+ 		fwts_log_warning(fw, "NOTE: The RSDT and XSDT are both "
+ 			"defined. An operating system supporting ACPI "
+diff --git a/src/acpi/spcr/spcr.c b/src/acpi/spcr/spcr.c
+index c38229b..395e687 100644
+--- a/src/acpi/spcr/spcr.c
++++ b/src/acpi/spcr/spcr.c
+@@ -39,8 +39,8 @@ static int spcr_init(fwts_framework *fw)
+ 		return FWTS_ERROR;
+ 	}
+ 	if (table == NULL || (table && table->length == 0)) {
+-		fwts_log_error(fw, "ACPI SPCR table does not exist, skipping test");
+-		return FWTS_SKIP;
++		fwts_log_error(fw, "ACPI SPCR table does not exist");
++		return FWTS_ERROR;
+ 	}
+ 	spcr = (const fwts_acpi_table_spcr*)table->data;
+ 
+diff --git a/src/acpi/xsdt/xsdt.c b/src/acpi/xsdt/xsdt.c
+index 37a45c8..82cfd72 100644
+--- a/src/acpi/xsdt/xsdt.c
++++ b/src/acpi/xsdt/xsdt.c
+@@ -45,6 +45,8 @@ static int xsdt_init(fwts_framework *fw)
+ 
+ /*
+  *  XSDT Extended System Description Table
++ *
++ *  ARM SBBR 4.2.1.2 XSDT
+  */
+ static int xsdt_test1(fwts_framework *fw)
+ {
+@@ -68,7 +70,8 @@ static int xsdt_test1(fwts_framework *fw)
+ 		}
+ 	}
+ 	if (passed)
+-		fwts_passed(fw, "No issues found in XSDT table.");
++		fwts_passed(fw, "No issues found in XSDT table."
++		    "Number of tables pointed by XSDT = %d", (int)n);
+ 
+ 	return FWTS_OK;
+ }
+diff --git a/src/dmi/dmicheck/dmicheck.c b/src/dmi/dmicheck/dmicheck.c
+index 49b523d..6770d3b 100644
+--- a/src/dmi/dmicheck/dmicheck.c
++++ b/src/dmi/dmicheck/dmicheck.c
+@@ -313,12 +313,15 @@ static int dmi_load_file(const char* filename, void *buf, size_t size)
+ 
+ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ {
+-	off_t addr = (off_t)entry->struct_table_address;
+ 	size_t length = (size_t)entry->struct_table_length;
+ 	void *table;
+-	void *mem;
+ 	char anchor[8];
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
++	off_t addr = (off_t)entry->struct_table_address;
++	void *mem;
++	#endif
++
+ 	/* 32 bit entry sanity check on length */
+ 	if ((length == 0) || (length > 0xffff)) {
+ 		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
+@@ -326,6 +329,7 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 		return NULL;
+ 	}
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
+ 	mem = fwts_mmap(addr, length);
+ 	if (mem != FWTS_MAP_FAILED) {
+ 		table = malloc(length);
+@@ -334,6 +338,7 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 		(void)fwts_munmap(mem, length);
+ 		return table;
+ 	}
++	#endif
+ 
+ 	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, 4) == FWTS_OK
+ 			&& strncmp(anchor, "_SM_", 4) == 0) {
+@@ -354,12 +359,15 @@ static void* dmi_table_smbios(fwts_framework *fw, fwts_smbios_entry *entry)
+ 
+ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ {
+-	off_t addr = (off_t)entry->struct_table_address;
+ 	size_t length = (size_t)entry->struct_table_max_size;
+ 	void *table;
+-	void *mem;
+ 	char anchor[8];
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
++	off_t addr = (off_t)entry->struct_table_address;
++	void *mem;
++	#endif
++
+ 	/* 64 bit entry sanity check on length */
+ 	if ((length == 0) || (length > 0xffffff)) {
+ 		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
+@@ -367,6 +375,7 @@ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ 		return NULL;
+ 	}
+ 
++	#if !defined(FWTS_ARCH_AARCH64)
+ 	mem = fwts_mmap(addr, length);
+ 	if (mem != FWTS_MAP_FAILED) {
+ 		table = malloc(length);
+@@ -375,6 +384,7 @@ static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
+ 		(void)fwts_munmap(mem, length);
+ 		return table;
+ 	}
++	#endif
+ 
+ 	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, 5) == FWTS_OK
+ 			&& strncmp(anchor, "_SM3_", 5) == 0) {
+@@ -1878,10 +1888,15 @@ static int dmicheck_test3(fwts_framework *fw)
+ 	return FWTS_OK;
+ }
+ 
++static int sbbr_smbios30_locate_structure (fwts_framework *fw, fwts_smbios30_entry *entry,
++	                                       uint8_t *table, uint8_t type, fwts_dmi_header *hdr);
++static int sbbr_smbios_test(fwts_framework *fw);
++
+ static fwts_framework_minor_test dmicheck_tests[] = {
+ 	{ dmicheck_test1, "Find and test SMBIOS Table Entry Points." },
+ 	{ dmicheck_test2, "Test DMI/SMBIOS tables for errors." },
+ 	{ dmicheck_test3, "Test DMI/SMBIOS3 tables for errors." },
++	{ sbbr_smbios_test, "Test ARM SBBR SMBIOS structure requirements."},
+ 	{ NULL, NULL }
+ };
+ 
+@@ -1893,3 +1908,124 @@ static fwts_framework_ops dmicheck_ops = {
+ FWTS_REGISTER("dmicheck", &dmicheck_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_BATCH | FWTS_FLAG_ROOT_PRIV)
+ 
+ #endif
++
++/*
++ * ARM SBBR SMBIOS Structure Test
++ */
++
++/* Test Entry Structure */
++typedef struct {
++	const char *name;
++	const uint8_t type;
++} sbbr_test_entry;
++
++/* Test Definition Array */
++sbbr_test_entry sbbr_test[] = {
++	{"BIOS Information", 0},
++	{"System Information", 1},
++	{"Baseboard Information", 2},
++	{"System Enclosure or Chassis", 3},
++	{"Processor Information", 4},
++	{"Cache Information", 7},
++	{"Port Connector Information", 8},
++	{"System Slots", 9},
++	{"OEM Strings", 11},
++	{"BIOS Language Information", 13},
++	{"System Event Log", 15},
++	{"Physical Memory Array", 16},
++	{"Memory Device", 17},
++	{"Memory Array Mapped Address", 19},
++	{"System Boot Information", 32},
++	{"IPMI Device Information", 38},
++	{"Onboard Devices Extended Information", 41},
++	{0, 0}
++};
++
++#define HEADER_TYPE_OFFSET 0
++#define HEADER_LENGTH_OFFSET 1
++#define HEADER_HANDLE_OFFSET 2
++
++/* Finds SMBIOS structure of a given type in an SMBIOS30 table. */
++static int sbbr_smbios30_locate_structure (fwts_framework *fw, fwts_smbios30_entry *entry,
++	                                       uint8_t *table, uint8_t type, fwts_dmi_header *hdr){
++	uint8_t *entry_data = table;
++	uint16_t table_max_length;
++	int i = 0;
++	uint8_t *next_entry;
++	table_max_length = entry->struct_table_max_size;
++
++	for (i = 0; entry_data <= (table + table_max_length - 4); i++) {
++
++		hdr->type   = entry_data[0];
++		hdr->length = entry_data[1];
++		hdr->handle = GET_UINT16(entry_data + 2);
++		hdr->data   = entry_data;
++
++		/* We found the entry we're looking for. */
++		if (hdr->type == type)
++			return FWTS_OK;
++
++		/* We found DMI end of table */
++		if (hdr->type == SMBIOS_END_OF_TABLE)
++			return FWTS_ERROR;
++
++		/* Real Physical Address */
++		next_entry = entry_data + hdr->length;
++
++		/* Look for structure terminator, ends in two zero bytes */
++		while (((next_entry - table + 1) < table_max_length) && ((next_entry[0] != 0) || (next_entry[1] != 0)))
++			next_entry++;
++
++		/* Skip over terminating two zero bytes, see section 6.1 of spec */
++		next_entry += 2;
++
++		if ((next_entry - table) > table_max_length){
++			fwts_failed(fw, LOG_LEVEL_HIGH, DMI_BAD_TABLE_LENGTH,
++				"DMI table maximum size was %" PRId32 " bytes (as specified by "
++				"the SMBIOS 3.0 header) but the DMI entries over the maximum "
++				"length without finding the End-of-Table(Type 127).",
++				table_max_length);
++			break;
++		}
++
++		entry_data = next_entry;
++	}
++	return FWTS_ERROR;
++}
++
++/* SBBR SMBIOS structure test function. */
++static int sbbr_smbios_test(fwts_framework *fw)
++{
++	fwts_smbios30_entry entry;
++	fwts_dmi_header hdr;
++	uint16_t version;
++	void *addr;
++	uint32_t i;
++	uint8_t *table;
++
++	/* Finding SMBIOS30 entry point. */
++	addr = fwts_smbios30_find_entry(fw, &entry, &version);
++	if (addr == NULL) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoTable", "Cannot find SMBIOS30 table "
++		            "entry.");
++		return FWTS_ERROR;
++	}
++
++	/* Getting SMBIOS table contents. */
++	table = dmi_table_smbios30(fw, &entry);
++	if (table == NULL)
++		return FWTS_ERROR;
++
++	/* Searching for each SMBIOS structure needed by SBBR. */
++	for (i = 0; sbbr_test[i].name != NULL; i++) {
++		if (sbbr_smbios30_locate_structure(fw, &entry, table, sbbr_test[i].type, &hdr) == FWTS_OK)
++			dmicheck_entry(fw, (uintptr_t)hdr.data, &hdr);
++		else
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoStruct", "Cannot find SMBIOS "
++			            "structure: %s (Type %d)", sbbr_test[i].name, sbbr_test[i].type);
++	}
++
++	dmi_table_free(table);
++
++	return FWTS_OK;
++}
+diff --git a/src/lib/src/fwts_smbios.c b/src/lib/src/fwts_smbios.c
+index 8d0ea39..2baa31b 100644
+--- a/src/lib/src/fwts_smbios.c
++++ b/src/lib/src/fwts_smbios.c
+@@ -52,6 +52,8 @@ static void *fwts_smbios_find_entry_uefi(fwts_framework *fw, fwts_smbios_entry *
+ 	void *addr;
+ 
+ 	if ((addr = fwts_scan_efi_systab("SMBIOS")) != NULL) {
++
++		#if !defined(FWTS_ARCH_AARCH64)
+ 		fwts_smbios_entry *mapped_entry;
+ 
+ 		if ((mapped_entry = fwts_mmap((off_t)addr, sizeof(fwts_smbios_entry))) != FWTS_MAP_FAILED) {
+@@ -60,6 +62,7 @@ static void *fwts_smbios_find_entry_uefi(fwts_framework *fw, fwts_smbios_entry *
+ 			*type  = FWTS_SMBIOS;
+ 			return addr;
+ 		}
++		#endif
+ 
+ 		if (fwts_load_file("/sys/firmware/dmi/tables/smbios_entry_point",
+ 				entry, sizeof(fwts_smbios_entry)) == FWTS_OK && !strncmp((char*)entry, "_SM_", 4)) {
+@@ -82,13 +85,16 @@ static void *fwts_smbios30_find_entry_uefi(fwts_framework *fw, fwts_smbios30_ent
+ 	void *addr;
+ 
+ 	if ((addr = fwts_scan_efi_systab("SMBIOS3")) != NULL) {
+-		fwts_smbios30_entry *mapped_entry;
+ 
++		#if !defined(FWTS_ARCH_AARCH64)
++		fwts_smbios30_entry *mapped_entry;
++		
+ 		if ((mapped_entry = fwts_mmap((off_t)addr, sizeof(fwts_smbios30_entry))) != FWTS_MAP_FAILED) {
+ 			*entry = *mapped_entry;
+ 			(void)fwts_munmap(mapped_entry, sizeof(fwts_smbios30_entry));
+ 			return addr;
+ 		}
++		#endif
+ 
+ 		if (fwts_load_file("/sys/firmware/dmi/tables/smbios_entry_point",
+ 				entry, sizeof(fwts_smbios30_entry)) == FWTS_OK && !strncmp((char*)entry, "_SM3_", 5)) {
diff --git a/meta-luv/recipes-core/fwts/fwts_git.bb b/meta-luv/recipes-core/fwts/fwts_git.bb
index fd8a8f8..4b8f139 100644
--- a/meta-luv/recipes-core/fwts/fwts_git.bb
+++ b/meta-luv/recipes-core/fwts/fwts_git.bb
@@ -9,6 +9,7 @@ PV = "V17.03.00+git${SRCPV}"
 SRCREV = "e3e9d1442b4cc70f5b30199f584cec8e25aeaad4"
 SRC_URI = "git://kernel.ubuntu.com/hwe/fwts.git \
            file://luv-parser-fwts \
+           file://sbbr.patch \
           "
 
 S = "${WORKDIR}/git"
diff --git a/meta-luv/recipes-core/images/core-image-efi-initramfs.bb b/meta-luv/recipes-core/images/core-image-efi-initramfs.bb
index 82a9cb8..b7e6a8d 100644
--- a/meta-luv/recipes-core/images/core-image-efi-initramfs.bb
+++ b/meta-luv/recipes-core/images/core-image-efi-initramfs.bb
@@ -9,6 +9,7 @@ IMAGE_INSTALL = "\
     util-linux-mount util-linux-umount kmod sed tar net-tools \
     shadow util-linux procps efivarfs-test \
     plymouth plymouth-set-default-theme kernel-efi-warnings linux-firmware kexec \
+    sbsa-acs-drv sbsa-acs-app \
     "
 
 X86_ADDITIONS = "chipsec python-codecs python-subprocess vmcore-dmesg bits \
diff --git a/meta-luv/recipes-core/images/luv-live-image.bb b/meta-luv/recipes-core/images/luv-live-image.bb
index 50cad08..8c5b75c 100644
--- a/meta-luv/recipes-core/images/luv-live-image.bb
+++ b/meta-luv/recipes-core/images/luv-live-image.bb
@@ -26,7 +26,7 @@ COMMON_CMDLINE_x86 += "splash nomodeset crash_kexec_post_notifiers"
 
 # Unlike the += operand, _append's do not insert a space between the current value
 # and the appended string. Thus, we add them.
-CMDLINE_append_aarch64 = " acpi=on"
+CMDLINE_append_aarch64 = " acpi=on crashkernel=256M earlycon uefi_debug ${ACS_CMDLINE_APPEND}"
 CMDLINE_append_x86 = "${COMMON_CMDLINE_x86}"
 CMDLINE_append_x86-64 = "${COMMON_CMDLINE_x86}"
 
@@ -42,7 +42,7 @@ python() {
 
 SPLASH_IMAGE = "blue-luv.jpg"
 
-GRUB_TIMEOUT = "2"
+GRUB_TIMEOUT = "1"
 
 inherit image-live
 
@@ -66,8 +66,8 @@ build_img() {
     BYTES_PER_SECTOR=512
     MiB=$(expr 1024 \* 1024)
     VFAT_RESULTS=${DEPLOY_DIR_IMAGE}/${PN}-results.hddimg
-    # 16MB of space to store test results
-    VFAT_RESULTS_SPACE_MiB=16
+    # 128 MB of space for test results and SCT installation
+    VFAT_RESULTS_SPACE_MiB=128
     VFAT_RESULTS_SPACE=$(expr $VFAT_RESULTS_SPACE_MiB \* $MiB)
     VFAT_RESULTS_BLOCKS=$(expr $VFAT_RESULTS_SPACE / 1024)
     # TODO: do we need to dynamically generate the UUID?
diff --git a/meta-luv/recipes-core/images/luv-netboot-image.bb b/meta-luv/recipes-core/images/luv-netboot-image.bb
index d8205ee..d3811fa 100644
--- a/meta-luv/recipes-core/images/luv-netboot-image.bb
+++ b/meta-luv/recipes-core/images/luv-netboot-image.bb
@@ -1,7 +1,7 @@
 LICENSE = "MIT"
 LIC_FILES_CHKSUM = "file://${COREBASE}/LICENSE;md5=4d92cd373abda3937c2bc47fbc49d690"
 
-DEPENDS_${PN} = "bits"
+DEPENDS_${PN} = "bits sbbr"
 
 INITRD_IMAGE_LIVE = "core-image-efi-initramfs"
 IMGDEPLOYDIR = "${DEPLOY_DIR_IMAGE}"
@@ -28,7 +28,7 @@ COMMON_CMDLINE_x86 += "splash nomodeset crash_kexec_post_notifiers"
 
 # Unlike the += operand, _append's do not insert a space between the current value
 # and the appended string. Thus, we add them.
-CMDLINE_append_aarch64 = " acpi=on"
+CMDLINE_append_aarch64 = " acpi=on crashkernel=256M earlycon uefi_debug luv.netboot"
 CMDLINE_append_x86 = "${COMMON_CMDLINE_x86}"
 CMDLINE_append_x86-64 = "${COMMON_CMDLINE_x86}"
 
@@ -59,7 +59,8 @@ do_mkimage[depends] += "dosfstools-native:do_populate_sysroot \
                         mtools-native:do_populate_sysroot \
                         cdrtools-native:do_populate_sysroot \
                         virtual/kernel:do_deploy \
-			${_BITSDEPENDS}"
+                        ${_BITSDEPENDS} \
+                        ${_SBBRDEPENDS}"
 
 do_bootimg[noexec] = "1"
 
@@ -68,7 +69,8 @@ do_populate_image() {
 	if [ "${TARGET_ARCH}" != "aarch64" ]; then
 		efi_populate_bits ${HDDDIR}
 	else
-		echo "bootaa64.efi" > ${HDDDIR}${EFIDIR}/startup.nsh
+		efi_populate_sbbr ${HDDDIR}
+		efi_populate_sbsa ${HDDDIR}
 		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${HDDDIR}${EFIDIR}
 	fi
 	install -m 0644 ${GRUBCFG} ${HDDDIR}${EFIDIR}
diff --git a/meta-luv/recipes-core/luv-test/luv-test.bb b/meta-luv/recipes-core/luv-test/luv-test.bb
index 7a94cc3..a35e2b9 100644
--- a/meta-luv/recipes-core/luv-test/luv-test.bb
+++ b/meta-luv/recipes-core/luv-test/luv-test.bb
@@ -32,6 +32,8 @@ SRC_URI += "file://luv-test-manager file://luv-test-parser \
             file://luv-test-manager.service \
             file://luv-crash-handler.service \
             file://luv-netconsole.service \
+            file://luv-collect-results \
+            file://luv-sbsa-test \
           "
 
 RDEPENDS_${PN}-netconsole+= "kernel-modules curl iputils iproute2 bash init-ifupdown dhcp-client"
@@ -67,6 +69,10 @@ do_install_append() {
        install -m 0644 ${WORKDIR}/luv-scripts ${D}${datadir}/luv/html
        install -m 0644 ${WORKDIR}/luv-css-styles ${D}${datadir}/luv/html
 
+       # Install luv-collect-results script
+       install -m 755 ${WORKDIR}/luv-collect-results ${D}${sysconfdir}/
+       install -m 755 ${WORKDIR}/luv-sbsa-test ${D}${sysconfdir}/
+
        install -d ${D}${systemd_unitdir}/system
 
        install -m 0644 ${WORKDIR}/luv-test-manager.service ${D}${systemd_unitdir}/system
diff --git a/meta-luv/recipes-core/luv-test/luv-test/luv-collect-results b/meta-luv/recipes-core/luv-test/luv-test/luv-collect-results
new file mode 100644
index 0000000..e6542e4
--- /dev/null
+++ b/meta-luv/recipes-core/luv-test/luv-test/luv-collect-results
@@ -0,0 +1,209 @@
+#!/usr/bin/env python
+
+import sys
+import os
+import re
+import codecs
+
+def log_fwts(d):
+    testCategory = ""
+    testName = ""
+    testPasses = 0
+    testFails = 0
+    testSkips = 0
+    totalPasses = 0
+    totalFails = 0
+    totalSkips = 0
+
+    # Finding latest FWTS results directory.
+    directory = os.listdir(d)
+    fwtsDir = ""
+    for folder in directory:
+        if "luv-results-" in folder and folder > fwtsDir:
+            fwtsDir = folder
+
+    # Opening FWTS raw output file.
+    fwtsRawPath = os.path.join(d, fwtsDir, "raw", "fwts")
+    try:
+        fwtsRaw = open(fwtsRawPath, "r")
+    except IOError:
+        print "FWTS raw results file \"%s\" could not be opened, skipping." % fwtsRawPath
+        return -1
+
+    # Printing .MD file header for FWTS results.
+    outFile.write("# FWTS Test Results\n")
+    outFile.write("| Category | Test Case | Passes | Skips | Failures |\n")
+    outFile.write("| :--- | :--- | ---: | ---: | ---: |\n")
+
+    # Scraping FWTS output.
+    while True:
+        # Getting a line from file.
+        line = fwtsRaw.readline()
+        if line == "":
+            if testCategory != "":
+                outFile.write ("| %s | %s | %d | %d | %d |\n" % (testCategory, testName, testPasses, testSkips, testFails))
+                outFile.write ("| Total |  | %d | %d | %d |\n" % (totalPasses, totalSkips, totalFails))
+            return 0
+        line = line.rstrip()
+
+        # Checking if line is the beginning of a new test results block.
+        matchString = re.search(r"INF Test \d", line, re.M|re.I)
+        if matchString:
+            # Printing information for previous test before we move to next one.
+            if testName != "":
+                outFile.write ("| %s | %s | %d | %d | %d |\n" % (testCategory, testName, testPasses, testSkips, testFails))
+                testCategory = ""
+            currentTest = line.split()[2] + " " + line.split()[3]
+            testCategory = line.split()[0]
+            testName = line[(line.index(":") + 2):]
+            testPasses = 0
+            testFails = 0
+            testSkips = 0
+            testInfos = 0
+            while testName[len(testName) - 1] != ".":
+                line = fwtsRaw.readline().rstrip()
+                if ";INF" not in line:
+                    break
+                testName = testName + " " + line[20:]
+
+        # Checking if line is a pass/fail/skip for currentTest.
+        if "PASSED" in line and currentTest in line:
+            testPasses = testPasses + 1
+            totalPasses = totalPasses + 1
+        if "SKIPPED" in line and currentTest in line:
+            testSkips = testSkips + 1
+            totalSkips = totalSkips + 1
+        if "FAILED" in line and currentTest in line:
+            testFails = testFails + 1
+            totalFails = totalFails + 1
+
+def log_sbbr(d):
+    testCategory = ""
+    testName = ""
+    testCase = ""
+    testDescription = ""
+    testPasses = 0
+    testWarnings = 0
+    testErrors = 0
+    totalPasses = 0
+    totalWarnings = 0
+    totalErrors = 0
+
+    # Finding SCT test results.
+    sbbrDir = os.path.join(d, "SCT", "Log")
+    if os.path.isdir(sbbrDir) == False:
+        print "SBBR SCT results directory \"%s\" not found.  Skipping." % sbbrDir
+        return -1
+
+    # Printing .MD file header for SCT results.
+    outFile.write("# UEFI SBBR SCT Test Results\n")
+    outFile.write("| Category | Test File | Test Case | Description | Passes | Warnings | Errors |\n")
+    outFile.write("| :--- | :--- | :--- | :--- | ---: | ---: | ---: |\n")
+
+    # Recursively walking through SBBR results folders.
+    for dirpath, dirnames, filenames in os.walk(sbbrDir):
+        for entry in filenames:
+            if ".log" in entry:
+                path, testName = os.path.split(dirpath)
+                testName = testName.split("0")[0]
+                path, testCategory = os.path.split(path)
+                with codecs.open(os.path.join(dirpath, entry), mode="r", encoding="utf-16") as logfile:
+                    i = 1
+                    while True:
+                        line = logfile.readline()
+                        if line == "":
+                            break
+                        if i == 2:
+                            testCase = line.rstrip()
+                        if i == 11:
+                            testDescription = line.rstrip()
+                        if "Passes..........." in line:
+                            testPasses = int(line.split()[1])
+                        if "Warnings........." in line:
+                            testWarnings = int(line.split()[1])
+                        if "Errors..........." in line:
+                            testErrors = int(line.split()[1])
+                        i = i + 1
+                    outFile.write("| %s | %s | %s | %s | %d | %d | %d |\n" % (testCategory, testName, testCase, testDescription, testPasses, testWarnings, testErrors))
+                    totalPasses = totalPasses + testPasses
+                    totalWarnings = totalWarnings + testWarnings
+                    totalErrors = totalErrors + testErrors
+
+    # Print totals.
+    outFile.write("| Total | | | | %d | %d | %d |" % (totalPasses, totalWarnings, totalErrors))
+
+def log_sbsa(d):
+    sbsaDir = os.path.join(d, "sbsa_results")
+    if os.path.isdir(sbsaDir) == False:
+        print "SBSA results results directory \"%s\" not found.  Skipping." % sbsaDir
+        return -1
+
+    uefi = "not found";
+    linux = "not found";
+    for entry in os.listdir(sbsaDir):
+        if(entry == "uefi"):
+            sbsaUefiLogs = os.path.join(sbsaDir, "uefi", "SbsaResults.log")
+	    try:
+		f = open(sbsaUefiLogs, "r")
+	    except IOError:
+		print "SBSA UEFI results file \"%s\" could not be opened, skipping." % sbsaUefiLogs
+                continue
+            logs = f.read()
+            outFile.write("\n\nSBSA UEFI Test Results\n\n")
+            outFile.write(logs)
+	    uefi = "collected"
+	if(entry=="linux"):
+	    sbsaLinuxLogs = os.path.join(sbsaDir, "linux", "SbsaResults.log")
+	    try:
+		f = open(sbsaLinuxLogs, "r")
+	    except IOError:
+		print "SBSA Linux results file \"%s\" could not be opened, skipping." % sbsaLinuxLogs
+		continue
+            logs = f.read()
+            outFile.write("\n\nSBSA Linux Test Results\n\n")
+            outFile.write(logs)
+	    linux = "collected"
+    print "SBSA Results for linux %s\n" % linux
+    print "SBSA Results for UEFI %s\n" % uefi
+
+# Script entry point.
+
+# This script needs to be run on a stripped out yocto distribution so we can't use argparse.
+if "-h" in sys.argv or "--help" in sys.argv:
+    print "Usage:"
+    print " python %s [-h] LUV_RESULTS OUTPUT_FILE" % sys.argv[0]
+    print "Options:"
+    print " -h, --help              Display this help and exit."
+    print " LUV_RESULTS             Path to luv-results directory/drive."
+    print " OUTPUT_FILE             File for script output, must have .md file extension."
+    exit()
+
+arg_directory = sys.argv[1]
+arg_output = sys.argv[2]
+
+# Validating parameter and opening output file.
+filename, fileext = os.path.splitext(arg_output)
+if fileext != ".md" and fileext != ".MD":
+    print "Output file must have .md file extension. Exiting."
+    exit()
+try:
+    outFile = open(arg_output, "w")
+except IOError:
+    print "Could not open \"%s\" for writing. Exiting." % arg_output
+    exit()
+
+# Scanning FWTS.
+print "Gathering FWTS test results..."
+log_fwts(arg_directory)
+
+# Scanning SBBR.
+print "Gathering UEFI SBBR SCT test results..."
+log_sbbr(arg_directory)
+
+# Scanning SBSA.
+print "Gathering SBSA test results..."
+log_sbsa(arg_directory)
+
+outFile.close()
+
+print "Done, test results can be found in \"%s\"" % arg_output
diff --git a/meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test b/meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test
new file mode 100755
index 0000000..756bc02
--- /dev/null
+++ b/meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+insmod /lib/modules/4.10.0-yocto-standard/extra/sbsa_acs.ko
+mkdir -p $1/sbsa_results/linux
+sbsa > $1/sbsa_results/linux/SbsaResults.log
diff --git a/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager b/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager
index 38aa116..0197db9 100644
--- a/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager
+++ b/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager
@@ -256,6 +256,11 @@ done | awk '/\[\+/  { units += 1 }
 cat /tmp/testsuites | html_inline ${LUV_HTML_REPORT} | tee -a /dev/kmsg /tmp/luv.results \
          ${LUV_SAVE_RESULTS_DIR}/luv.results
 
+# test SBSA compliance on luv
+sh /etc/luv-sbsa-test ${LUV_STORAGE}
+# collecting test results
+python /etc/luv-collect-results ${LUV_STORAGE} ${LUV_STORAGE}/results.md
+
 result=$(cat /tmp/testsuites)
 plymouth_write "$result"
 sleep 2
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb
index 916cc71..cc504a3 100644
--- a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb
@@ -78,6 +78,9 @@ SRC_URI += "file://0001-x86-efi-Move-efi_bgrt_init-to-early-stage.patch \
 SRC_URI += "file://0001-serial-SPCR-check-bit-width-for-the-16550-UART.patch  \
            "
 
+SRC_URI += "file://0001-SBSA-ACS-linux-4.10.patch \
+           "
+
 COMMON_CFG_x86 = " file://${MACHINE}/defconfig \
                    file://qemux86/modules.cfg \
                    file://qemux86/display.cfg \
diff --git a/meta/conf/bitbake.conf b/meta/conf/bitbake.conf
index 54a587f..b05fe94 100644
--- a/meta/conf/bitbake.conf
+++ b/meta/conf/bitbake.conf
@@ -728,7 +728,7 @@ INITRAMFS_FSTYPES ?= "cpio.gz"
 # The maximum size in Kbytes for the generated initramfs image size.
 # Usually, it should be less than 1/2 of ram size, or you may fail to
 # boot it.
-INITRAMFS_MAXSIZE ??= "131072"
+INITRAMFS_MAXSIZE ??= "196608"
 
 DEFAULT_TASK_PROVIDER ?= "packagegroup-base"
 MACHINE_TASK_PROVIDER ?= "${DEFAULT_TASK_PROVIDER}"
diff --git a/sbsa_setup.sh b/sbsa_setup.sh
new file mode 100755
index 0000000..946de8d
--- /dev/null
+++ b/sbsa_setup.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+#create tmp directory
+TMPDIR=$PWD/tmp
+LUVDIR=$PWD
+rm -rf $TMPDIR
+mkdir $TMPDIR
+cd $TMPDIR
+#clone linux-acs repo
+git clone git://linux-arm.org/linux-acs.git
+cd linux-acs
+#copy .bb and source files to relevant places
+mv sbsa-acs-drv $LUVDIR/meta-luv/recipes-core/
+mv kernel/src/0001-SBSA-ACS-linux-4.10.patch $LUVDIR/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/
+
+cd $TMPDIR
+git clone https://github.com/ARM-software/sbsa-acs.git
+cd sbsa-acs
+mv val test_pool $LUVDIR/meta-luv/recipes-core/sbsa-acs-drv/files/
+
+mkdir $LUVDIR/meta-luv/recipes-utils/sbsa-acs-app
+mv linux_app/* $LUVDIR/meta-luv/recipes-utils/sbsa-acs-app/
+
+cd $TMPDIR/..
+rm -rf $TMPDIR
-- 
2.7.4

